<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: struct.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">struct.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Structure type management (assembly level types)  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmember__t.html">member_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a member of an assembly level structure.  <a href="classmember__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstruc__t.html">struc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a structure type (assembly level)  <a href="classstruc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstruct__field__visitor__t.html">struct_field_visitor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements action to take when a field is visited with <a class="el" href="struct_8hpp.html#ab093ca18c1e8f5724f0bb97313ec708b" title="Visit structure fields in a stroff expression or in a reference to a struct data variable.">visit_stroff_fields()</a>  <a href="structstruct__field__visitor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aeb8e473dff428ee0345f5f055a121748"><td class="memItemLeft" align="right" valign="top"><a id="aeb8e473dff428ee0345f5f055a121748" name="aeb8e473dff428ee0345f5f055a121748"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRUC_SEPARATOR</b>&#160;&#160;&#160;'.'</td></tr>
<tr class="memdesc:aeb8e473dff428ee0345f5f055a121748"><td class="mdescLeft">&#160;</td><td class="mdescRight">structname.fieldname <br /></td></tr>
<tr class="separator:aeb8e473dff428ee0345f5f055a121748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfe4bd98a5a647372d6a78cec974b24"><td class="memItemLeft" align="right" valign="top"><a id="accfe4bd98a5a647372d6a78cec974b24" name="accfe4bd98a5a647372d6a78cec974b24"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_OK</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:accfe4bd98a5a647372d6a78cec974b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">is the member ok? (always yes) <br /></td></tr>
<tr class="separator:accfe4bd98a5a647372d6a78cec974b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b7269b6e37b1ac4bb174d975c8b317"><td class="memItemLeft" align="right" valign="top"><a id="a89b7269b6e37b1ac4bb174d975c8b317" name="a89b7269b6e37b1ac4bb174d975c8b317"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_UNIMEM</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:a89b7269b6e37b1ac4bb174d975c8b317"><td class="mdescLeft">&#160;</td><td class="mdescRight">is a member of a union? <br /></td></tr>
<tr class="separator:a89b7269b6e37b1ac4bb174d975c8b317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2762034a9926a1b10785fd30441180a"><td class="memItemLeft" align="right" valign="top"><a id="ab2762034a9926a1b10785fd30441180a" name="ab2762034a9926a1b10785fd30441180a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_HASUNI</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:ab2762034a9926a1b10785fd30441180a"><td class="mdescLeft">&#160;</td><td class="mdescRight">has members of type "union"? <br /></td></tr>
<tr class="separator:ab2762034a9926a1b10785fd30441180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccee9f4292a0f5b3a1cf762487f561e"><td class="memItemLeft" align="right" valign="top"><a id="a4ccee9f4292a0f5b3a1cf762487f561e" name="a4ccee9f4292a0f5b3a1cf762487f561e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_BYTIL</b>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:a4ccee9f4292a0f5b3a1cf762487f561e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the member was created due to the type system <br /></td></tr>
<tr class="separator:a4ccee9f4292a0f5b3a1cf762487f561e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a54e365e7a771b3ce5740f1c3754da"><td class="memItemLeft" align="right" valign="top"><a id="a52a54e365e7a771b3ce5740f1c3754da" name="a52a54e365e7a771b3ce5740f1c3754da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_HASTI</b>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:a52a54e365e7a771b3ce5740f1c3754da"><td class="mdescLeft">&#160;</td><td class="mdescRight">has type information? <br /></td></tr>
<tr class="separator:a52a54e365e7a771b3ce5740f1c3754da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9528b58e4ac4ed1ac2cc5a0a5d16e3"><td class="memItemLeft" align="right" valign="top"><a id="afe9528b58e4ac4ed1ac2cc5a0a5d16e3" name="afe9528b58e4ac4ed1ac2cc5a0a5d16e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_BASECLASS</b>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:afe9528b58e4ac4ed1ac2cc5a0a5d16e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">a special member representing base class <br /></td></tr>
<tr class="separator:afe9528b58e4ac4ed1ac2cc5a0a5d16e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b4e5ac2bc14b75c0f7307911893717"><td class="memItemLeft" align="right" valign="top"><a id="aa5b4e5ac2bc14b75c0f7307911893717" name="aa5b4e5ac2bc14b75c0f7307911893717"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_DTOR</b>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:aa5b4e5ac2bc14b75c0f7307911893717"><td class="mdescLeft">&#160;</td><td class="mdescRight">a special member representing destructor <br /></td></tr>
<tr class="separator:aa5b4e5ac2bc14b75c0f7307911893717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d6153ee27a6311899fd78c6da79d7"><td class="memItemLeft" align="right" valign="top"><a id="a661d6153ee27a6311899fd78c6da79d7" name="a661d6153ee27a6311899fd78c6da79d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_DUPNAME</b>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:a661d6153ee27a6311899fd78c6da79d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">duplicate name resolved with _N suffix (N==soff) <br /></td></tr>
<tr class="separator:a661d6153ee27a6311899fd78c6da79d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b9a9ad3cca19eb631d315e537d384d"><td class="memItemLeft" align="right" valign="top"><a id="a20b9a9ad3cca19eb631d315e537d384d" name="a20b9a9ad3cca19eb631d315e537d384d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MF_RESERVED1</b>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:a20b9a9ad3cca19eb631d315e537d384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved (for internal usage) <br /></td></tr>
<tr class="separator:a20b9a9ad3cca19eb631d315e537d384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2887ca1c10ddaf7ec691ee1a7c506d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#ab2887ca1c10ddaf7ec691ee1a7c506d9">SF_VAR</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:ab2887ca1c10ddaf7ec691ee1a7c506d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">is variable size structure (varstruct)? a variable size structure is one with the zero size last member.  <a href="struct_8hpp.html#ab2887ca1c10ddaf7ec691ee1a7c506d9">More...</a><br /></td></tr>
<tr class="separator:ab2887ca1c10ddaf7ec691ee1a7c506d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179c261302637756337e83e8a8bfde06"><td class="memItemLeft" align="right" valign="top"><a id="a179c261302637756337e83e8a8bfde06" name="a179c261302637756337e83e8a8bfde06"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SF_UNION</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:a179c261302637756337e83e8a8bfde06"><td class="mdescLeft">&#160;</td><td class="mdescRight">is a union? varunions are prohibited! <br /></td></tr>
<tr class="separator:a179c261302637756337e83e8a8bfde06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f266f43562a29fa4495652be7c479d3"><td class="memItemLeft" align="right" valign="top"><a id="a9f266f43562a29fa4495652be7c479d3" name="a9f266f43562a29fa4495652be7c479d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SF_HASUNI</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:a9f266f43562a29fa4495652be7c479d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">has members of type "union"? <br /></td></tr>
<tr class="separator:a9f266f43562a29fa4495652be7c479d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac555d5d6421d2526a0256b9dfd0a89ea"><td class="memItemLeft" align="right" valign="top"><a id="ac555d5d6421d2526a0256b9dfd0a89ea" name="ac555d5d6421d2526a0256b9dfd0a89ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SF_NOLIST</b>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:ac555d5d6421d2526a0256b9dfd0a89ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't include in the chooser list <br /></td></tr>
<tr class="separator:ac555d5d6421d2526a0256b9dfd0a89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf9168b96cf9628391f20a2eef3f67c"><td class="memItemLeft" align="right" valign="top"><a id="a6cf9168b96cf9628391f20a2eef3f67c" name="a6cf9168b96cf9628391f20a2eef3f67c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SF_TYPLIB</b>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:a6cf9168b96cf9628391f20a2eef3f67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the structure comes from type library <br /></td></tr>
<tr class="separator:a6cf9168b96cf9628391f20a2eef3f67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6ed7a6362dc0e44e0f0e4e33249a73"><td class="memItemLeft" align="right" valign="top"><a id="a4e6ed7a6362dc0e44e0f0e4e33249a73" name="a4e6ed7a6362dc0e44e0f0e4e33249a73"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SF_HIDDEN</b>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:a4e6ed7a6362dc0e44e0f0e4e33249a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">the structure is collapsed <br /></td></tr>
<tr class="separator:a4e6ed7a6362dc0e44e0f0e4e33249a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b395347ef66eb4a1faa5c584421a3e8"><td class="memItemLeft" align="right" valign="top"><a id="a1b395347ef66eb4a1faa5c584421a3e8" name="a1b395347ef66eb4a1faa5c584421a3e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SF_FRAME</b>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:a1b395347ef66eb4a1faa5c584421a3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">the structure is a function frame <br /></td></tr>
<tr class="separator:a1b395347ef66eb4a1faa5c584421a3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758f228e585003ae05f1d9e476ccbdd7"><td class="memItemLeft" align="right" valign="top"><a id="a758f228e585003ae05f1d9e476ccbdd7" name="a758f228e585003ae05f1d9e476ccbdd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SF_ALIGN</b>&#160;&#160;&#160;0x00000F80</td></tr>
<tr class="memdesc:a758f228e585003ae05f1d9e476ccbdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">alignment (shift amount: 0..31) <br /></td></tr>
<tr class="separator:a758f228e585003ae05f1d9e476ccbdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19e7396164061042fb789b0ae8dde88"><td class="memItemLeft" align="right" valign="top"><a id="ad19e7396164061042fb789b0ae8dde88" name="ad19e7396164061042fb789b0ae8dde88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SF_GHOST</b>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="memdesc:ad19e7396164061042fb789b0ae8dde88"><td class="mdescLeft">&#160;</td><td class="mdescRight">ghost copy of a local type <br /></td></tr>
<tr class="separator:ad19e7396164061042fb789b0ae8dde88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Internal structures list</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp316f681d435a32c52a27b24c446398de"></a>IDA maintains an internal vector of known structures.</p>
<p >Use these functions to work with this vector. </p>
</td></tr>
<tr class="memitem:a6edae9f56b72795bda4e3acf3b8d58c2"><td class="memItemLeft" align="right" valign="top"><a id="a6edae9f56b72795bda4e3acf3b8d58c2" name="a6edae9f56b72795bda4e3acf3b8d58c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRNFL_REGEX</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a6edae9f56b72795bda4e3acf3b8d58c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply regular expressions to beautify the name <br /></td></tr>
<tr class="separator:a6edae9f56b72795bda4e3acf3b8d58c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b42dbf3a42f5d3276bcd200a55a5889"><td class="memItemLeft" align="right" valign="top"><a id="a3b42dbf3a42f5d3276bcd200a55a5889" name="a3b42dbf3a42f5d3276bcd200a55a5889"></a>
idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc_qty</b> (void)</td></tr>
<tr class="memdesc:a3b42dbf3a42f5d3276bcd200a55a5889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of known structures. <br /></td></tr>
<tr class="separator:a3b42dbf3a42f5d3276bcd200a55a5889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d2ea8f387b1b07aeaab63ba524a610"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a85d2ea8f387b1b07aeaab63ba524a610">get_first_struc_idx</a> (void)</td></tr>
<tr class="memdesc:a85d2ea8f387b1b07aeaab63ba524a610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of first structure.  <a href="struct_8hpp.html#a85d2ea8f387b1b07aeaab63ba524a610">More...</a><br /></td></tr>
<tr class="separator:a85d2ea8f387b1b07aeaab63ba524a610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf74b0f354956a690bc8c770bbfa27a2"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#aaf74b0f354956a690bc8c770bbfa27a2">get_last_struc_idx</a> (void)</td></tr>
<tr class="memdesc:aaf74b0f354956a690bc8c770bbfa27a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of last structure.  <a href="struct_8hpp.html#aaf74b0f354956a690bc8c770bbfa27a2">More...</a><br /></td></tr>
<tr class="separator:aaf74b0f354956a690bc8c770bbfa27a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cde2a9b63c3a8d173ac253e7d49314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a46cde2a9b63c3a8d173ac253e7d49314">get_prev_struc_idx</a> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> idx)</td></tr>
<tr class="memdesc:a46cde2a9b63c3a8d173ac253e7d49314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get previous struct index.  <a href="struct_8hpp.html#a46cde2a9b63c3a8d173ac253e7d49314">More...</a><br /></td></tr>
<tr class="separator:a46cde2a9b63c3a8d173ac253e7d49314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57063f026ec4e0aca498adc1f55d01ec"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a57063f026ec4e0aca498adc1f55d01ec">get_next_struc_idx</a> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> idx)</td></tr>
<tr class="memdesc:a57063f026ec4e0aca498adc1f55d01ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next struct index.  <a href="struct_8hpp.html#a57063f026ec4e0aca498adc1f55d01ec">More...</a><br /></td></tr>
<tr class="separator:a57063f026ec4e0aca498adc1f55d01ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42189a9c7e10a0df284428dfcd7e334"><td class="memItemLeft" align="right" valign="top"><a id="ad42189a9c7e10a0df284428dfcd7e334" name="ad42189a9c7e10a0df284428dfcd7e334"></a>
idaman <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc_idx</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id)</td></tr>
<tr class="memdesc:ad42189a9c7e10a0df284428dfcd7e334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get internal number of the structure. <br /></td></tr>
<tr class="separator:ad42189a9c7e10a0df284428dfcd7e334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b7fc0c2093f385012ddb5b1d05743a"><td class="memItemLeft" align="right" valign="top"><a id="a94b7fc0c2093f385012ddb5b1d05743a" name="a94b7fc0c2093f385012ddb5b1d05743a"></a>
idaman <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc_by_idx</b> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> idx)</td></tr>
<tr class="memdesc:a94b7fc0c2093f385012ddb5b1d05743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get struct id by struct number. <br /></td></tr>
<tr class="separator:a94b7fc0c2093f385012ddb5b1d05743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83f120345806e9bda5412bcdb1a6389"><td class="memItemLeft" align="right" valign="top"><a id="ac83f120345806e9bda5412bcdb1a6389" name="ac83f120345806e9bda5412bcdb1a6389"></a>
idaman <a class="el" href="classstruc__t.html">struc_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id)</td></tr>
<tr class="memdesc:ac83f120345806e9bda5412bcdb1a6389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to struct type info. <br /></td></tr>
<tr class="separator:ac83f120345806e9bda5412bcdb1a6389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608ab3f78637b6ef5391fa6df2736d16"><td class="memItemLeft" align="right" valign="top"><a id="a608ab3f78637b6ef5391fa6df2736d16" name="a608ab3f78637b6ef5391fa6df2736d16"></a>
idaman <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc_id</b> (const char *name)</td></tr>
<tr class="memdesc:a608ab3f78637b6ef5391fa6df2736d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get struct id by name. <br /></td></tr>
<tr class="separator:a608ab3f78637b6ef5391fa6df2736d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee72fea7bed39afe6d8a1c60133b53fc"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#aee72fea7bed39afe6d8a1c60133b53fc">get_struc_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id, int flags=0)</td></tr>
<tr class="memdesc:aee72fea7bed39afe6d8a1c60133b53fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get struct name by id.  <a href="struct_8hpp.html#aee72fea7bed39afe6d8a1c60133b53fc">More...</a><br /></td></tr>
<tr class="separator:aee72fea7bed39afe6d8a1c60133b53fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2408cb47ec3166048e9e6bc0d56b2aa5"><td class="memItemLeft" align="right" valign="top"><a id="a2408cb47ec3166048e9e6bc0d56b2aa5" name="a2408cb47ec3166048e9e6bc0d56b2aa5"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc_name</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id, int flags=0)</td></tr>
<tr class="separator:a2408cb47ec3166048e9e6bc0d56b2aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb015b8375a2c6de54b439c027feabe0"><td class="memItemLeft" align="right" valign="top"><a id="afb015b8375a2c6de54b439c027feabe0" name="afb015b8375a2c6de54b439c027feabe0"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc_cmt</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id, bool repeatable)</td></tr>
<tr class="memdesc:afb015b8375a2c6de54b439c027feabe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get struct comment. <br /></td></tr>
<tr class="separator:afb015b8375a2c6de54b439c027feabe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb57f21963ace541e201cdd0d7ffedd3"><td class="memItemLeft" align="right" valign="top"><a id="adb57f21963ace541e201cdd0d7ffedd3" name="adb57f21963ace541e201cdd0d7ffedd3"></a>
idaman asize_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc_size</b> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr)</td></tr>
<tr class="memdesc:adb57f21963ace541e201cdd0d7ffedd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get struct size (also see <a class="el" href="struct_8hpp.html#abcfd34601634f9dbe96a9402ba717368" title="Get struct size (also see get_struc_size(const struc_t *))">get_struc_size(tid_t)</a>) <br /></td></tr>
<tr class="separator:adb57f21963ace541e201cdd0d7ffedd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfd34601634f9dbe96a9402ba717368"><td class="memItemLeft" align="right" valign="top"><a id="abcfd34601634f9dbe96a9402ba717368" name="abcfd34601634f9dbe96a9402ba717368"></a>
asize_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_struc_size</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id)</td></tr>
<tr class="memdesc:abcfd34601634f9dbe96a9402ba717368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get struct size (also see <a class="el" href="struct_8hpp.html#adb57f21963ace541e201cdd0d7ffedd3" title="Get struct size (also see get_struc_size(tid_t))">get_struc_size(const struc_t *)</a>) <br /></td></tr>
<tr class="separator:abcfd34601634f9dbe96a9402ba717368"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Struct offsets</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp5e7739f4f4c6bce28ac744d60035de88"></a></p><dl class="section note"><dt>Note</dt><dd>for unions, soff == number of the current member </dd></dl>
</td></tr>
<tr class="memitem:a8a1c6621ffba3c30a6377af284fbe1eb"><td class="memItemLeft" align="right" valign="top"><a id="a8a1c6621ffba3c30a6377af284fbe1eb" name="a8a1c6621ffba3c30a6377af284fbe1eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SET_MEMTI_MAY_DESTROY</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a8a1c6621ffba3c30a6377af284fbe1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">may destroy other members <br /></td></tr>
<tr class="separator:a8a1c6621ffba3c30a6377af284fbe1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df3838e610f16430d9df4da57656a88"><td class="memItemLeft" align="right" valign="top"><a id="a2df3838e610f16430d9df4da57656a88" name="a2df3838e610f16430d9df4da57656a88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SET_MEMTI_COMPATIBLE</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a2df3838e610f16430d9df4da57656a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">new type must be compatible with the old <br /></td></tr>
<tr class="separator:a2df3838e610f16430d9df4da57656a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e810dcdad667bc02fc400a115b57e72"><td class="memItemLeft" align="right" valign="top"><a id="a7e810dcdad667bc02fc400a115b57e72" name="a7e810dcdad667bc02fc400a115b57e72"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SET_MEMTI_FUNCARG</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a7e810dcdad667bc02fc400a115b57e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">mptr is function argument (cannot create arrays) <br /></td></tr>
<tr class="separator:a7e810dcdad667bc02fc400a115b57e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1457187807a21538bfd999f0c05514"><td class="memItemLeft" align="right" valign="top"><a id="a8b1457187807a21538bfd999f0c05514" name="a8b1457187807a21538bfd999f0c05514"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SET_MEMTI_BYTIL</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a8b1457187807a21538bfd999f0c05514"><td class="mdescLeft">&#160;</td><td class="mdescRight">new type was created by the type subsystem <br /></td></tr>
<tr class="separator:a8b1457187807a21538bfd999f0c05514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79b78eb8c34a4f4fe940a15ae88b11f"><td class="memItemLeft" align="right" valign="top"><a id="aa79b78eb8c34a4f4fe940a15ae88b11f" name="aa79b78eb8c34a4f4fe940a15ae88b11f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SET_MEMTI_USERTI</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:aa79b78eb8c34a4f4fe940a15ae88b11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">user-specified type <br /></td></tr>
<tr class="separator:aa79b78eb8c34a4f4fe940a15ae88b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e006e866b807ff36125e69097de8a48"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48">struc_error_t</a> { <br />
&#160;&#160;<a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48a7863b4c99228b653a0f9237ff4a9cc79">STRUC_ERROR_MEMBER_OK</a> = 0
, <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48ae71fb6b1f4371ee4f25d99c9e6548462">STRUC_ERROR_MEMBER_NAME</a> = -1
, <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48a6afa947f335ba64eadf32f3a15f6715e">STRUC_ERROR_MEMBER_OFFSET</a> = -2
, <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48a805242b8970597654ade0e741a841ed0">STRUC_ERROR_MEMBER_SIZE</a> = -3
, <br />
&#160;&#160;<a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48a291cb4fd7ae811bc7deda3c7ebac0001">STRUC_ERROR_MEMBER_TINFO</a> = -4
, <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48a018a34286c09650cf855a03209987c4e">STRUC_ERROR_MEMBER_STRUCT</a> = -5
, <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48a5e0299347c70fb398057d8c3e3bf6855">STRUC_ERROR_MEMBER_UNIVAR</a> = -6
, <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48a14b7a50ae1cfd4f23d7a60498fa5ea2d">STRUC_ERROR_MEMBER_VARLAST</a> = -7
, <br />
&#160;&#160;<a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48a549fb77ade937758f3a92462631d0afb">STRUC_ERROR_MEMBER_NESTED</a> = -8
<br />
 }</td></tr>
<tr class="memdesc:a7e006e866b807ff36125e69097de8a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values for <a class="el" href="struct_8hpp.html#af0d1570f7145054ba5cbb7fd987a8c27" title="Add member to existing structure.">add_struc_member()</a>  <a href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48">More...</a><br /></td></tr>
<tr class="separator:a7e006e866b807ff36125e69097de8a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addab072d470c849945079dbd99ee1e21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21">smt_code_t</a> { <br />
&#160;&#160;<a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21ae3524f3e3504ead335b5875996df21aa">SMT_BADARG</a> = -6
, <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21a3171ec61b11eabd4fa0cca7c44c76f74">SMT_NOCOMPAT</a> = -5
, <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21ae9a9caecdd11765cdc5cd0059d43b6e2">SMT_WORSE</a> = -4
, <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21a288f91cdac82c34a7fa0632026d78430">SMT_SIZE</a> = -3
, <br />
&#160;&#160;<a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21af94655ab46422318fcc774a033c4c851">SMT_ARRAY</a> = -2
, <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21ade46ab40e111029e415c77129043fdd5">SMT_OVERLAP</a> = -1
, <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21a40b1a482baceefc13b2c2293517931d2">SMT_FAILED</a> = 0
, <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21af84edb20e8e29624b8f18c9da7516b12">SMT_OK</a> = 1
, <br />
&#160;&#160;<a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21ad8239f9d550dcebe4cc4a2583e640e93">SMT_KEEP</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:addab072d470c849945079dbd99ee1e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Member type information (return values for <a class="el" href="struct_8hpp.html#aaa3683a4790b5ad049a50afc0e0a961e" title="Set tinfo for given member.">set_member_tinfo()</a>)  <a href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21">More...</a><br /></td></tr>
<tr class="separator:addab072d470c849945079dbd99ee1e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50759fd85eebb25000c9a4b7e28b5be3"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a50759fd85eebb25000c9a4b7e28b5be3">get_struc_prev_offset</a> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, ea_t offset)</td></tr>
<tr class="memdesc:a50759fd85eebb25000c9a4b7e28b5be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset of member with largest offset less than 'offset'.  <a href="struct_8hpp.html#a50759fd85eebb25000c9a4b7e28b5be3">More...</a><br /></td></tr>
<tr class="separator:a50759fd85eebb25000c9a4b7e28b5be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe11be18398d534be6b5f4c33a23bf0b"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#afe11be18398d534be6b5f4c33a23bf0b">get_struc_next_offset</a> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, ea_t offset)</td></tr>
<tr class="memdesc:afe11be18398d534be6b5f4c33a23bf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset of member with smallest offset larger than 'offset'.  <a href="struct_8hpp.html#afe11be18398d534be6b5f4c33a23bf0b">More...</a><br /></td></tr>
<tr class="separator:afe11be18398d534be6b5f4c33a23bf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c8cc9e81856e49de9697688e7d14c8"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#ae9c8cc9e81856e49de9697688e7d14c8">get_struc_last_offset</a> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr)</td></tr>
<tr class="memdesc:ae9c8cc9e81856e49de9697688e7d14c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset of last member.  <a href="struct_8hpp.html#ae9c8cc9e81856e49de9697688e7d14c8">More...</a><br /></td></tr>
<tr class="separator:ae9c8cc9e81856e49de9697688e7d14c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79228860947a6137908c25949a91ad5a"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a79228860947a6137908c25949a91ad5a">get_struc_first_offset</a> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr)</td></tr>
<tr class="memdesc:a79228860947a6137908c25949a91ad5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset of first member.  <a href="struct_8hpp.html#a79228860947a6137908c25949a91ad5a">More...</a><br /></td></tr>
<tr class="separator:a79228860947a6137908c25949a91ad5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a834e05b1fc81234b99e6c22cfc898"><td class="memItemLeft" align="right" valign="top"><a id="a71a834e05b1fc81234b99e6c22cfc898" name="a71a834e05b1fc81234b99e6c22cfc898"></a>
ea_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_max_offset</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr)</td></tr>
<tr class="memdesc:a71a834e05b1fc81234b99e6c22cfc898"><td class="mdescLeft">&#160;</td><td class="mdescRight">For unions: returns number of members, for structs: returns size of structure. <br /></td></tr>
<tr class="separator:a71a834e05b1fc81234b99e6c22cfc898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5ae2a74257f36f352a253bac20fa6e"><td class="memItemLeft" align="right" valign="top"><a id="a1e5ae2a74257f36f352a253bac20fa6e" name="a1e5ae2a74257f36f352a253bac20fa6e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_varstr</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id)</td></tr>
<tr class="memdesc:a1e5ae2a74257f36f352a253bac20fa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is variable size structure? <br /></td></tr>
<tr class="separator:a1e5ae2a74257f36f352a253bac20fa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0595fd6aacc279748170b4893c55eb"><td class="memItemLeft" align="right" valign="top"><a id="a1a0595fd6aacc279748170b4893c55eb" name="a1a0595fd6aacc279748170b4893c55eb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_union</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id)</td></tr>
<tr class="memdesc:a1a0595fd6aacc279748170b4893c55eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a union? <br /></td></tr>
<tr class="separator:a1a0595fd6aacc279748170b4893c55eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf971c532282322866c524b5740a35d"><td class="memItemLeft" align="right" valign="top"><a id="aadf971c532282322866c524b5740a35d" name="aadf971c532282322866c524b5740a35d"></a>
idaman <a class="el" href="classstruc__t.html">struc_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_struc</b> (const char *fullname)</td></tr>
<tr class="memdesc:aadf971c532282322866c524b5740a35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get containing structure of member by its full name "struct.field". <br /></td></tr>
<tr class="separator:aadf971c532282322866c524b5740a35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdb2e7b7d20d9f9c4960753349ee077"><td class="memItemLeft" align="right" valign="top"><a id="adcdb2e7b7d20d9f9c4960753349ee077" name="adcdb2e7b7d20d9f9c4960753349ee077"></a>
idaman <a class="el" href="classstruc__t.html">struc_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_sptr</b> (const <a class="el" href="classmember__t.html">member_t</a> *mptr)</td></tr>
<tr class="memdesc:adcdb2e7b7d20d9f9c4960753349ee077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get child struct if member is a struct. <br /></td></tr>
<tr class="separator:adcdb2e7b7d20d9f9c4960753349ee077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb6f0d87ab87abaac77e5f36463b257"><td class="memItemLeft" align="right" valign="top"><a id="afeb6f0d87ab87abaac77e5f36463b257" name="afeb6f0d87ab87abaac77e5f36463b257"></a>
idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_member</b> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, asize_t offset)</td></tr>
<tr class="memdesc:afeb6f0d87ab87abaac77e5f36463b257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get member at given offset. <br /></td></tr>
<tr class="separator:afeb6f0d87ab87abaac77e5f36463b257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa04cf7769f02accfe59b0b317f522d"><td class="memItemLeft" align="right" valign="top"><a id="a9fa04cf7769f02accfe59b0b317f522d" name="a9fa04cf7769f02accfe59b0b317f522d"></a>
<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_id</b> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, asize_t offset)</td></tr>
<tr class="memdesc:a9fa04cf7769f02accfe59b0b317f522d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get member id at given offset. <br /></td></tr>
<tr class="separator:a9fa04cf7769f02accfe59b0b317f522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae880f473b9253f9c5c669d256e1b8194"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#ae880f473b9253f9c5c669d256e1b8194">get_innermost_member</a> (<a class="el" href="classstruc__t.html">struc_t</a> **sptr, asize_t *offset)</td></tr>
<tr class="memdesc:ae880f473b9253f9c5c669d256e1b8194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the innermost member at the given offset.  <a href="struct_8hpp.html#ae880f473b9253f9c5c669d256e1b8194">More...</a><br /></td></tr>
<tr class="separator:ae880f473b9253f9c5c669d256e1b8194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7123e6abe7c64886bcc53a261e5232e7"><td class="memItemLeft" align="right" valign="top"><a id="a7123e6abe7c64886bcc53a261e5232e7" name="a7123e6abe7c64886bcc53a261e5232e7"></a>
idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_by_name</b> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, const char *membername)</td></tr>
<tr class="memdesc:a7123e6abe7c64886bcc53a261e5232e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a member by its name, like "field44". <br /></td></tr>
<tr class="separator:a7123e6abe7c64886bcc53a261e5232e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec8777fac1851e54a1e014b7e35a31b"><td class="memItemLeft" align="right" valign="top"><a id="a3ec8777fac1851e54a1e014b7e35a31b" name="a3ec8777fac1851e54a1e014b7e35a31b"></a>
idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_by_fullname</b> (<a class="el" href="classstruc__t.html">struc_t</a> **sptr_place, const char *fullname)</td></tr>
<tr class="memdesc:a3ec8777fac1851e54a1e014b7e35a31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a member by its fully qualified name, "struct.field". <br /></td></tr>
<tr class="separator:a3ec8777fac1851e54a1e014b7e35a31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cc1eed310356a6f7aca8420f1ed005"><td class="memItemLeft" align="right" valign="top"><a id="a87cc1eed310356a6f7aca8420f1ed005" name="a87cc1eed310356a6f7aca8420f1ed005"></a>
idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_fullname</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> mid)</td></tr>
<tr class="memdesc:a87cc1eed310356a6f7aca8420f1ed005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a member's fully qualified name, "struct.field". <br /></td></tr>
<tr class="separator:a87cc1eed310356a6f7aca8420f1ed005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c9b167158af60380f6afdceab2ca74"><td class="memItemLeft" align="right" valign="top"><a id="af4c9b167158af60380f6afdceab2ca74" name="af4c9b167158af60380f6afdceab2ca74"></a>
idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> mid)</td></tr>
<tr class="memdesc:af4c9b167158af60380f6afdceab2ca74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of structure member. <br /></td></tr>
<tr class="separator:af4c9b167158af60380f6afdceab2ca74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad9f5c50186a6008160af39a0b0865b"><td class="memItemLeft" align="right" valign="top"><a id="a3ad9f5c50186a6008160af39a0b0865b" name="a3ad9f5c50186a6008160af39a0b0865b"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_name</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> mid)</td></tr>
<tr class="separator:a3ad9f5c50186a6008160af39a0b0865b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f68814f41b8c22aaa7607f819f5f8b"><td class="memItemLeft" align="right" valign="top"><a id="a83f68814f41b8c22aaa7607f819f5f8b" name="a83f68814f41b8c22aaa7607f819f5f8b"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_cmt</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> mid, bool repeatable)</td></tr>
<tr class="memdesc:a83f68814f41b8c22aaa7607f819f5f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get comment of structure member. <br /></td></tr>
<tr class="separator:a83f68814f41b8c22aaa7607f819f5f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cf713d0f8b970a0d8e364913bfac5e"><td class="memItemLeft" align="right" valign="top">asize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a43cf713d0f8b970a0d8e364913bfac5e">get_member_size</a> (const <a class="el" href="classmember__t.html">member_t</a> *NONNULL mptr)</td></tr>
<tr class="memdesc:a43cf713d0f8b970a0d8e364913bfac5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of structure member.  <a href="struct_8hpp.html#a43cf713d0f8b970a0d8e364913bfac5e">More...</a><br /></td></tr>
<tr class="separator:a43cf713d0f8b970a0d8e364913bfac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999286bc99d7381de5cd467966f12d1a"><td class="memItemLeft" align="right" valign="top"><a id="a999286bc99d7381de5cd467966f12d1a" name="a999286bc99d7381de5cd467966f12d1a"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_varmember</b> (const <a class="el" href="classmember__t.html">member_t</a> *mptr)</td></tr>
<tr class="memdesc:a999286bc99d7381de5cd467966f12d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is variable size member? <br /></td></tr>
<tr class="separator:a999286bc99d7381de5cd467966f12d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41677908ab576e37e6dbd82d3111642"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#ae41677908ab576e37e6dbd82d3111642">get_best_fit_member</a> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, asize_t offset)</td></tr>
<tr class="memdesc:ae41677908ab576e37e6dbd82d3111642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get member that is most likely referenced by the specified offset.  <a href="struct_8hpp.html#ae41677908ab576e37e6dbd82d3111642">More...</a><br /></td></tr>
<tr class="separator:ae41677908ab576e37e6dbd82d3111642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6053c84e7d10bb4bfeedc4561af9dcb6"><td class="memItemLeft" align="right" valign="top"><a id="a6053c84e7d10bb4bfeedc4561af9dcb6" name="a6053c84e7d10bb4bfeedc4561af9dcb6"></a>
idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_next_member_idx</b> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, asize_t off)</td></tr>
<tr class="memdesc:a6053c84e7d10bb4bfeedc4561af9dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next member idx, if it does not exist, return -1. <br /></td></tr>
<tr class="separator:a6053c84e7d10bb4bfeedc4561af9dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e715f683f9866b727d12232de89659"><td class="memItemLeft" align="right" valign="top"><a id="a55e715f683f9866b727d12232de89659" name="a55e715f683f9866b727d12232de89659"></a>
idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_prev_member_idx</b> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, asize_t off)</td></tr>
<tr class="memdesc:a55e715f683f9866b727d12232de89659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the prev member idx, if it does not exist, return -1. <br /></td></tr>
<tr class="separator:a55e715f683f9866b727d12232de89659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae824ee337c3e36cb1d55cf6d9dbd0fc0"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#ae824ee337c3e36cb1d55cf6d9dbd0fc0">add_struc</a> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> idx, const char *name, bool <a class="el" href="struct_8hpp.html#a1a0595fd6aacc279748170b4893c55eb">is_union</a>=false)</td></tr>
<tr class="memdesc:ae824ee337c3e36cb1d55cf6d9dbd0fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a structure type.  <a href="struct_8hpp.html#ae824ee337c3e36cb1d55cf6d9dbd0fc0">More...</a><br /></td></tr>
<tr class="separator:ae824ee337c3e36cb1d55cf6d9dbd0fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e632561dfb0ff00236fd34b7d93d708"><td class="memItemLeft" align="right" valign="top"><a id="a8e632561dfb0ff00236fd34b7d93d708" name="a8e632561dfb0ff00236fd34b7d93d708"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>del_struc</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr)</td></tr>
<tr class="memdesc:a8e632561dfb0ff00236fd34b7d93d708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a structure type. <br /></td></tr>
<tr class="separator:a8e632561dfb0ff00236fd34b7d93d708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f64fada72a83ec4eebb1d50f53acaad"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a4f64fada72a83ec4eebb1d50f53acaad">set_struc_idx</a> (const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> idx)</td></tr>
<tr class="memdesc:a4f64fada72a83ec4eebb1d50f53acaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set internal number of struct.  <a href="struct_8hpp.html#a4f64fada72a83ec4eebb1d50f53acaad">More...</a><br /></td></tr>
<tr class="separator:a4f64fada72a83ec4eebb1d50f53acaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecda082089d4e107b072e8cf1df8101"><td class="memItemLeft" align="right" valign="top"><a id="a8ecda082089d4e107b072e8cf1df8101" name="a8ecda082089d4e107b072e8cf1df8101"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_struc_align</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, int shift)</td></tr>
<tr class="memdesc:a8ecda082089d4e107b072e8cf1df8101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set structure alignment (<a class="el" href="struct_8hpp.html#a758f228e585003ae05f1d9e476ccbdd7" title="alignment (shift amount: 0..31)">SF_ALIGN</a>) <br /></td></tr>
<tr class="separator:a8ecda082089d4e107b072e8cf1df8101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246899acae2bab0d259f0f44fd50b67d"><td class="memItemLeft" align="right" valign="top"><a id="a246899acae2bab0d259f0f44fd50b67d" name="a246899acae2bab0d259f0f44fd50b67d"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_struc_name</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id, const char *name)</td></tr>
<tr class="memdesc:a246899acae2bab0d259f0f44fd50b67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set structure name. <br /></td></tr>
<tr class="separator:a246899acae2bab0d259f0f44fd50b67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19a8af44f5e0726c488b0eff62ef6b6"><td class="memItemLeft" align="right" valign="top"><a id="ac19a8af44f5e0726c488b0eff62ef6b6" name="ac19a8af44f5e0726c488b0eff62ef6b6"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_struc_cmt</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id, const char *cmt, bool repeatable)</td></tr>
<tr class="memdesc:ac19a8af44f5e0726c488b0eff62ef6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set structure comment. <br /></td></tr>
<tr class="separator:ac19a8af44f5e0726c488b0eff62ef6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d1570f7145054ba5cbb7fd987a8c27"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48">struc_error_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#af0d1570f7145054ba5cbb7fd987a8c27">add_struc_member</a> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, const char *fieldname, ea_t offset, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> flag, const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *mt, asize_t nbytes)</td></tr>
<tr class="memdesc:af0d1570f7145054ba5cbb7fd987a8c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add member to existing structure.  <a href="struct_8hpp.html#af0d1570f7145054ba5cbb7fd987a8c27">More...</a><br /></td></tr>
<tr class="separator:af0d1570f7145054ba5cbb7fd987a8c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee19ab243a3ea3bb160d42db31fe261b"><td class="memItemLeft" align="right" valign="top"><a id="aee19ab243a3ea3bb160d42db31fe261b" name="aee19ab243a3ea3bb160d42db31fe261b"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>del_struc_member</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, ea_t offset)</td></tr>
<tr class="memdesc:aee19ab243a3ea3bb160d42db31fe261b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete member at given offset. <br /></td></tr>
<tr class="separator:aee19ab243a3ea3bb160d42db31fe261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74df0b6078b09eb1d865adc4ea8b07b0"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#a74df0b6078b09eb1d865adc4ea8b07b0">del_struc_members</a> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, ea_t off1, ea_t off2)</td></tr>
<tr class="memdesc:a74df0b6078b09eb1d865adc4ea8b07b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete members which occupy range of offsets (off1..off2).  <a href="struct_8hpp.html#a74df0b6078b09eb1d865adc4ea8b07b0">More...</a><br /></td></tr>
<tr class="separator:a74df0b6078b09eb1d865adc4ea8b07b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee95c35fae8c287a2628f8667e8d1c9d"><td class="memItemLeft" align="right" valign="top"><a id="aee95c35fae8c287a2628f8667e8d1c9d" name="aee95c35fae8c287a2628f8667e8d1c9d"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_member_name</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, ea_t offset, const char *name)</td></tr>
<tr class="memdesc:aee95c35fae8c287a2628f8667e8d1c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set name of member at given offset. <br /></td></tr>
<tr class="separator:aee95c35fae8c287a2628f8667e8d1c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0419f8c527b12014a661d88414d69633"><td class="memItemLeft" align="right" valign="top"><a id="a0419f8c527b12014a661d88414d69633" name="a0419f8c527b12014a661d88414d69633"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_member_type</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, ea_t offset, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> flag, const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *mt, asize_t nbytes)</td></tr>
<tr class="memdesc:a0419f8c527b12014a661d88414d69633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set type of member at given offset (also see <a class="el" href="struct_8hpp.html#af0d1570f7145054ba5cbb7fd987a8c27" title="Add member to existing structure.">add_struc_member()</a>) <br /></td></tr>
<tr class="separator:a0419f8c527b12014a661d88414d69633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaafc1a6aed486c4d49153e7aac1c01"><td class="memItemLeft" align="right" valign="top"><a id="a4aaafc1a6aed486c4d49153e7aac1c01" name="a4aaafc1a6aed486c4d49153e7aac1c01"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_member_cmt</b> (<a class="el" href="classmember__t.html">member_t</a> *mptr, const char *cmt, bool repeatable)</td></tr>
<tr class="memdesc:a4aaafc1a6aed486c4d49153e7aac1c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set member comment. <br /></td></tr>
<tr class="separator:a4aaafc1a6aed486c4d49153e7aac1c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47e2aadfb39daa9c568c494d595b9ce"><td class="memItemLeft" align="right" valign="top"><a id="af47e2aadfb39daa9c568c494d595b9ce" name="af47e2aadfb39daa9c568c494d595b9ce"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>expand_struc</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, ea_t offset, adiff_t delta, bool recalc=true)</td></tr>
<tr class="memdesc:af47e2aadfb39daa9c568c494d595b9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand/Shrink structure type. <br /></td></tr>
<tr class="separator:af47e2aadfb39daa9c568c494d595b9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c207e3ad2f55100a66fec857481aff4"><td class="memItemLeft" align="right" valign="top"><a id="a2c207e3ad2f55100a66fec857481aff4" name="a2c207e3ad2f55100a66fec857481aff4"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>save_struc</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, bool may_update_ltypes=true)</td></tr>
<tr class="memdesc:a2c207e3ad2f55100a66fec857481aff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update struct information in the database (internal function) <br /></td></tr>
<tr class="separator:a2c207e3ad2f55100a66fec857481aff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af151026b7e94f5d12895b0ba92231fcd"><td class="memItemLeft" align="right" valign="top"><a id="af151026b7e94f5d12895b0ba92231fcd" name="af151026b7e94f5d12895b0ba92231fcd"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_struc_hidden</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, bool is_hidden)</td></tr>
<tr class="memdesc:af151026b7e94f5d12895b0ba92231fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hide/unhide a struct type. <br /></td></tr>
<tr class="separator:af151026b7e94f5d12895b0ba92231fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd394f6825ba3151836d155162dec75"><td class="memItemLeft" align="right" valign="top"><a id="a4dd394f6825ba3151836d155162dec75" name="a4dd394f6825ba3151836d155162dec75"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_struc_listed</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, bool is_listed)</td></tr>
<tr class="memdesc:a4dd394f6825ba3151836d155162dec75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/remove a struct type from the struct list. <br /></td></tr>
<tr class="separator:a4dd394f6825ba3151836d155162dec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d1f49726830ad01024d7b6e92d0914"><td class="memItemLeft" align="right" valign="top"><a id="af4d1f49726830ad01024d7b6e92d0914" name="af4d1f49726830ad01024d7b6e92d0914"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_tinfo</b> (<a class="el" href="classtinfo__t.html">tinfo_t</a> *tif, const <a class="el" href="classmember__t.html">member_t</a> *mptr)</td></tr>
<tr class="memdesc:af4d1f49726830ad01024d7b6e92d0914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get tinfo for given member. <br /></td></tr>
<tr class="separator:af4d1f49726830ad01024d7b6e92d0914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baf59d4c878690b5e91cd5d0ce3a68b"><td class="memItemLeft" align="right" valign="top"><a id="a0baf59d4c878690b5e91cd5d0ce3a68b" name="a0baf59d4c878690b5e91cd5d0ce3a68b"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>del_member_tinfo</b> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, <a class="el" href="classmember__t.html">member_t</a> *mptr)</td></tr>
<tr class="memdesc:a0baf59d4c878690b5e91cd5d0ce3a68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete tinfo for given member. <br /></td></tr>
<tr class="separator:a0baf59d4c878690b5e91cd5d0ce3a68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3683a4790b5ad049a50afc0e0a961e"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21">smt_code_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#aaa3683a4790b5ad049a50afc0e0a961e">set_member_tinfo</a> (<a class="el" href="classstruc__t.html">struc_t</a> *sptr, <a class="el" href="classmember__t.html">member_t</a> *mptr, <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> memoff, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, int flags)</td></tr>
<tr class="memdesc:aaa3683a4790b5ad049a50afc0e0a961e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set tinfo for given member.  <a href="struct_8hpp.html#aaa3683a4790b5ad049a50afc0e0a961e">More...</a><br /></td></tr>
<tr class="separator:aaa3683a4790b5ad049a50afc0e0a961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781bca8e23e3b3512e15ff0dae577b23"><td class="memItemLeft" align="right" valign="top"><a id="a781bca8e23e3b3512e15ff0dae577b23" name="a781bca8e23e3b3512e15ff0dae577b23"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_or_guess_member_tinfo</b> (<a class="el" href="classtinfo__t.html">tinfo_t</a> *tif, const <a class="el" href="classmember__t.html">member_t</a> *mptr)</td></tr>
<tr class="memdesc:a781bca8e23e3b3512e15ff0dae577b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get tinfo for given member - if failed, generate a tinfo using information about the member id from the disassembly. <br /></td></tr>
<tr class="separator:a781bca8e23e3b3512e15ff0dae577b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0072e3021d0f21115acf37a00a0d492d"><td class="memItemLeft" align="right" valign="top"><a id="a0072e3021d0f21115acf37a00a0d492d" name="a0072e3021d0f21115acf37a00a0d492d"></a>
<a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>retrieve_member_info</b> (<a class="el" href="unionopinfo__t.html">opinfo_t</a> *buf, const <a class="el" href="classmember__t.html">member_t</a> *mptr)</td></tr>
<tr class="memdesc:a0072e3021d0f21115acf37a00a0d492d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get operand type info for member. <br /></td></tr>
<tr class="separator:a0072e3021d0f21115acf37a00a0d492d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09f9c2f040026d9f1fdb7023f7597ac"><td class="memItemLeft" align="right" valign="top"><a id="ac09f9c2f040026d9f1fdb7023f7597ac" name="ac09f9c2f040026d9f1fdb7023f7597ac"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_anonymous_member_name</b> (const char *name)</td></tr>
<tr class="memdesc:ac09f9c2f040026d9f1fdb7023f7597ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is member name prefixed with "anonymous"? <br /></td></tr>
<tr class="separator:ac09f9c2f040026d9f1fdb7023f7597ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1977b4b76b7643a319a1efb888807e27"><td class="memItemLeft" align="right" valign="top"><a id="a1977b4b76b7643a319a1efb888807e27" name="a1977b4b76b7643a319a1efb888807e27"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_dummy_member_name</b> (const char *name)</td></tr>
<tr class="memdesc:a1977b4b76b7643a319a1efb888807e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is member name an auto-generated name? <br /></td></tr>
<tr class="separator:a1977b4b76b7643a319a1efb888807e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cff5be67367d99f3e1e708899d4c08c"><td class="memItemLeft" align="right" valign="top"><a id="a7cff5be67367d99f3e1e708899d4c08c" name="a7cff5be67367d99f3e1e708899d4c08c"></a>
<a class="el" href="classmember__t.html">member_t</a> *idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_by_id</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out_mname, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> mid, <a class="el" href="classstruc__t.html">struc_t</a> **sptr_place)</td></tr>
<tr class="memdesc:a7cff5be67367d99f3e1e708899d4c08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified member id points to a struct member. <br /></td></tr>
<tr class="separator:a7cff5be67367d99f3e1e708899d4c08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedaafb5d5621a4d63539aeecc8a903c"><td class="memItemLeft" align="right" valign="top"><a id="aeedaafb5d5621a4d63539aeecc8a903c" name="aeedaafb5d5621a4d63539aeecc8a903c"></a>
idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_member_by_id</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> mid, <a class="el" href="classstruc__t.html">struc_t</a> **sptr_place=nullptr)</td></tr>
<tr class="memdesc:aeedaafb5d5621a4d63539aeecc8a903c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified member id points to a struct member. convenience function. <br /></td></tr>
<tr class="separator:aeedaafb5d5621a4d63539aeecc8a903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39757bd78a90d8fbacd95ddd9cd58b9c"><td class="memItemLeft" align="right" valign="top"><a id="a39757bd78a90d8fbacd95ddd9cd58b9c" name="a39757bd78a90d8fbacd95ddd9cd58b9c"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_member_id</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> mid)</td></tr>
<tr class="memdesc:a39757bd78a90d8fbacd95ddd9cd58b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a member id? <br /></td></tr>
<tr class="separator:a39757bd78a90d8fbacd95ddd9cd58b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36f0c122f48b2ff43aa082074c1d325"><td class="memItemLeft" align="right" valign="top"><a id="af36f0c122f48b2ff43aa082074c1d325" name="af36f0c122f48b2ff43aa082074c1d325"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_special_member</b> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id)</td></tr>
<tr class="memdesc:af36f0c122f48b2ff43aa082074c1d325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a special member with the name beginning with ' '? <br /></td></tr>
<tr class="separator:af36f0c122f48b2ff43aa082074c1d325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab093ca18c1e8f5724f0bb97313ec708b"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_8hpp.html#ab093ca18c1e8f5724f0bb97313ec708b">visit_stroff_fields</a> (<a class="el" href="structstruct__field__visitor__t.html">struct_field_visitor_t</a> &amp;sfv, const <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *path, int plen, adiff_t *disp, bool appzero)</td></tr>
<tr class="memdesc:ab093ca18c1e8f5724f0bb97313ec708b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit structure fields in a stroff expression or in a reference to a struct data variable.  <a href="struct_8hpp.html#ab093ca18c1e8f5724f0bb97313ec708b">More...</a><br /></td></tr>
<tr class="separator:ab093ca18c1e8f5724f0bb97313ec708b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd86275b146d73936cdd92cf4d09934"><td class="memItemLeft" align="right" valign="top"><a id="a8cd86275b146d73936cdd92cf4d09934" name="a8cd86275b146d73936cdd92cf4d09934"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>stroff_as_size</b> (int plen, const <a class="el" href="classstruc__t.html">struc_t</a> *sptr, asize_t value)</td></tr>
<tr class="memdesc:a8cd86275b146d73936cdd92cf4d09934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should display a structure offset expression as the structure size? <br /></td></tr>
<tr class="separator:a8cd86275b146d73936cdd92cf4d09934"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Structure type management (assembly level types) </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab2887ca1c10ddaf7ec691ee1a7c506d9" name="ab2887ca1c10ddaf7ec691ee1a7c506d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2887ca1c10ddaf7ec691ee1a7c506d9">&#9670;&nbsp;</a></span>SF_VAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SF_VAR&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is variable size structure (varstruct)? a variable size structure is one with the zero size last member. </p>
<p >if the last member is a varstruct, then the current structure is a varstruct too. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7e006e866b807ff36125e69097de8a48" name="a7e006e866b807ff36125e69097de8a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e006e866b807ff36125e69097de8a48">&#9670;&nbsp;</a></span>struc_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48">struc_error_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return values for <a class="el" href="struct_8hpp.html#af0d1570f7145054ba5cbb7fd987a8c27" title="Add member to existing structure.">add_struc_member()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48a7863b4c99228b653a0f9237ff4a9cc79" name="a7e006e866b807ff36125e69097de8a48a7863b4c99228b653a0f9237ff4a9cc79"></a>STRUC_ERROR_MEMBER_OK&#160;</td><td class="fielddoc"><p >success </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48ae71fb6b1f4371ee4f25d99c9e6548462" name="a7e006e866b807ff36125e69097de8a48ae71fb6b1f4371ee4f25d99c9e6548462"></a>STRUC_ERROR_MEMBER_NAME&#160;</td><td class="fielddoc"><p >already has member with this name (bad name) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48a6afa947f335ba64eadf32f3a15f6715e" name="a7e006e866b807ff36125e69097de8a48a6afa947f335ba64eadf32f3a15f6715e"></a>STRUC_ERROR_MEMBER_OFFSET&#160;</td><td class="fielddoc"><p >already has member at this offset </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48a805242b8970597654ade0e741a841ed0" name="a7e006e866b807ff36125e69097de8a48a805242b8970597654ade0e741a841ed0"></a>STRUC_ERROR_MEMBER_SIZE&#160;</td><td class="fielddoc"><p >bad number of bytes or bad sizeof(type) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48a291cb4fd7ae811bc7deda3c7ebac0001" name="a7e006e866b807ff36125e69097de8a48a291cb4fd7ae811bc7deda3c7ebac0001"></a>STRUC_ERROR_MEMBER_TINFO&#160;</td><td class="fielddoc"><p >bad typeid parameter </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48a018a34286c09650cf855a03209987c4e" name="a7e006e866b807ff36125e69097de8a48a018a34286c09650cf855a03209987c4e"></a>STRUC_ERROR_MEMBER_STRUCT&#160;</td><td class="fielddoc"><p >bad struct id (the 1st argument) </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48a5e0299347c70fb398057d8c3e3bf6855" name="a7e006e866b807ff36125e69097de8a48a5e0299347c70fb398057d8c3e3bf6855"></a>STRUC_ERROR_MEMBER_UNIVAR&#160;</td><td class="fielddoc"><p >unions can't have variable sized members </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48a14b7a50ae1cfd4f23d7a60498fa5ea2d" name="a7e006e866b807ff36125e69097de8a48a14b7a50ae1cfd4f23d7a60498fa5ea2d"></a>STRUC_ERROR_MEMBER_VARLAST&#160;</td><td class="fielddoc"><p >variable sized member should be the last member in the structure </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e006e866b807ff36125e69097de8a48a549fb77ade937758f3a92462631d0afb" name="a7e006e866b807ff36125e69097de8a48a549fb77ade937758f3a92462631d0afb"></a>STRUC_ERROR_MEMBER_NESTED&#160;</td><td class="fielddoc"><p >recursive structure nesting is forbidden </p>
</td></tr>
</table>

</div>
</div>
<a id="addab072d470c849945079dbd99ee1e21" name="addab072d470c849945079dbd99ee1e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addab072d470c849945079dbd99ee1e21">&#9670;&nbsp;</a></span>smt_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21">smt_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Member type information (return values for <a class="el" href="struct_8hpp.html#aaa3683a4790b5ad049a50afc0e0a961e" title="Set tinfo for given member.">set_member_tinfo()</a>) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21ae3524f3e3504ead335b5875996df21aa" name="addab072d470c849945079dbd99ee1e21ae3524f3e3504ead335b5875996df21aa"></a>SMT_BADARG&#160;</td><td class="fielddoc"><p >bad parameters </p>
</td></tr>
<tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21a3171ec61b11eabd4fa0cca7c44c76f74" name="addab072d470c849945079dbd99ee1e21a3171ec61b11eabd4fa0cca7c44c76f74"></a>SMT_NOCOMPAT&#160;</td><td class="fielddoc"><p >the new type is not compatible with the old type </p>
</td></tr>
<tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21ae9a9caecdd11765cdc5cd0059d43b6e2" name="addab072d470c849945079dbd99ee1e21ae9a9caecdd11765cdc5cd0059d43b6e2"></a>SMT_WORSE&#160;</td><td class="fielddoc"><p >the new type is worse than the old type </p>
</td></tr>
<tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21a288f91cdac82c34a7fa0632026d78430" name="addab072d470c849945079dbd99ee1e21a288f91cdac82c34a7fa0632026d78430"></a>SMT_SIZE&#160;</td><td class="fielddoc"><p >the new type is incompatible with the member size </p>
</td></tr>
<tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21af94655ab46422318fcc774a033c4c851" name="addab072d470c849945079dbd99ee1e21af94655ab46422318fcc774a033c4c851"></a>SMT_ARRAY&#160;</td><td class="fielddoc"><p >arrays are forbidden as function arguments </p>
</td></tr>
<tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21ade46ab40e111029e415c77129043fdd5" name="addab072d470c849945079dbd99ee1e21ade46ab40e111029e415c77129043fdd5"></a>SMT_OVERLAP&#160;</td><td class="fielddoc"><p >member would overlap with members that cannot be deleted </p>
</td></tr>
<tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21a40b1a482baceefc13b2c2293517931d2" name="addab072d470c849945079dbd99ee1e21a40b1a482baceefc13b2c2293517931d2"></a>SMT_FAILED&#160;</td><td class="fielddoc"><p >failed to set new member type </p>
</td></tr>
<tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21af84edb20e8e29624b8f18c9da7516b12" name="addab072d470c849945079dbd99ee1e21af84edb20e8e29624b8f18c9da7516b12"></a>SMT_OK&#160;</td><td class="fielddoc"><p >success: changed the member type </p>
</td></tr>
<tr><td class="fieldname"><a id="addab072d470c849945079dbd99ee1e21ad8239f9d550dcebe4cc4a2583e640e93" name="addab072d470c849945079dbd99ee1e21ad8239f9d550dcebe4cc4a2583e640e93"></a>SMT_KEEP&#160;</td><td class="fielddoc"><p >no need to change the member type, the old type is better </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a85d2ea8f387b1b07aeaab63ba524a610" name="a85d2ea8f387b1b07aeaab63ba524a610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d2ea8f387b1b07aeaab63ba524a610">&#9670;&nbsp;</a></span>get_first_struc_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> ida_export get_first_struc_idx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of first structure. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if no known structures, 0 otherwise </dd></dl>

</div>
</div>
<a id="aaf74b0f354956a690bc8c770bbfa27a2" name="aaf74b0f354956a690bc8c770bbfa27a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf74b0f354956a690bc8c770bbfa27a2">&#9670;&nbsp;</a></span>get_last_struc_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> ida_export get_last_struc_idx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of last structure. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if no known structures, <a class="el" href="struct_8hpp.html#a3b42dbf3a42f5d3276bcd200a55a5889" title="Get number of known structures.">get_struc_qty()</a>-1 otherwise </dd></dl>

</div>
</div>
<a id="a46cde2a9b63c3a8d173ac253e7d49314" name="a46cde2a9b63c3a8d173ac253e7d49314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cde2a9b63c3a8d173ac253e7d49314">&#9670;&nbsp;</a></span>get_prev_struc_idx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> get_prev_struc_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get previous struct index. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if resulting index is negative, otherwise idx - 1 </dd></dl>

</div>
</div>
<a id="a57063f026ec4e0aca498adc1f55d01ec" name="a57063f026ec4e0aca498adc1f55d01ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57063f026ec4e0aca498adc1f55d01ec">&#9670;&nbsp;</a></span>get_next_struc_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> ida_export get_next_struc_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next struct index. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if resulting index is out of bounds, otherwise idx++ </dd></dl>

</div>
</div>
<a id="aee72fea7bed39afe6d8a1c60133b53fc" name="aee72fea7bed39afe6d8a1c60133b53fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee72fea7bed39afe6d8a1c60133b53fc">&#9670;&nbsp;</a></span>get_struc_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_struc_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get struct name by id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>buffer to hold the name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">id</td><td>struct id </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td><a class="el" href="group___s_t_r_n_f_l__.html">Struct name flags</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50759fd85eebb25000c9a4b7e28b5be3" name="a50759fd85eebb25000c9a4b7e28b5be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50759fd85eebb25000c9a4b7e28b5be3">&#9670;&nbsp;</a></span>get_struc_prev_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_struc_prev_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get offset of member with largest offset less than 'offset'. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if no prev offset </dd></dl>

</div>
</div>
<a id="afe11be18398d534be6b5f4c33a23bf0b" name="afe11be18398d534be6b5f4c33a23bf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe11be18398d534be6b5f4c33a23bf0b">&#9670;&nbsp;</a></span>get_struc_next_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_struc_next_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get offset of member with smallest offset larger than 'offset'. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if no next offset </dd></dl>

</div>
</div>
<a id="ae9c8cc9e81856e49de9697688e7d14c8" name="ae9c8cc9e81856e49de9697688e7d14c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c8cc9e81856e49de9697688e7d14c8">&#9670;&nbsp;</a></span>get_struc_last_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_struc_last_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get offset of last member. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if memqty == 0 </dd></dl>

</div>
</div>
<a id="a79228860947a6137908c25949a91ad5a" name="a79228860947a6137908c25949a91ad5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79228860947a6137908c25949a91ad5a">&#9670;&nbsp;</a></span>get_struc_first_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_struc_first_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get offset of first member. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if memqty == 0 </dd></dl>

</div>
</div>
<a id="ae880f473b9253f9c5c669d256e1b8194" name="ae880f473b9253f9c5c669d256e1b8194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae880f473b9253f9c5c669d256e1b8194">&#9670;&nbsp;</a></span>get_innermost_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export get_innermost_member </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstruc__t.html">struc_t</a> **&#160;</td>
          <td class="paramname"><em>sptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the innermost member at the given offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sptr</td><td>the starting structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sptr</td><td>the innermost structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>offset into the starting structure </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offset</td><td>remaining offset into the returned member </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">a</td><td>member in SPTR (it is not a structure) or 'nullptr' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43cf713d0f8b970a0d8e364913bfac5e" name="a43cf713d0f8b970a0d8e364913bfac5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cf713d0f8b970a0d8e364913bfac5e">&#9670;&nbsp;</a></span>get_member_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asize_t get_member_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmember__t.html">member_t</a> *NONNULL&#160;</td>
          <td class="paramname"><em>mptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of structure member. </p>
<p >May return 0 for the last member of varstruct. For union members, returns <a class="el" href="classmember__t.html#acc1698d4bdd05601d40c915a80235a38" title="end offset">member_t::eoff</a>. </p>

</div>
</div>
<a id="ae41677908ab576e37e6dbd82d3111642" name="ae41677908ab576e37e6dbd82d3111642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41677908ab576e37e6dbd82d3111642">&#9670;&nbsp;</a></span>get_best_fit_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export get_best_fit_member </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get member that is most likely referenced by the specified offset. </p>
<p >Useful for offsets &gt; sizeof(struct). </p>

</div>
</div>
<a id="ae824ee337c3e36cb1d55cf6d9dbd0fc0" name="ae824ee337c3e36cb1d55cf6d9dbd0fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae824ee337c3e36cb1d55cf6d9dbd0fc0">&#9670;&nbsp;</a></span>add_struc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> ida_export add_struc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_union</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a structure type. </p>
<p >if idx==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> then add as the last idx. if name==nullptr then a name will be generated "struct_%d". </p>

</div>
</div>
<a id="a4f64fada72a83ec4eebb1d50f53acaad" name="a4f64fada72a83ec4eebb1d50f53acaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f64fada72a83ec4eebb1d50f53acaad">&#9670;&nbsp;</a></span>set_struc_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_struc_idx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set internal number of struct. </p>
<p >Also see <a class="el" href="struct_8hpp.html#ad42189a9c7e10a0df284428dfcd7e334" title="Get internal number of the structure.">get_struc_idx()</a>, <a class="el" href="struct_8hpp.html#a94b7fc0c2093f385012ddb5b1d05743a" title="Get struct id by struct number.">get_struc_by_idx()</a>. </p>

</div>
</div>
<a id="af0d1570f7145054ba5cbb7fd987a8c27" name="af0d1570f7145054ba5cbb7fd987a8c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d1570f7145054ba5cbb7fd987a8c27">&#9670;&nbsp;</a></span>add_struc_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="struct_8hpp.html#a7e006e866b807ff36125e69097de8a48">struc_error_t</a> ida_export add_struc_member </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add member to existing structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sptr</td><td>structure to modify </td></tr>
    <tr><td class="paramname">fieldname</td><td>if nullptr, then "anonymous_#" name will be generated </td></tr>
    <tr><td class="paramname">offset</td><td><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> means add to the end of structure </td></tr>
    <tr><td class="paramname">flag</td><td>type + representation bits </td></tr>
    <tr><td class="paramname">mt</td><td>additional info about member type. must be present for structs, offsets, enums, strings, struct offsets. </td></tr>
    <tr><td class="paramname">nbytes</td><td>if == 0 then the structure will be a varstruct. in this case the member should be the last member in the structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74df0b6078b09eb1d865adc4ea8b07b0" name="a74df0b6078b09eb1d865adc4ea8b07b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74df0b6078b09eb1d865adc4ea8b07b0">&#9670;&nbsp;</a></span>del_struc_members()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export del_struc_members </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>off1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>off2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete members which occupy range of offsets (off1..off2). </p>
<dl class="section return"><dt>Returns</dt><dd>number of deleted members or -1 on error </dd></dl>

</div>
</div>
<a id="aaa3683a4790b5ad049a50afc0e0a961e" name="aaa3683a4790b5ad049a50afc0e0a961e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3683a4790b5ad049a50afc0e0a961e">&#9670;&nbsp;</a></span>set_member_tinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="struct_8hpp.html#addab072d470c849945079dbd99ee1e21">smt_code_t</a> ida_export set_member_tinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td>
          <td class="paramname"><em>sptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmember__t.html">member_t</a> *&#160;</td>
          <td class="paramname"><em>mptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td>
          <td class="paramname"><em>memoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set tinfo for given member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sptr</td><td>containing struct </td></tr>
    <tr><td class="paramname">mptr</td><td>target member </td></tr>
    <tr><td class="paramname">memoff</td><td>offset within member </td></tr>
    <tr><td class="paramname">tif</td><td>type info </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_e_t___m_e_m_t_i__.html">Set member tinfo flags</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab093ca18c1e8f5724f0bb97313ec708b" name="ab093ca18c1e8f5724f0bb97313ec708b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab093ca18c1e8f5724f0bb97313ec708b">&#9670;&nbsp;</a></span>visit_stroff_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export visit_stroff_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structstruct__field__visitor__t.html">struct_field_visitor_t</a> &amp;&#160;</td>
          <td class="paramname"><em>sfv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adiff_t *&#160;</td>
          <td class="paramname"><em>disp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appzero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit structure fields in a stroff expression or in a reference to a struct data variable. </p>
<p >This function can be used to enumerate all components of an expression like 'a.b.c'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sfv</td><td>visitor object </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">path</td><td>struct path (path[0] contains the initial struct id) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">plen</td><td>len </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">disp</td><td>offset into structure </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">appzero</td><td>should visit field at offset zero? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
