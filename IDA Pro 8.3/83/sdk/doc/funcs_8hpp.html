<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: funcs.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">funcs.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Routines for working with functions within the disassembled program.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregarg__t.html">regarg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register argument description.  <a href="structregarg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfunc__t.html">func_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function is a set of continuous ranges of addresses with characteristics.  <a href="classfunc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlock__func.html">lock_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to lock a function pointer so it stays valid.  <a href="classlock__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfunc__tail__iterator__t.html">func_tail_iterator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to enumerate all function tails sorted by addresses.  <a href="classfunc__tail__iterator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfunc__item__iterator__t.html">func_item_iterator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to enumerate all function instructions and data sorted by addresses.  <a href="classfunc__item__iterator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfunc__parent__iterator__t.html">func_parent_iterator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to enumerate all function parents sorted by addresses.  <a href="classfunc__parent__iterator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9f89bd6c0cf00b4e346266627a5e5b3a"><td class="memItemLeft" align="right" valign="top"><a id="a9f89bd6c0cf00b4e346266627a5e5b3a" name="a9f89bd6c0cf00b4e346266627a5e5b3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_NORET</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:a9f89bd6c0cf00b4e346266627a5e5b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function doesn't return. <br /></td></tr>
<tr class="separator:a9f89bd6c0cf00b4e346266627a5e5b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96692fe2be20e5de1dd446a87d8424dd"><td class="memItemLeft" align="right" valign="top"><a id="a96692fe2be20e5de1dd446a87d8424dd" name="a96692fe2be20e5de1dd446a87d8424dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_FAR</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:a96692fe2be20e5de1dd446a87d8424dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Far function. <br /></td></tr>
<tr class="separator:a96692fe2be20e5de1dd446a87d8424dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad36171134e3e021961c2849e6abfae"><td class="memItemLeft" align="right" valign="top"><a id="a3ad36171134e3e021961c2849e6abfae" name="a3ad36171134e3e021961c2849e6abfae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_LIB</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:a3ad36171134e3e021961c2849e6abfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library function. <br /></td></tr>
<tr class="separator:a3ad36171134e3e021961c2849e6abfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eb9bcfdebfcce3aaf6e113665739b9"><td class="memItemLeft" align="right" valign="top"><a id="a83eb9bcfdebfcce3aaf6e113665739b9" name="a83eb9bcfdebfcce3aaf6e113665739b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_STATICDEF</b>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:a83eb9bcfdebfcce3aaf6e113665739b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function. <br /></td></tr>
<tr class="separator:a83eb9bcfdebfcce3aaf6e113665739b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c18a77caa51d78fcf13ae598fff4b7c"><td class="memItemLeft" align="right" valign="top"><a id="a5c18a77caa51d78fcf13ae598fff4b7c" name="a5c18a77caa51d78fcf13ae598fff4b7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_FRAME</b>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:a5c18a77caa51d78fcf13ae598fff4b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function uses frame pointer (BP) <br /></td></tr>
<tr class="separator:a5c18a77caa51d78fcf13ae598fff4b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34804c1dcd3a8d02c3c81b5b6b9ef65"><td class="memItemLeft" align="right" valign="top"><a id="ae34804c1dcd3a8d02c3c81b5b6b9ef65" name="ae34804c1dcd3a8d02c3c81b5b6b9ef65"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_USERFAR</b>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:ae34804c1dcd3a8d02c3c81b5b6b9ef65"><td class="mdescLeft">&#160;</td><td class="mdescRight">User has specified far-ness of the function. <br /></td></tr>
<tr class="separator:ae34804c1dcd3a8d02c3c81b5b6b9ef65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d248bf1de00c5bb76bad8590070159"><td class="memItemLeft" align="right" valign="top"><a id="a38d248bf1de00c5bb76bad8590070159" name="a38d248bf1de00c5bb76bad8590070159"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_HIDDEN</b>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:a38d248bf1de00c5bb76bad8590070159"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hidden function chunk. <br /></td></tr>
<tr class="separator:a38d248bf1de00c5bb76bad8590070159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0d02377ae90e10869a3c9130a3d5f4"><td class="memItemLeft" align="right" valign="top"><a id="a4c0d02377ae90e10869a3c9130a3d5f4" name="a4c0d02377ae90e10869a3c9130a3d5f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_THUNK</b>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:a4c0d02377ae90e10869a3c9130a3d5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thunk (jump) function. <br /></td></tr>
<tr class="separator:a4c0d02377ae90e10869a3c9130a3d5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578cedfb8ef7408383fe739c57e35485"><td class="memItemLeft" align="right" valign="top"><a id="a578cedfb8ef7408383fe739c57e35485" name="a578cedfb8ef7408383fe739c57e35485"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_BOTTOMBP</b>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="memdesc:a578cedfb8ef7408383fe739c57e35485"><td class="mdescLeft">&#160;</td><td class="mdescRight">BP points to the bottom of the stack frame. <br /></td></tr>
<tr class="separator:a578cedfb8ef7408383fe739c57e35485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5642dcc557a7cc6237a5ad2b0f7518b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a5642dcc557a7cc6237a5ad2b0f7518b3">FUNC_NORET_PENDING</a>&#160;&#160;&#160;0x00200</td></tr>
<tr class="memdesc:a5642dcc557a7cc6237a5ad2b0f7518b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function 'non-return' analysis must be performed.  <a href="funcs_8hpp.html#a5642dcc557a7cc6237a5ad2b0f7518b3">More...</a><br /></td></tr>
<tr class="separator:a5642dcc557a7cc6237a5ad2b0f7518b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705fa62af6e2f9c71165c9e789e6db24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a705fa62af6e2f9c71165c9e789e6db24">FUNC_SP_READY</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="memdesc:a705fa62af6e2f9c71165c9e789e6db24"><td class="mdescLeft">&#160;</td><td class="mdescRight">SP-analysis has been performed.  <a href="funcs_8hpp.html#a705fa62af6e2f9c71165c9e789e6db24">More...</a><br /></td></tr>
<tr class="separator:a705fa62af6e2f9c71165c9e789e6db24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598d4230a03182337e451b4d7e90776b"><td class="memItemLeft" align="right" valign="top"><a id="a598d4230a03182337e451b4d7e90776b" name="a598d4230a03182337e451b4d7e90776b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_FUZZY_SP</b>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="memdesc:a598d4230a03182337e451b4d7e90776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function changes SP in untraceable way, for example: and esp, 0FFFFFFF0h. <br /></td></tr>
<tr class="separator:a598d4230a03182337e451b4d7e90776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270dfb7dcdbddab712480e3c9516a1c8"><td class="memItemLeft" align="right" valign="top"><a id="a270dfb7dcdbddab712480e3c9516a1c8" name="a270dfb7dcdbddab712480e3c9516a1c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_PROLOG_OK</b>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="memdesc:a270dfb7dcdbddab712480e3c9516a1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prolog analysis has been performed by last SP-analysis. <br /></td></tr>
<tr class="separator:a270dfb7dcdbddab712480e3c9516a1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda3bf9abb0f4029d6e258b878ef7d13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#aeda3bf9abb0f4029d6e258b878ef7d13">FUNC_PURGED_OK</a>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="memdesc:aeda3bf9abb0f4029d6e258b878ef7d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">'argsize' field has been validated.  <a href="funcs_8hpp.html#aeda3bf9abb0f4029d6e258b878ef7d13">More...</a><br /></td></tr>
<tr class="separator:aeda3bf9abb0f4029d6e258b878ef7d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8193dd74d95481badc272c645e5dc910"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a8193dd74d95481badc272c645e5dc910">FUNC_TAIL</a>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="memdesc:a8193dd74d95481badc272c645e5dc910"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a function tail.  <a href="funcs_8hpp.html#a8193dd74d95481badc272c645e5dc910">More...</a><br /></td></tr>
<tr class="separator:a8193dd74d95481badc272c645e5dc910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072bad79f877ea68ef3686dc8ae7c293"><td class="memItemLeft" align="right" valign="top"><a id="a072bad79f877ea68ef3686dc8ae7c293" name="a072bad79f877ea68ef3686dc8ae7c293"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_LUMINA</b>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="memdesc:a072bad79f877ea68ef3686dc8ae7c293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function info is provided by Lumina. <br /></td></tr>
<tr class="separator:a072bad79f877ea68ef3686dc8ae7c293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370efd4fc11ab8fa51d15f6adbc47d7c"><td class="memItemLeft" align="right" valign="top"><a id="a370efd4fc11ab8fa51d15f6adbc47d7c" name="a370efd4fc11ab8fa51d15f6adbc47d7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_OUTLINE</b>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="memdesc:a370efd4fc11ab8fa51d15f6adbc47d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outlined code, not a real function. <br /></td></tr>
<tr class="separator:a370efd4fc11ab8fa51d15f6adbc47d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9895d0fbf5e28e7e657e0f6cf19d6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#aab9895d0fbf5e28e7e657e0f6cf19d6d">FUNC_REANALYZE</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="memdesc:aab9895d0fbf5e28e7e657e0f6cf19d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function frame changed, request to reanalyze the function after the last insn is analyzed.  <a href="funcs_8hpp.html#aab9895d0fbf5e28e7e657e0f6cf19d6d">More...</a><br /></td></tr>
<tr class="separator:aab9895d0fbf5e28e7e657e0f6cf19d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf462cd830f80efe2140b415df6ea3a5"><td class="memItemLeft" align="right" valign="top"><a id="abf462cd830f80efe2140b415df6ea3a5" name="abf462cd830f80efe2140b415df6ea3a5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_RESERVED</b>&#160;&#160;&#160;0x8000000000000000LL</td></tr>
<tr class="memdesc:abf462cd830f80efe2140b415df6ea3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved (for internal usage) <br /></td></tr>
<tr class="separator:abf462cd830f80efe2140b415df6ea3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e802fd7fa28afa28c8685920ed2aa8"><td class="memItemLeft" align="right" valign="top"><a id="a49e802fd7fa28afa28c8685920ed2aa8" name="a49e802fd7fa28afa28c8685920ed2aa8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MOVE_FUNC_OK</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a49e802fd7fa28afa28c8685920ed2aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ok <br /></td></tr>
<tr class="separator:a49e802fd7fa28afa28c8685920ed2aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7cff5af7aa06b571dc99bb3dc08d42"><td class="memItemLeft" align="right" valign="top"><a id="aed7cff5af7aa06b571dc99bb3dc08d42" name="aed7cff5af7aa06b571dc99bb3dc08d42"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MOVE_FUNC_NOCODE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aed7cff5af7aa06b571dc99bb3dc08d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">no instruction at 'newstart' <br /></td></tr>
<tr class="separator:aed7cff5af7aa06b571dc99bb3dc08d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12adb873df28d8973afac8d9ca526233"><td class="memItemLeft" align="right" valign="top"><a id="a12adb873df28d8973afac8d9ca526233" name="a12adb873df28d8973afac8d9ca526233"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MOVE_FUNC_BADSTART</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a12adb873df28d8973afac8d9ca526233"><td class="mdescLeft">&#160;</td><td class="mdescRight">bad new start address <br /></td></tr>
<tr class="separator:a12adb873df28d8973afac8d9ca526233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b49a13caa3d3983e3a7e88b71bd9f2"><td class="memItemLeft" align="right" valign="top"><a id="a42b49a13caa3d3983e3a7e88b71bd9f2" name="a42b49a13caa3d3983e3a7e88b71bd9f2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MOVE_FUNC_NOFUNC</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a42b49a13caa3d3983e3a7e88b71bd9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">no function at 'ea' <br /></td></tr>
<tr class="separator:a42b49a13caa3d3983e3a7e88b71bd9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a79967c372781217e27fef006c4763"><td class="memItemLeft" align="right" valign="top"><a id="a82a79967c372781217e27fef006c4763" name="a82a79967c372781217e27fef006c4763"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MOVE_FUNC_REFUSED</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a82a79967c372781217e27fef006c4763"><td class="mdescLeft">&#160;</td><td class="mdescRight">a plugin refused the action <br /></td></tr>
<tr class="separator:a82a79967c372781217e27fef006c4763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc06fe8ec5d4434488efb28d79205bdd"><td class="memItemLeft" align="right" valign="top"><a id="adc06fe8ec5d4434488efb28d79205bdd" name="adc06fe8ec5d4434488efb28d79205bdd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FIND_FUNC_NORMAL</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:adc06fe8ec5d4434488efb28d79205bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop processing if undefined byte is encountered <br /></td></tr>
<tr class="separator:adc06fe8ec5d4434488efb28d79205bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625d181ea2205e5fe3a844f61f1bfca6"><td class="memItemLeft" align="right" valign="top"><a id="a625d181ea2205e5fe3a844f61f1bfca6" name="a625d181ea2205e5fe3a844f61f1bfca6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FIND_FUNC_DEFINE</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a625d181ea2205e5fe3a844f61f1bfca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">create instruction if undefined byte is encountered <br /></td></tr>
<tr class="separator:a625d181ea2205e5fe3a844f61f1bfca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9d638c1a974a95cfaa9ee750cef097"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a1f9d638c1a974a95cfaa9ee750cef097">FIND_FUNC_IGNOREFN</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a1f9d638c1a974a95cfaa9ee750cef097"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore existing function boundaries.  <a href="funcs_8hpp.html#a1f9d638c1a974a95cfaa9ee750cef097">More...</a><br /></td></tr>
<tr class="separator:a1f9d638c1a974a95cfaa9ee750cef097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9d7a5331e580e06b9b3ce911f635d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a6c9d7a5331e580e06b9b3ce911f635d7">FIND_FUNC_KEEPBD</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a6c9d7a5331e580e06b9b3ce911f635d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not modify incoming function boundaries, just create instructions inside the boundaries.  <a href="funcs_8hpp.html#a6c9d7a5331e580e06b9b3ce911f635d7">More...</a><br /></td></tr>
<tr class="separator:a6c9d7a5331e580e06b9b3ce911f635d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e201eff6859ad0590bbe4db125570f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a3e201eff6859ad0590bbe4db125570f0">FIND_FUNC_UNDEF</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a3e201eff6859ad0590bbe4db125570f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">function has instructions that pass execution flow to unexplored bytes.  <a href="funcs_8hpp.html#a3e201eff6859ad0590bbe4db125570f0">More...</a><br /></td></tr>
<tr class="separator:a3e201eff6859ad0590bbe4db125570f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3153bb9e99648e6306129e5654b0b2"><td class="memItemLeft" align="right" valign="top"><a id="adc3153bb9e99648e6306129e5654b0b2" name="adc3153bb9e99648e6306129e5654b0b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FIND_FUNC_OK</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:adc3153bb9e99648e6306129e5654b0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ok, 'nfn' is ready for <a class="el" href="funcs_8hpp.html#a43dfcfff5941536b5b16d5ea160cce8a" title="Add a new function.">add_func()</a> <br /></td></tr>
<tr class="separator:adc3153bb9e99648e6306129e5654b0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c77ab371a3816e3d90f1f9f48710bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ae1c77ab371a3816e3d90f1f9f48710bd">FIND_FUNC_EXIST</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ae1c77ab371a3816e3d90f1f9f48710bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function exists already.  <a href="funcs_8hpp.html#ae1c77ab371a3816e3d90f1f9f48710bd">More...</a><br /></td></tr>
<tr class="separator:ae1c77ab371a3816e3d90f1f9f48710bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc5031907dd057a3d76ff9a19fba350"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#acbc5031907dd057a3d76ff9a19fba350">DECLARE_FUNC_ITERATORS</a>(prefix)</td></tr>
<tr class="memdesc:acbc5031907dd057a3d76ff9a19fba350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare helper functions for <a class="el" href="classfunc__item__iterator__t.html" title="Class to enumerate all function instructions and data sorted by addresses.">func_item_iterator_t</a>.  <a href="funcs_8hpp.html#acbc5031907dd057a3d76ff9a19fba350">More...</a><br /></td></tr>
<tr class="separator:acbc5031907dd057a3d76ff9a19fba350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8363d8e95532a1b9529d57fdc3a29d0d"><td class="memItemLeft" align="right" valign="top"><a id="a8363d8e95532a1b9529d57fdc3a29d0d" name="a8363d8e95532a1b9529d57fdc3a29d0d"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>free_regarg</b> (struct <a class="el" href="structregarg__t.html">regarg_t</a> *v)</td></tr>
<tr class="separator:a8363d8e95532a1b9529d57fdc3a29d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69925eef4a6347fd8f9026225604909"><td class="memItemLeft" align="right" valign="top"><a id="ab69925eef4a6347fd8f9026225604909" name="ab69925eef4a6347fd8f9026225604909"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_func_entry</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:ab69925eef4a6347fd8f9026225604909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does function describe a function entry chunk? <br /></td></tr>
<tr class="separator:ab69925eef4a6347fd8f9026225604909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac798e57513ae645a9682c4ea695d754d"><td class="memItemLeft" align="right" valign="top"><a id="ac798e57513ae645a9682c4ea695d754d" name="ac798e57513ae645a9682c4ea695d754d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_func_tail</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:ac798e57513ae645a9682c4ea695d754d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does function describe a function tail chunk? <br /></td></tr>
<tr class="separator:ac798e57513ae645a9682c4ea695d754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381aa5ad285df1295afbe5a70825dbf4"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a381aa5ad285df1295afbe5a70825dbf4">lock_func_range</a> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn, bool lock)</td></tr>
<tr class="memdesc:a381aa5ad285df1295afbe5a70825dbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock function pointer Locked pointers are guaranteed to remain valid until they are unlocked.  <a href="funcs_8hpp.html#a381aa5ad285df1295afbe5a70825dbf4">More...</a><br /></td></tr>
<tr class="separator:a381aa5ad285df1295afbe5a70825dbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1b284ab27a052c1276f71e8d5bc091"><td class="memItemLeft" align="right" valign="top"><a id="a5b1b284ab27a052c1276f71e8d5bc091" name="a5b1b284ab27a052c1276f71e8d5bc091"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_func_locked</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a5b1b284ab27a052c1276f71e8d5bc091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the function pointer locked? <br /></td></tr>
<tr class="separator:a5b1b284ab27a052c1276f71e8d5bc091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ee6619c160f8191cd89381132c4c20"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a69ee6619c160f8191cd89381132c4c20">get_func</a> (ea_t ea)</td></tr>
<tr class="memdesc:a69ee6619c160f8191cd89381132c4c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to function structure by address.  <a href="funcs_8hpp.html#a69ee6619c160f8191cd89381132c4c20">More...</a><br /></td></tr>
<tr class="separator:a69ee6619c160f8191cd89381132c4c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdde3cac23887c5c536ae79d2f9093b"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a3fdde3cac23887c5c536ae79d2f9093b">get_func_chunknum</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="memdesc:a3fdde3cac23887c5c536ae79d2f9093b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the containing tail chunk of 'ea'.  <a href="funcs_8hpp.html#a3fdde3cac23887c5c536ae79d2f9093b">More...</a><br /></td></tr>
<tr class="separator:a3fdde3cac23887c5c536ae79d2f9093b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1d8703e0e1d004e009d089258ea46f"><td class="memItemLeft" align="right" valign="top"><a id="a9c1d8703e0e1d004e009d089258ea46f" name="a9c1d8703e0e1d004e009d089258ea46f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>func_contains</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="memdesc:a9c1d8703e0e1d004e009d089258ea46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given function contain the given address? <br /></td></tr>
<tr class="separator:a9c1d8703e0e1d004e009d089258ea46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40503b8a0e15e31b016135aedd87267"><td class="memItemLeft" align="right" valign="top"><a id="ae40503b8a0e15e31b016135aedd87267" name="ae40503b8a0e15e31b016135aedd87267"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_same_func</b> (ea_t ea1, ea_t ea2)</td></tr>
<tr class="memdesc:ae40503b8a0e15e31b016135aedd87267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do two addresses belong to the same function? <br /></td></tr>
<tr class="separator:ae40503b8a0e15e31b016135aedd87267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a4ce6b6edc50c1a43f0d8cae7309fc"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a03a4ce6b6edc50c1a43f0d8cae7309fc">getn_func</a> (size_t n)</td></tr>
<tr class="memdesc:a03a4ce6b6edc50c1a43f0d8cae7309fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to function structure by number.  <a href="funcs_8hpp.html#a03a4ce6b6edc50c1a43f0d8cae7309fc">More...</a><br /></td></tr>
<tr class="separator:a03a4ce6b6edc50c1a43f0d8cae7309fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dd1d91e9eb3d3bab69abed43be3aee"><td class="memItemLeft" align="right" valign="top"><a id="a22dd1d91e9eb3d3bab69abed43be3aee" name="a22dd1d91e9eb3d3bab69abed43be3aee"></a>
idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_func_qty</b> (void)</td></tr>
<tr class="memdesc:a22dd1d91e9eb3d3bab69abed43be3aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of functions in the program. <br /></td></tr>
<tr class="separator:a22dd1d91e9eb3d3bab69abed43be3aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f8b164bb6112dbc21bfecd4763c58a"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#aa1f8b164bb6112dbc21bfecd4763c58a">get_func_num</a> (ea_t ea)</td></tr>
<tr class="memdesc:aa1f8b164bb6112dbc21bfecd4763c58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ordinal number of a function.  <a href="funcs_8hpp.html#aa1f8b164bb6112dbc21bfecd4763c58a">More...</a><br /></td></tr>
<tr class="separator:aa1f8b164bb6112dbc21bfecd4763c58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934e746c1e5fe415816cc46160258ce7"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a934e746c1e5fe415816cc46160258ce7">get_prev_func</a> (ea_t ea)</td></tr>
<tr class="memdesc:a934e746c1e5fe415816cc46160258ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the previous function.  <a href="funcs_8hpp.html#a934e746c1e5fe415816cc46160258ce7">More...</a><br /></td></tr>
<tr class="separator:a934e746c1e5fe415816cc46160258ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed86b7fef649d785a4c75171ee40ccd3"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#aed86b7fef649d785a4c75171ee40ccd3">get_next_func</a> (ea_t ea)</td></tr>
<tr class="memdesc:aed86b7fef649d785a4c75171ee40ccd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the next function.  <a href="funcs_8hpp.html#aed86b7fef649d785a4c75171ee40ccd3">More...</a><br /></td></tr>
<tr class="separator:aed86b7fef649d785a4c75171ee40ccd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fc740f61121d71d6958030fa06e677"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a11fc740f61121d71d6958030fa06e677">get_func_ranges</a> (<a class="el" href="classrangeset__t.html">rangeset_t</a> *ranges, <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a11fc740f61121d71d6958030fa06e677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function ranges.  <a href="funcs_8hpp.html#a11fc740f61121d71d6958030fa06e677">More...</a><br /></td></tr>
<tr class="separator:a11fc740f61121d71d6958030fa06e677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadbb1e0b11eae2e34730ede51d1ed38"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#aeadbb1e0b11eae2e34730ede51d1ed38">get_func_cmt</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classfunc__t.html">func_t</a> *pfn, bool repeatable)</td></tr>
<tr class="memdesc:aeadbb1e0b11eae2e34730ede51d1ed38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function comment.  <a href="funcs_8hpp.html#aeadbb1e0b11eae2e34730ede51d1ed38">More...</a><br /></td></tr>
<tr class="separator:aeadbb1e0b11eae2e34730ede51d1ed38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49070bb3dbf2ca55720d20db3a44c9f0"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a49070bb3dbf2ca55720d20db3a44c9f0">set_func_cmt</a> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn, const char *cmt, bool repeatable)</td></tr>
<tr class="memdesc:a49070bb3dbf2ca55720d20db3a44c9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set function comment.  <a href="funcs_8hpp.html#a49070bb3dbf2ca55720d20db3a44c9f0">More...</a><br /></td></tr>
<tr class="separator:a49070bb3dbf2ca55720d20db3a44c9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184f1967b3f6e7d00e02e4d97a41e836"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a184f1967b3f6e7d00e02e4d97a41e836">update_func</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a184f1967b3f6e7d00e02e4d97a41e836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update information about a function in the database (<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a>).  <a href="funcs_8hpp.html#a184f1967b3f6e7d00e02e4d97a41e836">More...</a><br /></td></tr>
<tr class="separator:a184f1967b3f6e7d00e02e4d97a41e836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d69de76e1743db96e0d7ecf7909dc2"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a55d69de76e1743db96e0d7ecf7909dc2">add_func_ex</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a55d69de76e1743db96e0d7ecf7909dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new function.  <a href="funcs_8hpp.html#a55d69de76e1743db96e0d7ecf7909dc2">More...</a><br /></td></tr>
<tr class="separator:a55d69de76e1743db96e0d7ecf7909dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dfcfff5941536b5b16d5ea160cce8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a43dfcfff5941536b5b16d5ea160cce8a">add_func</a> (ea_t ea1, ea_t ea2=<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a>)</td></tr>
<tr class="memdesc:a43dfcfff5941536b5b16d5ea160cce8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new function.  <a href="funcs_8hpp.html#a43dfcfff5941536b5b16d5ea160cce8a">More...</a><br /></td></tr>
<tr class="separator:a43dfcfff5941536b5b16d5ea160cce8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a9f424e35fdf6393b44bf35f36832f"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ac8a9f424e35fdf6393b44bf35f36832f">del_func</a> (ea_t ea)</td></tr>
<tr class="memdesc:ac8a9f424e35fdf6393b44bf35f36832f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a function.  <a href="funcs_8hpp.html#ac8a9f424e35fdf6393b44bf35f36832f">More...</a><br /></td></tr>
<tr class="separator:ac8a9f424e35fdf6393b44bf35f36832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0e8d3e2712894d3b4b3fdea39cd5c3"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#aea0e8d3e2712894d3b4b3fdea39cd5c3">set_func_start</a> (ea_t ea, ea_t newstart)</td></tr>
<tr class="memdesc:aea0e8d3e2712894d3b4b3fdea39cd5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move function chunk start address.  <a href="funcs_8hpp.html#aea0e8d3e2712894d3b4b3fdea39cd5c3">More...</a><br /></td></tr>
<tr class="separator:aea0e8d3e2712894d3b4b3fdea39cd5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7548171011040223d66c8740d7098d32"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a7548171011040223d66c8740d7098d32">set_func_end</a> (ea_t ea, ea_t newend)</td></tr>
<tr class="memdesc:a7548171011040223d66c8740d7098d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move function chunk end address.  <a href="funcs_8hpp.html#a7548171011040223d66c8740d7098d32">More...</a><br /></td></tr>
<tr class="separator:a7548171011040223d66c8740d7098d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ed5ff5471d43941271df7cb0a54cd0"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#af4ed5ff5471d43941271df7cb0a54cd0">reanalyze_function</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea1=0, ea_t ea2=<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a>, bool analyze_parents=false)</td></tr>
<tr class="memdesc:af4ed5ff5471d43941271df7cb0a54cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reanalyze a function.  <a href="funcs_8hpp.html#af4ed5ff5471d43941271df7cb0a54cd0">More...</a><br /></td></tr>
<tr class="separator:af4ed5ff5471d43941271df7cb0a54cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27a7eb0cc4e210f6ffa21e6aa06e589"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#af27a7eb0cc4e210f6ffa21e6aa06e589">find_func_bounds</a> (<a class="el" href="classfunc__t.html">func_t</a> *nfn, int flags)</td></tr>
<tr class="memdesc:af27a7eb0cc4e210f6ffa21e6aa06e589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the boundaries of a new function.  <a href="funcs_8hpp.html#af27a7eb0cc4e210f6ffa21e6aa06e589">More...</a><br /></td></tr>
<tr class="separator:af27a7eb0cc4e210f6ffa21e6aa06e589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee61d9e3082565c8e941377a5b150c5"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#aaee61d9e3082565c8e941377a5b150c5">get_func_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea)</td></tr>
<tr class="memdesc:aaee61d9e3082565c8e941377a5b150c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function name.  <a href="funcs_8hpp.html#aaee61d9e3082565c8e941377a5b150c5">More...</a><br /></td></tr>
<tr class="separator:aaee61d9e3082565c8e941377a5b150c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa98c6848186d239d12588f84e7c2e5"><td class="memItemLeft" align="right" valign="top">idaman asize_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#acaa98c6848186d239d12588f84e7c2e5">calc_func_size</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:acaa98c6848186d239d12588f84e7c2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate function size.  <a href="funcs_8hpp.html#acaa98c6848186d239d12588f84e7c2e5">More...</a><br /></td></tr>
<tr class="separator:acaa98c6848186d239d12588f84e7c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c60a7de477ea88c24a5cecf5722942"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ac1c60a7de477ea88c24a5cecf5722942">get_func_bitness</a> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:ac1c60a7de477ea88c24a5cecf5722942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function bitness (which is equal to the function segment bitness).  <a href="funcs_8hpp.html#ac1c60a7de477ea88c24a5cecf5722942">More...</a><br /></td></tr>
<tr class="separator:ac1c60a7de477ea88c24a5cecf5722942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9717f0f01699931eb94276d3c529b34c"><td class="memItemLeft" align="right" valign="top"><a id="a9717f0f01699931eb94276d3c529b34c" name="a9717f0f01699931eb94276d3c529b34c"></a>
int idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_func_bits</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a9717f0f01699931eb94276d3c529b34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bits in the function addressing. <br /></td></tr>
<tr class="separator:a9717f0f01699931eb94276d3c529b34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46de47bb9d73604bde35ed252b638cd"><td class="memItemLeft" align="right" valign="top"><a id="af46de47bb9d73604bde35ed252b638cd" name="af46de47bb9d73604bde35ed252b638cd"></a>
int idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_func_bytes</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:af46de47bb9d73604bde35ed252b638cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes in the function addressing. <br /></td></tr>
<tr class="separator:af46de47bb9d73604bde35ed252b638cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43324a92becc4d10ff14387339d68e0"><td class="memItemLeft" align="right" valign="top"><a id="af43324a92becc4d10ff14387339d68e0" name="af43324a92becc4d10ff14387339d68e0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_visible_func</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:af43324a92becc4d10ff14387339d68e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the function visible (not hidden)? <br /></td></tr>
<tr class="separator:af43324a92becc4d10ff14387339d68e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3196f5735da224e4f5a42dd30f2786"><td class="memItemLeft" align="right" valign="top"><a id="adc3196f5735da224e4f5a42dd30f2786" name="adc3196f5735da224e4f5a42dd30f2786"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_finally_visible_func</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:adc3196f5735da224e4f5a42dd30f2786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the function visible (event after considering <a class="el" href="ida_8hpp.html#a94d070157b5d5458eb76bdfa9e03f55b" title="show hidden functions">SCF_SHHID_FUNC</a>)? <br /></td></tr>
<tr class="separator:adc3196f5735da224e4f5a42dd30f2786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b430fb82b48859c63faf67a73c2200"><td class="memItemLeft" align="right" valign="top"><a id="ae5b430fb82b48859c63faf67a73c2200" name="ae5b430fb82b48859c63faf67a73c2200"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_visible_func</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, bool visible)</td></tr>
<tr class="memdesc:ae5b430fb82b48859c63faf67a73c2200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set visibility of function. <br /></td></tr>
<tr class="separator:ae5b430fb82b48859c63faf67a73c2200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce3d589a62220b86154f5b43bd9d51a"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a1ce3d589a62220b86154f5b43bd9d51a">set_func_name_if_jumpfunc</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, const char *oldname)</td></tr>
<tr class="memdesc:a1ce3d589a62220b86154f5b43bd9d51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a meaningful name to function if it consists of only 'jump' instruction.  <a href="funcs_8hpp.html#a1ce3d589a62220b86154f5b43bd9d51a">More...</a><br /></td></tr>
<tr class="separator:a1ce3d589a62220b86154f5b43bd9d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819926f1d7697e0eb65015230c1e3d7"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a3819926f1d7697e0eb65015230c1e3d7">calc_thunk_func_target</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t *fptr)</td></tr>
<tr class="memdesc:a3819926f1d7697e0eb65015230c1e3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate target of a thunk function.  <a href="funcs_8hpp.html#a3819926f1d7697e0eb65015230c1e3d7">More...</a><br /></td></tr>
<tr class="separator:a3819926f1d7697e0eb65015230c1e3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae527c8e35dbe6163ea66f8709a7bfafa"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ae527c8e35dbe6163ea66f8709a7bfafa">func_does_return</a> (ea_t callee)</td></tr>
<tr class="memdesc:ae527c8e35dbe6163ea66f8709a7bfafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the function return?.  <a href="funcs_8hpp.html#ae527c8e35dbe6163ea66f8709a7bfafa">More...</a><br /></td></tr>
<tr class="separator:ae527c8e35dbe6163ea66f8709a7bfafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cb55474c9f4d9bbea12873dcf4fbcc"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a65cb55474c9f4d9bbea12873dcf4fbcc">reanalyze_noret_flag</a> (ea_t ea)</td></tr>
<tr class="memdesc:a65cb55474c9f4d9bbea12873dcf4fbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plan to reanalyze noret flag.  <a href="funcs_8hpp.html#a65cb55474c9f4d9bbea12873dcf4fbcc">More...</a><br /></td></tr>
<tr class="separator:a65cb55474c9f4d9bbea12873dcf4fbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f68e84613300162cc0d23e79250c4d9"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a1f68e84613300162cc0d23e79250c4d9">set_noret_insn</a> (ea_t insn_ea, bool noret)</td></tr>
<tr class="memdesc:a1f68e84613300162cc0d23e79250c4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a non-returning instruction.  <a href="funcs_8hpp.html#a1f68e84613300162cc0d23e79250c4d9">More...</a><br /></td></tr>
<tr class="separator:a1f68e84613300162cc0d23e79250c4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f445f95dc174740557cea00659231"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ac32f445f95dc174740557cea00659231">get_fchunk</a> (ea_t ea)</td></tr>
<tr class="memdesc:ac32f445f95dc174740557cea00659231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to function chunk structure by address.  <a href="funcs_8hpp.html#ac32f445f95dc174740557cea00659231">More...</a><br /></td></tr>
<tr class="separator:ac32f445f95dc174740557cea00659231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1c6ad6c3f483c7cce589cfea512f9b"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a7a1c6ad6c3f483c7cce589cfea512f9b">getn_fchunk</a> (int n)</td></tr>
<tr class="memdesc:a7a1c6ad6c3f483c7cce589cfea512f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to function chunk structure by number.  <a href="funcs_8hpp.html#a7a1c6ad6c3f483c7cce589cfea512f9b">More...</a><br /></td></tr>
<tr class="separator:a7a1c6ad6c3f483c7cce589cfea512f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ff5e98bb6bb48e48cadf69cadd54f"><td class="memItemLeft" align="right" valign="top"><a id="aa10ff5e98bb6bb48e48cadf69cadd54f" name="aa10ff5e98bb6bb48e48cadf69cadd54f"></a>
idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_fchunk_qty</b> (void)</td></tr>
<tr class="memdesc:aa10ff5e98bb6bb48e48cadf69cadd54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total number of function chunks in the program. <br /></td></tr>
<tr class="separator:aa10ff5e98bb6bb48e48cadf69cadd54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fe102694ea5e127bfb3f81d65cf39c"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#aa5fe102694ea5e127bfb3f81d65cf39c">get_fchunk_num</a> (ea_t ea)</td></tr>
<tr class="memdesc:aa5fe102694ea5e127bfb3f81d65cf39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ordinal number of a function chunk in the global list of function chunks.  <a href="funcs_8hpp.html#aa5fe102694ea5e127bfb3f81d65cf39c">More...</a><br /></td></tr>
<tr class="separator:aa5fe102694ea5e127bfb3f81d65cf39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad66f01ac6a72a388c5ab67c6392205"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a5ad66f01ac6a72a388c5ab67c6392205">get_prev_fchunk</a> (ea_t ea)</td></tr>
<tr class="memdesc:a5ad66f01ac6a72a388c5ab67c6392205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the previous function chunk in the global list.  <a href="funcs_8hpp.html#a5ad66f01ac6a72a388c5ab67c6392205">More...</a><br /></td></tr>
<tr class="separator:a5ad66f01ac6a72a388c5ab67c6392205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baa958421786151e145dc412218fbeb"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a0baa958421786151e145dc412218fbeb">get_next_fchunk</a> (ea_t ea)</td></tr>
<tr class="memdesc:a0baa958421786151e145dc412218fbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the next function chunk in the global list.  <a href="funcs_8hpp.html#a0baa958421786151e145dc412218fbeb">More...</a><br /></td></tr>
<tr class="separator:a0baa958421786151e145dc412218fbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f9ee11e7bb8a270a3cbe3714eeb5fd"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a52f9ee11e7bb8a270a3cbe3714eeb5fd">append_func_tail</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea1, ea_t ea2)</td></tr>
<tr class="memdesc:a52f9ee11e7bb8a270a3cbe3714eeb5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new tail chunk to the function definition.  <a href="funcs_8hpp.html#a52f9ee11e7bb8a270a3cbe3714eeb5fd">More...</a><br /></td></tr>
<tr class="separator:a52f9ee11e7bb8a270a3cbe3714eeb5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c614485023e2bb894f6c304244e120"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ae7c614485023e2bb894f6c304244e120">remove_func_tail</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t tail_ea)</td></tr>
<tr class="memdesc:ae7c614485023e2bb894f6c304244e120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a function tail.  <a href="funcs_8hpp.html#ae7c614485023e2bb894f6c304244e120">More...</a><br /></td></tr>
<tr class="separator:ae7c614485023e2bb894f6c304244e120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eaa4df97318e5af34b6b6de3d391af"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a26eaa4df97318e5af34b6b6de3d391af">set_tail_owner</a> (<a class="el" href="classfunc__t.html">func_t</a> *fnt, ea_t new_owner)</td></tr>
<tr class="memdesc:a26eaa4df97318e5af34b6b6de3d391af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new owner of a function tail.  <a href="funcs_8hpp.html#a26eaa4df97318e5af34b6b6de3d391af">More...</a><br /></td></tr>
<tr class="separator:a26eaa4df97318e5af34b6b6de3d391af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fd42d54945fad4fac880c6b98eed5d"><td class="memItemLeft" align="right" valign="top"><a id="ad9fd42d54945fad4fac880c6b98eed5d" name="ad9fd42d54945fad4fac880c6b98eed5d"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_any</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>, void *)</td></tr>
<tr class="memdesc:ad9fd42d54945fad4fac880c6b98eed5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to accept any address. <br /></td></tr>
<tr class="separator:ad9fd42d54945fad4fac880c6b98eed5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85e3cc19cedb028d8a41d6a58529809"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ac85e3cc19cedb028d8a41d6a58529809">iterate_func_chunks</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, void(idaapi *func)(ea_t ea1, ea_t ea2, void *ud), void *ud=nullptr, bool include_parents=false)</td></tr>
<tr class="memdesc:ac85e3cc19cedb028d8a41d6a58529809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to iterate function chunks (all of them including the entry chunk)  <a href="funcs_8hpp.html#ac85e3cc19cedb028d8a41d6a58529809">More...</a><br /></td></tr>
<tr class="separator:ac85e3cc19cedb028d8a41d6a58529809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get prev/next address in function</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Unlike <a class="el" href="classfunc__item__iterator__t.html" title="Class to enumerate all function instructions and data sorted by addresses.">func_item_iterator_t</a> which always enumerates the main function chunk first, these functions respect linear address ordering.</p>
</div></td></tr>
<tr class="memitem:a30b0fd3f556586cb9f903142ff2448b1"><td class="memItemLeft" align="right" valign="top"><a id="a30b0fd3f556586cb9f903142ff2448b1" name="a30b0fd3f556586cb9f903142ff2448b1"></a>
idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_prev_func_addr</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="separator:a30b0fd3f556586cb9f903142ff2448b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e55b1b8a13fb277b458ce1929b2bb2"><td class="memItemLeft" align="right" valign="top"><a id="a07e55b1b8a13fb277b458ce1929b2bb2" name="a07e55b1b8a13fb277b458ce1929b2bb2"></a>
idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_next_func_addr</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="separator:a07e55b1b8a13fb277b458ce1929b2bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp01747264fe7bf50731df0522c351974e"></a>Functions to work with temporary register argument definitions </p>
</td></tr>
<tr class="memitem:ac254d7fc6f7d0f1fc23d9ba2b9b0d7f5"><td class="memItemLeft" align="right" valign="top"><a id="ac254d7fc6f7d0f1fc23d9ba2b9b0d7f5" name="ac254d7fc6f7d0f1fc23d9ba2b9b0d7f5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IDASGN_OK</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ac254d7fc6f7d0f1fc23d9ba2b9b0d7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ok <br /></td></tr>
<tr class="separator:ac254d7fc6f7d0f1fc23d9ba2b9b0d7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccd43014c7fe84025391684eca0c483"><td class="memItemLeft" align="right" valign="top"><a id="adccd43014c7fe84025391684eca0c483" name="adccd43014c7fe84025391684eca0c483"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IDASGN_BADARG</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:adccd43014c7fe84025391684eca0c483"><td class="mdescLeft">&#160;</td><td class="mdescRight">bad number of signature <br /></td></tr>
<tr class="separator:adccd43014c7fe84025391684eca0c483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed1e8d15a128423ad7e6ec66a3b1084"><td class="memItemLeft" align="right" valign="top"><a id="a0ed1e8d15a128423ad7e6ec66a3b1084" name="a0ed1e8d15a128423ad7e6ec66a3b1084"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IDASGN_APPLIED</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a0ed1e8d15a128423ad7e6ec66a3b1084"><td class="mdescLeft">&#160;</td><td class="mdescRight">signature is already applied <br /></td></tr>
<tr class="separator:a0ed1e8d15a128423ad7e6ec66a3b1084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd1a2f59f129c3409b4ba7067671c26"><td class="memItemLeft" align="right" valign="top"><a id="a3cd1a2f59f129c3409b4ba7067671c26" name="a3cd1a2f59f129c3409b4ba7067671c26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IDASGN_CURRENT</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a3cd1a2f59f129c3409b4ba7067671c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">signature is currently being applied <br /></td></tr>
<tr class="separator:a3cd1a2f59f129c3409b4ba7067671c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb5f33fa63a75ff1c34d52806419490"><td class="memItemLeft" align="right" valign="top"><a id="a5fb5f33fa63a75ff1c34d52806419490" name="a5fb5f33fa63a75ff1c34d52806419490"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IDASGN_PLANNED</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a5fb5f33fa63a75ff1c34d52806419490"><td class="mdescLeft">&#160;</td><td class="mdescRight">signature is planned to be applied <br /></td></tr>
<tr class="separator:a5fb5f33fa63a75ff1c34d52806419490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd057e3133f0f2ae254f8b12822cc88"><td class="memItemLeft" align="right" valign="top"><a id="a7fd057e3133f0f2ae254f8b12822cc88" name="a7fd057e3133f0f2ae254f8b12822cc88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LIBFUNC_FOUND</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a7fd057e3133f0f2ae254f8b12822cc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">ok, library function is found <br /></td></tr>
<tr class="separator:a7fd057e3133f0f2ae254f8b12822cc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0237fbae98b51bc7604039785fc80cf"><td class="memItemLeft" align="right" valign="top"><a id="ab0237fbae98b51bc7604039785fc80cf" name="ab0237fbae98b51bc7604039785fc80cf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LIBFUNC_NONE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ab0237fbae98b51bc7604039785fc80cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">no, this is not a library function <br /></td></tr>
<tr class="separator:ab0237fbae98b51bc7604039785fc80cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec13a8da35ad737bd87bd1ce0083602"><td class="memItemLeft" align="right" valign="top"><a id="a6ec13a8da35ad737bd87bd1ce0083602" name="a6ec13a8da35ad737bd87bd1ce0083602"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LIBFUNC_DELAY</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a6ec13a8da35ad737bd87bd1ce0083602"><td class="mdescLeft">&#160;</td><td class="mdescRight">no decision because of lack of information <br /></td></tr>
<tr class="separator:a6ec13a8da35ad737bd87bd1ce0083602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f1df7669aedbf122627705a18a938a"><td class="memItemLeft" align="right" valign="top"><a id="a56f1df7669aedbf122627705a18a938a" name="a56f1df7669aedbf122627705a18a938a"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>read_regargs</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:a56f1df7669aedbf122627705a18a938a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be8603ccd85da70fcd88dd69d43f477"><td class="memItemLeft" align="right" valign="top"><a id="a2be8603ccd85da70fcd88dd69d43f477" name="a2be8603ccd85da70fcd88dd69d43f477"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>add_regarg</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, int reg, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, const char *name)</td></tr>
<tr class="separator:a2be8603ccd85da70fcd88dd69d43f477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa2dc515f7b37cbdc393eb789d9c4d"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a21aa2dc515f7b37cbdc393eb789d9c4d">plan_to_apply_idasgn</a> (const char *fname)</td></tr>
<tr class="memdesc:a21aa2dc515f7b37cbdc393eb789d9c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a signature file to the list of planned signature files.  <a href="funcs_8hpp.html#a21aa2dc515f7b37cbdc393eb789d9c4d">More...</a><br /></td></tr>
<tr class="separator:a21aa2dc515f7b37cbdc393eb789d9c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11aee0876bd2f234cbb3cc11aa69dbca"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a11aee0876bd2f234cbb3cc11aa69dbca">apply_idasgn_to</a> (const char *signame, ea_t ea, bool is_startup)</td></tr>
<tr class="memdesc:a11aee0876bd2f234cbb3cc11aa69dbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a signature file to the specified address.  <a href="funcs_8hpp.html#a11aee0876bd2f234cbb3cc11aa69dbca">More...</a><br /></td></tr>
<tr class="separator:a11aee0876bd2f234cbb3cc11aa69dbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053a76d76510369e88182b93c1289ce8"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a053a76d76510369e88182b93c1289ce8">get_idasgn_qty</a> (void)</td></tr>
<tr class="memdesc:a053a76d76510369e88182b93c1289ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of signatures in the list of planned and applied signatures.  <a href="funcs_8hpp.html#a053a76d76510369e88182b93c1289ce8">More...</a><br /></td></tr>
<tr class="separator:a053a76d76510369e88182b93c1289ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc01ee0b7011b7cc2d42ce314bfe0ef"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a1bc01ee0b7011b7cc2d42ce314bfe0ef">get_current_idasgn</a> (void)</td></tr>
<tr class="memdesc:a1bc01ee0b7011b7cc2d42ce314bfe0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of the the current signature.  <a href="funcs_8hpp.html#a1bc01ee0b7011b7cc2d42ce314bfe0ef">More...</a><br /></td></tr>
<tr class="separator:a1bc01ee0b7011b7cc2d42ce314bfe0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac32c36269d53db5a14273b7ee09d03"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#adac32c36269d53db5a14273b7ee09d03">calc_idasgn_state</a> (int n)</td></tr>
<tr class="memdesc:adac32c36269d53db5a14273b7ee09d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get state of a signature in the list of planned signatures.  <a href="funcs_8hpp.html#adac32c36269d53db5a14273b7ee09d03">More...</a><br /></td></tr>
<tr class="separator:adac32c36269d53db5a14273b7ee09d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3431fb53c0c6e4ec9519348d60722a5b"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a3431fb53c0c6e4ec9519348d60722a5b">del_idasgn</a> (int n)</td></tr>
<tr class="memdesc:a3431fb53c0c6e4ec9519348d60722a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove signature from the list of planned signatures.  <a href="funcs_8hpp.html#a3431fb53c0c6e4ec9519348d60722a5b">More...</a><br /></td></tr>
<tr class="separator:a3431fb53c0c6e4ec9519348d60722a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236eb154300e347420506e61ec20f76f"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a236eb154300e347420506e61ec20f76f">get_idasgn_desc</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *signame, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *optlibs, int n)</td></tr>
<tr class="memdesc:a236eb154300e347420506e61ec20f76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a signature in the list.  <a href="funcs_8hpp.html#a236eb154300e347420506e61ec20f76f">More...</a><br /></td></tr>
<tr class="separator:a236eb154300e347420506e61ec20f76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b459d3bef78a730d0c641c5767f22b"><td class="memItemLeft" align="right" valign="top">idaman idasgn_t *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ac0b459d3bef78a730d0c641c5767f22b">get_idasgn_header_by_short_name</a> (const char *name)</td></tr>
<tr class="memdesc:ac0b459d3bef78a730d0c641c5767f22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get idasgn header by a short signature name.  <a href="funcs_8hpp.html#ac0b459d3bef78a730d0c641c5767f22b">More...</a><br /></td></tr>
<tr class="separator:ac0b459d3bef78a730d0c641c5767f22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85bd713ec5c3fda0e79ca0203107c03"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#ad85bd713ec5c3fda0e79ca0203107c03">get_idasgn_title</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const char *name)</td></tr>
<tr class="memdesc:ad85bd713ec5c3fda0e79ca0203107c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full description of the signature by its short name.  <a href="funcs_8hpp.html#ad85bd713ec5c3fda0e79ca0203107c03">More...</a><br /></td></tr>
<tr class="separator:ad85bd713ec5c3fda0e79ca0203107c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c187a31ca0b6379001ed49babe03cc"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#af1c187a31ca0b6379001ed49babe03cc">determine_rtl</a> (void)</td></tr>
<tr class="memdesc:af1c187a31ca0b6379001ed49babe03cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine compiler/vendor using the startup signatures.  <a href="funcs_8hpp.html#af1c187a31ca0b6379001ed49babe03cc">More...</a><br /></td></tr>
<tr class="separator:af1c187a31ca0b6379001ed49babe03cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a89d1f765c7d13738e85333473a2f6e"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#a2a89d1f765c7d13738e85333473a2f6e">apply_startup_sig</a> (ea_t ea, const char *startup)</td></tr>
<tr class="memdesc:a2a89d1f765c7d13738e85333473a2f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a startup signature file to the specified address.  <a href="funcs_8hpp.html#a2a89d1f765c7d13738e85333473a2f6e">More...</a><br /></td></tr>
<tr class="separator:a2a89d1f765c7d13738e85333473a2f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb69ff17eadf468ac080c807027d5526"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="funcs_8hpp.html#afb69ff17eadf468ac080c807027d5526">try_to_add_libfunc</a> (ea_t ea)</td></tr>
<tr class="memdesc:afb69ff17eadf468ac080c807027d5526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the currently loaded signature file to the specified address.  <a href="funcs_8hpp.html#afb69ff17eadf468ac080c807027d5526">More...</a><br /></td></tr>
<tr class="separator:afb69ff17eadf468ac080c807027d5526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Routines for working with functions within the disassembled program. </p>
<p >This file also contains routines for working with library signatures (e.g. FLIRT).</p>
<p >Each function consists of function chunks. At least one function chunk must be present in the function definition - the function entry chunk. Other chunks are called function tails. There may be several of them for a function.</p>
<p >A function tail is a continuous range of addresses. It can be used in the definition of one or more functions. One function using the tail is singled out and called the tail owner. This function is considered as 'possessing' the tail. <a class="el" href="funcs_8hpp.html#a69ee6619c160f8191cd89381132c4c20" title="Get pointer to function structure by address.">get_func()</a> on a tail address will return the function possessing the tail. You can enumerate the functions using the tail by using <a class="el" href="classfunc__parent__iterator__t.html" title="Class to enumerate all function parents sorted by addresses.">func_parent_iterator_t</a>.</p>
<p >Each function chunk in the disassembly is represented as an "range" (a range of addresses, see <a class="el" href="range_8hpp.html" title="Contains the definition of range_t.">range.hpp</a> for details) with characteristics.</p>
<p >A function entry must start with an instruction (code) byte. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5642dcc557a7cc6237a5ad2b0f7518b3" name="a5642dcc557a7cc6237a5ad2b0f7518b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5642dcc557a7cc6237a5ad2b0f7518b3">&#9670;&nbsp;</a></span>FUNC_NORET_PENDING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNC_NORET_PENDING&#160;&#160;&#160;0x00200</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function 'non-return' analysis must be performed. </p>
<p >This flag is verified upon <a class="el" href="funcs_8hpp.html#ae527c8e35dbe6163ea66f8709a7bfafa" title="Does the function return?.">func_does_return()</a> </p>

</div>
</div>
<a id="a705fa62af6e2f9c71165c9e789e6db24" name="a705fa62af6e2f9c71165c9e789e6db24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705fa62af6e2f9c71165c9e789e6db24">&#9670;&nbsp;</a></span>FUNC_SP_READY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNC_SP_READY&#160;&#160;&#160;0x00000400</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SP-analysis has been performed. </p>
<p >If this flag is on, the stack change points should not be not modified anymore. Currently this analysis is performed only for PC </p>

</div>
</div>
<a id="aeda3bf9abb0f4029d6e258b878ef7d13" name="aeda3bf9abb0f4029d6e258b878ef7d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda3bf9abb0f4029d6e258b878ef7d13">&#9670;&nbsp;</a></span>FUNC_PURGED_OK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNC_PURGED_OK&#160;&#160;&#160;0x00004000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'argsize' field has been validated. </p>
<p >If this bit is clear and 'argsize' is 0, then we do not known the real number of bytes removed from the stack. This bit is handled by the processor module. </p>

</div>
</div>
<a id="a8193dd74d95481badc272c645e5dc910" name="a8193dd74d95481badc272c645e5dc910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8193dd74d95481badc272c645e5dc910">&#9670;&nbsp;</a></span>FUNC_TAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNC_TAIL&#160;&#160;&#160;0x00008000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a function tail. </p>
<p >Other bits must be clear (except <a class="el" href="funcs_8hpp.html#a38d248bf1de00c5bb76bad8590070159" title="A hidden function chunk.">FUNC_HIDDEN</a>). </p>

</div>
</div>
<a id="aab9895d0fbf5e28e7e657e0f6cf19d6d" name="aab9895d0fbf5e28e7e657e0f6cf19d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9895d0fbf5e28e7e657e0f6cf19d6d">&#9670;&nbsp;</a></span>FUNC_REANALYZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUNC_REANALYZE&#160;&#160;&#160;0x00040000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function frame changed, request to reanalyze the function after the last insn is analyzed. </p>

</div>
</div>
<a id="a1f9d638c1a974a95cfaa9ee750cef097" name="a1f9d638c1a974a95cfaa9ee750cef097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9d638c1a974a95cfaa9ee750cef097">&#9670;&nbsp;</a></span>FIND_FUNC_IGNOREFN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_FUNC_IGNOREFN&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ignore existing function boundaries. </p>
<p >by default the function returns function boundaries if ea belongs to a function. </p>

</div>
</div>
<a id="a6c9d7a5331e580e06b9b3ce911f635d7" name="a6c9d7a5331e580e06b9b3ce911f635d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9d7a5331e580e06b9b3ce911f635d7">&#9670;&nbsp;</a></span>FIND_FUNC_KEEPBD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_FUNC_KEEPBD&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>do not modify incoming function boundaries, just create instructions inside the boundaries. </p>

</div>
</div>
<a id="a3e201eff6859ad0590bbe4db125570f0" name="a3e201eff6859ad0590bbe4db125570f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e201eff6859ad0590bbe4db125570f0">&#9670;&nbsp;</a></span>FIND_FUNC_UNDEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_FUNC_UNDEF&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function has instructions that pass execution flow to unexplored bytes. </p>
<p >nfn-&gt;end_ea will have the address of the unexplored byte. </p>

</div>
</div>
<a id="ae1c77ab371a3816e3d90f1f9f48710bd" name="ae1c77ab371a3816e3d90f1f9f48710bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c77ab371a3816e3d90f1f9f48710bd">&#9670;&nbsp;</a></span>FIND_FUNC_EXIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIND_FUNC_EXIST&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function exists already. </p>
<p >its bounds are returned in 'nfn'. </p>

</div>
</div>
<a id="acbc5031907dd057a3d76ff9a19fba350" name="acbc5031907dd057a3d76ff9a19fba350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc5031907dd057a3d76ff9a19fba350">&#9670;&nbsp;</a></span>DECLARE_FUNC_ITERATORS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DECLARE_FUNC_ITERATORS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">prefix</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">prefix <span class="keywordtype">bool</span> ida_export func_tail_iterator_set(<a class="code hl_class" href="classfunc__tail__iterator__t.html">func_tail_iterator_t</a> *fti, <a class="code hl_class" href="classfunc__t.html">func_t</a> *pfn, ea_t ea);\</div>
<div class="line">prefix <span class="keywordtype">bool</span> ida_export func_tail_iterator_set_ea(<a class="code hl_class" href="classfunc__tail__iterator__t.html">func_tail_iterator_t</a> *fti, ea_t ea);\</div>
<div class="line">prefix <span class="keywordtype">bool</span> ida_export func_parent_iterator_set(<a class="code hl_class" href="classfunc__parent__iterator__t.html">func_parent_iterator_t</a> *fpi, <a class="code hl_class" href="classfunc__t.html">func_t</a> *pfn);\</div>
<div class="line">prefix <span class="keywordtype">bool</span> ida_export func_item_iterator_next(<a class="code hl_class" href="classfunc__item__iterator__t.html">func_item_iterator_t</a> *fii, <a class="code hl_typedef" href="bytes_8hpp.html#ad5185f9d189b9af5cbf47bdbaa3888eb">testf_t</a> *testf, <span class="keywordtype">void</span> *ud);\</div>
<div class="line">prefix <span class="keywordtype">bool</span> ida_export func_item_iterator_prev(<a class="code hl_class" href="classfunc__item__iterator__t.html">func_item_iterator_t</a> *fii, <a class="code hl_typedef" href="bytes_8hpp.html#ad5185f9d189b9af5cbf47bdbaa3888eb">testf_t</a> *testf, <span class="keywordtype">void</span> *ud);\</div>
<div class="line">prefix <span class="keywordtype">bool</span> ida_export func_item_iterator_decode_prev_insn(<a class="code hl_class" href="classfunc__item__iterator__t.html">func_item_iterator_t</a> *fii, <a class="code hl_class" href="classinsn__t.html">insn_t</a> *out); \</div>
<div class="line">prefix <span class="keywordtype">bool</span> ida_export func_item_iterator_decode_preceding_insn(<a class="code hl_class" href="classfunc__item__iterator__t.html">func_item_iterator_t</a> *fii, <a class="code hl_class" href="classqvector.html">eavec_t</a> *visited, <span class="keywordtype">bool</span> *p_farref, <a class="code hl_class" href="classinsn__t.html">insn_t</a> *out); \</div>
<div class="line">prefix <span class="keywordtype">bool</span> ida_export func_item_iterator_succ(<a class="code hl_class" href="classfunc__item__iterator__t.html">func_item_iterator_t</a> *fii, <a class="code hl_typedef" href="bytes_8hpp.html#ad5185f9d189b9af5cbf47bdbaa3888eb">testf_t</a> *testf, <span class="keywordtype">void</span> *ud);</div>
<div class="ttc" id="abytes_8hpp_html_ad5185f9d189b9af5cbf47bdbaa3888eb"><div class="ttname"><a href="bytes_8hpp.html#ad5185f9d189b9af5cbf47bdbaa3888eb">testf_t</a></div><div class="ttdeci">bool idaapi testf_t(flags64_t flags, void *ud)</div><div class="ttdoc">Flag tester - see next_that(), prev_that()</div><div class="ttdef"><b>Definition:</b> bytes.hpp:110</div></div>
<div class="ttc" id="aclassfunc__item__iterator__t_html"><div class="ttname"><a href="classfunc__item__iterator__t.html">func_item_iterator_t</a></div><div class="ttdoc">Class to enumerate all function instructions and data sorted by addresses.</div><div class="ttdef"><b>Definition:</b> funcs.hpp:771</div></div>
<div class="ttc" id="aclassfunc__parent__iterator__t_html"><div class="ttname"><a href="classfunc__parent__iterator__t.html">func_parent_iterator_t</a></div><div class="ttdoc">Class to enumerate all function parents sorted by addresses.</div><div class="ttdef"><b>Definition:</b> funcs.hpp:825</div></div>
<div class="ttc" id="aclassfunc__t_html"><div class="ttname"><a href="classfunc__t.html">func_t</a></div><div class="ttdoc">A function is a set of continuous ranges of addresses with characteristics.</div><div class="ttdef"><b>Definition:</b> funcs.hpp:85</div></div>
<div class="ttc" id="aclassfunc__tail__iterator__t_html"><div class="ttname"><a href="classfunc__tail__iterator__t.html">func_tail_iterator_t</a></div><div class="ttdoc">Class to enumerate all function tails sorted by addresses.</div><div class="ttdef"><b>Definition:</b> funcs.hpp:700</div></div>
<div class="ttc" id="aclassinsn__t_html"><div class="ttname"><a href="classinsn__t.html">insn_t</a></div><div class="ttdef"><b>Definition:</b> ua.hpp:354</div></div>
<div class="ttc" id="aclassqvector_html"><div class="ttname"><a href="classqvector.html">qvector&lt; ea_t &gt;</a></div></div>
</div><!-- fragment -->
<p>Declare helper functions for <a class="el" href="classfunc__item__iterator__t.html" title="Class to enumerate all function instructions and data sorted by addresses.">func_item_iterator_t</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a381aa5ad285df1295afbe5a70825dbf4" name="a381aa5ad285df1295afbe5a70825dbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381aa5ad285df1295afbe5a70825dbf4">&#9670;&nbsp;</a></span>lock_func_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export lock_func_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock function pointer Locked pointers are guaranteed to remain valid until they are unlocked. </p>
<p >Ranges with locked pointers cannot be deleted or moved. </p>

</div>
</div>
<a id="a69ee6619c160f8191cd89381132c4c20" name="a69ee6619c160f8191cd89381132c4c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ee6619c160f8191cd89381132c4c20">&#9670;&nbsp;</a></span>get_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export get_func </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to function structure by address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in a function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to a function or nullptr. This function returns a function entry chunk. </dd></dl>

</div>
</div>
<a id="a3fdde3cac23887c5c536ae79d2f9093b" name="a3fdde3cac23887c5c536ae79d2f9093b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdde3cac23887c5c536ae79d2f9093b">&#9670;&nbsp;</a></span>get_func_chunknum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_func_chunknum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the containing tail chunk of 'ea'. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>means 'does not contain ea' </td></tr>
    <tr><td class="paramname">0</td><td>means the 'pfn' itself contains ea </td></tr>
    <tr><td class="paramname">&gt;0</td><td>the number of the containing function tail chunk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03a4ce6b6edc50c1a43f0d8cae7309fc" name="a03a4ce6b6edc50c1a43f0d8cae7309fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a4ce6b6edc50c1a43f0d8cae7309fc">&#9670;&nbsp;</a></span>getn_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export getn_func </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to function structure by number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of function, is in range 0..<a class="el" href="funcs_8hpp.html#a22dd1d91e9eb3d3bab69abed43be3aee" title="Get total number of functions in the program.">get_func_qty()</a>-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to a function or nullptr. This function returns a function entry chunk. </dd></dl>

</div>
</div>
<a id="aa1f8b164bb6112dbc21bfecd4763c58a" name="aa1f8b164bb6112dbc21bfecd4763c58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f8b164bb6112dbc21bfecd4763c58a">&#9670;&nbsp;</a></span>get_func_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_func_num </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ordinal number of a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of function (0..<a class="el" href="funcs_8hpp.html#a22dd1d91e9eb3d3bab69abed43be3aee" title="Get total number of functions in the program.">get_func_qty()</a>-1). -1 means 'no function at the specified address'. </dd></dl>

</div>
</div>
<a id="a934e746c1e5fe415816cc46160258ce7" name="a934e746c1e5fe415816cc46160258ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934e746c1e5fe415816cc46160258ce7">&#9670;&nbsp;</a></span>get_prev_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export get_prev_func </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the previous function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to function or nullptr if previous function doesn't exist </dd></dl>

</div>
</div>
<a id="aed86b7fef649d785a4c75171ee40ccd3" name="aed86b7fef649d785a4c75171ee40ccd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed86b7fef649d785a4c75171ee40ccd3">&#9670;&nbsp;</a></span>get_next_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export get_next_func </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the next function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to function or nullptr if next function doesn't exist </dd></dl>

</div>
</div>
<a id="a11fc740f61121d71d6958030fa06e677" name="a11fc740f61121d71d6958030fa06e677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fc740f61121d71d6958030fa06e677">&#9670;&nbsp;</a></span>get_func_ranges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_func_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrangeset__t.html">rangeset_t</a> *&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get function ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ranges</td><td>buffer to receive the range info </td></tr>
    <tr><td class="paramname">pfn</td><td>ptr to function structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end address of the last function range (BADADDR-error) </dd></dl>

</div>
</div>
<a id="aeadbb1e0b11eae2e34730ede51d1ed38" name="aeadbb1e0b11eae2e34730ede51d1ed38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadbb1e0b11eae2e34730ede51d1ed38">&#9670;&nbsp;</a></span>get_func_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_func_cmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeatable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get function comment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer for the comment </td></tr>
    <tr><td class="paramname">pfn</td><td>ptr to function structure </td></tr>
    <tr><td class="paramname">repeatable</td><td>get repeatable comment? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of comment or -1 In fact this function works with function chunks too. </dd></dl>

</div>
</div>
<a id="a49070bb3dbf2ca55720d20db3a44c9f0" name="a49070bb3dbf2ca55720d20db3a44c9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49070bb3dbf2ca55720d20db3a44c9f0">&#9670;&nbsp;</a></span>set_func_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_func_cmt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeatable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set function comment. </p>
<p >This function works with function chunks too. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>ptr to function structure </td></tr>
    <tr><td class="paramname">cmt</td><td>comment string, may be multiline (with '<br  />
'). Use empty str ("") to delete comment </td></tr>
    <tr><td class="paramname">repeatable</td><td>set repeatable comment? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a184f1967b3f6e7d00e02e4d97a41e836" name="a184f1967b3f6e7d00e02e4d97a41e836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184f1967b3f6e7d00e02e4d97a41e836">&#9670;&nbsp;</a></span>update_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export update_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update information about a function in the database (<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a>). </p>
<p >You must not change the function start and end addresses using this function. Use <a class="el" href="funcs_8hpp.html#aea0e8d3e2712894d3b4b3fdea39cd5c3" title="Move function chunk start address.">set_func_start()</a> and <a class="el" href="funcs_8hpp.html#a7548171011040223d66c8740d7098d32" title="Move function chunk end address.">set_func_end()</a> for it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>ptr to function structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a55d69de76e1743db96e0d7ecf7909dc2" name="a55d69de76e1743db96e0d7ecf7909dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d69de76e1743db96e0d7ecf7909dc2">&#9670;&nbsp;</a></span>add_func_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_func_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new function. </p>
<p >If the fn-&gt;end_ea is <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>, then IDA will try to determine the function bounds by calling find_func_bounds(..., <a class="el" href="funcs_8hpp.html#a625d181ea2205e5fe3a844f61f1bfca6" title="create instruction if undefined byte is encountered">FIND_FUNC_DEFINE</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>ptr to filled function structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a43dfcfff5941536b5b16d5ea160cce8a" name="a43dfcfff5941536b5b16d5ea160cce8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43dfcfff5941536b5b16d5ea160cce8a">&#9670;&nbsp;</a></span>add_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool add_func </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em> = <code><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new function. </p>
<p >If the function end address is <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>, then IDA will try to determine the function bounds by calling find_func_bounds(..., <a class="el" href="funcs_8hpp.html#a625d181ea2205e5fe3a844f61f1bfca6" title="create instruction if undefined byte is encountered">FIND_FUNC_DEFINE</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea1</td><td>start address </td></tr>
    <tr><td class="paramname">ea2</td><td>end address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ac8a9f424e35fdf6393b44bf35f36832f" name="ac8a9f424e35fdf6393b44bf35f36832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a9f424e35fdf6393b44bf35f36832f">&#9670;&nbsp;</a></span>del_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export del_func </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the function entry chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="aea0e8d3e2712894d3b4b3fdea39cd5c3" name="aea0e8d3e2712894d3b4b3fdea39cd5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0e8d3e2712894d3b4b3fdea39cd5c3">&#9670;&nbsp;</a></span>set_func_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export set_func_start </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>newstart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move function chunk start address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the function </td></tr>
    <tr><td class="paramname">newstart</td><td>new end address of the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___m_o_v_e___f_u_n_c__.html">Function move result codes</a> </dd></dl>

</div>
</div>
<a id="a7548171011040223d66c8740d7098d32" name="a7548171011040223d66c8740d7098d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7548171011040223d66c8740d7098d32">&#9670;&nbsp;</a></span>set_func_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_func_end </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>newend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move function chunk end address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the function </td></tr>
    <tr><td class="paramname">newend</td><td>new end address of the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="af4ed5ff5471d43941271df7cb0a54cd0" name="af4ed5ff5471d43941271df7cb0a54cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ed5ff5471d43941271df7cb0a54cd0">&#9670;&nbsp;</a></span>reanalyze_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export reanalyze_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em> = <code><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>analyze_parents</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reanalyze a function. </p>
<p >This function plans to analyzes all chunks of the given function. Optional parameters (ea1, ea2) may be used to narrow the analyzed range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to a function </td></tr>
    <tr><td class="paramname">ea1</td><td>start of the range to analyze </td></tr>
    <tr><td class="paramname">ea2</td><td>end of range to analyze </td></tr>
    <tr><td class="paramname">analyze_parents</td><td>meaningful only if pfn points to a function tail. if true, all tail parents will be reanalyzed. if false, only the given tail will be reanalyzed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af27a7eb0cc4e210f6ffa21e6aa06e589" name="af27a7eb0cc4e210f6ffa21e6aa06e589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27a7eb0cc4e210f6ffa21e6aa06e589">&#9670;&nbsp;</a></span>find_func_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export find_func_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>nfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the boundaries of a new function. </p>
<p >This function tries to find the start and end addresses of a new function. It calls the module with processor_t::func_bounds in order to fine tune the function boundaries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfn</td><td>structure to fill with information \ nfn-&gt;start_ea points to the start address of the new function. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___f_i_n_d___f_u_n_c___f.html">Find function bounds flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___f_i_n_d___f_u_n_c___r.html">Find function bounds result codes</a> </dd></dl>

</div>
</div>
<a id="aaee61d9e3082565c8e941377a5b150c5" name="aaee61d9e3082565c8e941377a5b150c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee61d9e3082565c8e941377a5b150c5">&#9670;&nbsp;</a></span>get_func_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_func_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get function name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer for the answer </td></tr>
    <tr><td class="paramname">ea</td><td>any address in the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the function name </dd></dl>

</div>
</div>
<a id="acaa98c6848186d239d12588f84e7c2e5" name="acaa98c6848186d239d12588f84e7c2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa98c6848186d239d12588f84e7c2e5">&#9670;&nbsp;</a></span>calc_func_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman asize_t ida_export calc_func_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate function size. </p>
<p >This function takes into account all fragments of the function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>ptr to function structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1c60a7de477ea88c24a5cecf5722942" name="ac1c60a7de477ea88c24a5cecf5722942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c60a7de477ea88c24a5cecf5722942">&#9670;&nbsp;</a></span>get_func_bitness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_func_bitness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get function bitness (which is equal to the function segment bitness). </p>
<p >pfn==nullptr =&gt; returns 0 </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>16 </td></tr>
    <tr><td class="paramname">1</td><td>32 </td></tr>
    <tr><td class="paramname">2</td><td>64 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce3d589a62220b86154f5b43bd9d51a" name="a1ce3d589a62220b86154f5b43bd9d51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce3d589a62220b86154f5b43bd9d51a">&#9670;&nbsp;</a></span>set_func_name_if_jumpfunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export set_func_name_if_jumpfunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give a meaningful name to function if it consists of only 'jump' instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function (may be nullptr) </td></tr>
    <tr><td class="paramname">oldname</td><td>old name of function. if old name was in "j_..." form, then we may discard it and set a new name. if oldname is not known, you may pass nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a3819926f1d7697e0eb65015230c1e3d7" name="a3819926f1d7697e0eb65015230c1e3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3819926f1d7697e0eb65015230c1e3d7">&#9670;&nbsp;</a></span>calc_thunk_func_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export calc_thunk_func_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t *&#160;</td>
          <td class="paramname"><em>fptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate target of a thunk function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function (may not be nullptr) </td></tr>
    <tr><td class="paramname">fptr</td><td>out: will hold address of a function pointer (if indirect jump) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the target function or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> </dd></dl>

</div>
</div>
<a id="ae527c8e35dbe6163ea66f8709a7bfafa" name="ae527c8e35dbe6163ea66f8709a7bfafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae527c8e35dbe6163ea66f8709a7bfafa">&#9670;&nbsp;</a></span>func_does_return()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export func_does_return </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>callee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the function return?. </p>
<p >To calculate the answer, <a class="el" href="funcs_8hpp.html#a9f89bd6c0cf00b4e346266627a5e5b3a" title="Function doesn&#39;t return.">FUNC_NORET</a> flag and is_noret() are consulted The latter is required for imported functions in the .idata section. Since in .idata we have only function pointers but not functions, we have to introduce a special flag for them. </p>

</div>
</div>
<a id="a65cb55474c9f4d9bbea12873dcf4fbcc" name="a65cb55474c9f4d9bbea12873dcf4fbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cb55474c9f4d9bbea12873dcf4fbcc">&#9670;&nbsp;</a></span>reanalyze_noret_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export reanalyze_noret_flag </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plan to reanalyze noret flag. </p>
<p >This function does not remove FUNC_NORET if it is already present. It just plans to reanalysis. </p>

</div>
</div>
<a id="a1f68e84613300162cc0d23e79250c4d9" name="a1f68e84613300162cc0d23e79250c4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f68e84613300162cc0d23e79250c4d9">&#9670;&nbsp;</a></span>set_noret_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_noret_insn </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>insn_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a non-returning instruction. </p>
<p >This function can be used by the processor module to tell the kernel about non-returning instructions (like call exit). The kernel will perform the global function analysis and find out if the function returns at all. This analysis will be done at the first call to <a class="el" href="funcs_8hpp.html#ae527c8e35dbe6163ea66f8709a7bfafa" title="Does the function return?.">func_does_return()</a> </p><dl class="section return"><dt>Returns</dt><dd>true if the instruction 'noret' flag has been changed </dd></dl>

</div>
</div>
<a id="ac32f445f95dc174740557cea00659231" name="ac32f445f95dc174740557cea00659231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32f445f95dc174740557cea00659231">&#9670;&nbsp;</a></span>get_fchunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export get_fchunk </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to function chunk structure by address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in a function chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to a function chunk or nullptr. This function may return a function entry as well as a function tail. </dd></dl>

</div>
</div>
<a id="a7a1c6ad6c3f483c7cce589cfea512f9b" name="a7a1c6ad6c3f483c7cce589cfea512f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1c6ad6c3f483c7cce589cfea512f9b">&#9670;&nbsp;</a></span>getn_fchunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export getn_fchunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to function chunk structure by number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of function chunk, is in range 0..<a class="el" href="funcs_8hpp.html#aa10ff5e98bb6bb48e48cadf69cadd54f" title="Get total number of function chunks in the program.">get_fchunk_qty()</a>-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to a function chunk or nullptr. This function may return a function entry as well as a function tail. </dd></dl>

</div>
</div>
<a id="aa5fe102694ea5e127bfb3f81d65cf39c" name="aa5fe102694ea5e127bfb3f81d65cf39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fe102694ea5e127bfb3f81d65cf39c">&#9670;&nbsp;</a></span>get_fchunk_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_fchunk_num </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ordinal number of a function chunk in the global list of function chunks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the function chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of function chunk (0..<a class="el" href="funcs_8hpp.html#aa10ff5e98bb6bb48e48cadf69cadd54f" title="Get total number of function chunks in the program.">get_fchunk_qty()</a>-1). -1 means 'no function chunk at the specified address'. </dd></dl>

</div>
</div>
<a id="a5ad66f01ac6a72a388c5ab67c6392205" name="a5ad66f01ac6a72a388c5ab67c6392205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad66f01ac6a72a388c5ab67c6392205">&#9670;&nbsp;</a></span>get_prev_fchunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export get_prev_fchunk </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the previous function chunk in the global list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to function chunk or nullptr if previous function chunk doesn't exist </dd></dl>

</div>
</div>
<a id="a0baa958421786151e145dc412218fbeb" name="a0baa958421786151e145dc412218fbeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baa958421786151e145dc412218fbeb">&#9670;&nbsp;</a></span>get_next_fchunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classfunc__t.html">func_t</a> *ida_export get_next_fchunk </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the next function chunk in the global list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to function chunk or nullptr if next function chunk doesn't exist </dd></dl>

</div>
</div>
<a id="a52f9ee11e7bb8a270a3cbe3714eeb5fd" name="a52f9ee11e7bb8a270a3cbe3714eeb5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f9ee11e7bb8a270a3cbe3714eeb5fd">&#9670;&nbsp;</a></span>append_func_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export append_func_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new tail chunk to the function definition. </p>
<p >If the tail already exists, then it will simply be added to the function tail list Otherwise a new tail will be created and its owner will be set to be our function If a new tail cannot be created, then this function will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to the function </td></tr>
    <tr><td class="paramname">ea1</td><td>start of the tail. If a tail already exists at the specified address it must start at 'ea1' </td></tr>
    <tr><td class="paramname">ea2</td><td>end of the tail. If a tail already exists at the specified address it must end at 'ea2'. If specified as BADADDR, IDA will determine the end address itself. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7c614485023e2bb894f6c304244e120" name="ae7c614485023e2bb894f6c304244e120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c614485023e2bb894f6c304244e120">&#9670;&nbsp;</a></span>remove_func_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export remove_func_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>tail_ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a function tail. </p>
<p >If the tail belongs only to one function, it will be completely removed. Otherwise if the function was the tail owner, the first function using this tail becomes the owner of the tail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to the function </td></tr>
    <tr><td class="paramname">tail_ea</td><td>any address inside the tail to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26eaa4df97318e5af34b6b6de3d391af" name="a26eaa4df97318e5af34b6b6de3d391af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eaa4df97318e5af34b6b6de3d391af">&#9670;&nbsp;</a></span>set_tail_owner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_tail_owner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>fnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>new_owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new owner of a function tail. </p>
<p >The new owner function must be already referring to the tail (after append_func_tail). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fnt</td><td>pointer to the function tail </td></tr>
    <tr><td class="paramname">new_owner</td><td>the entry point of the new owner function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac85e3cc19cedb028d8a41d6a58529809" name="ac85e3cc19cedb028d8a41d6a58529809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85e3cc19cedb028d8a41d6a58529809">&#9670;&nbsp;</a></span>iterate_func_chunks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export iterate_func_chunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(idaapi *)(ea_t ea1, ea_t ea2, void *ud)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_parents</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to iterate function chunks (all of them including the entry chunk) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to the function </td></tr>
    <tr><td class="paramname">func</td><td>function to call for each chunk </td></tr>
    <tr><td class="paramname">ud</td><td>user data for 'func' </td></tr>
    <tr><td class="paramname">include_parents</td><td>meaningful only if pfn points to a function tail. if true, all tail parents will be iterated. if false, only the given tail will be iterated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21aa2dc515f7b37cbdc393eb789d9c4d" name="a21aa2dc515f7b37cbdc393eb789d9c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa2dc515f7b37cbdc393eb789d9c4d">&#9670;&nbsp;</a></span>plan_to_apply_idasgn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export plan_to_apply_idasgn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a signature file to the list of planned signature files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>file name. should not contain directory part. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if failed, otherwise number of planned (and applied) signatures </dd></dl>

</div>
</div>
<a id="a11aee0876bd2f234cbb3cc11aa69dbca" name="a11aee0876bd2f234cbb3cc11aa69dbca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11aee0876bd2f234cbb3cc11aa69dbca">&#9670;&nbsp;</a></span>apply_idasgn_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export apply_idasgn_to </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>signame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a signature file to the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signame</td><td>short name of signature file (the file name without path) </td></tr>
    <tr><td class="paramname">ea</td><td>address to apply the signature </td></tr>
    <tr><td class="paramname">is_startup</td><td>if set, then the signature is treated as a startup one for startup signature ida doesn't rename the first function of the applied module. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___l_i_b_f_u_n_c__.html">Library function codes</a> </dd></dl>

</div>
</div>
<a id="a053a76d76510369e88182b93c1289ce8" name="a053a76d76510369e88182b93c1289ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053a76d76510369e88182b93c1289ce8">&#9670;&nbsp;</a></span>get_idasgn_qty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_idasgn_qty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of signatures in the list of planned and applied signatures. </p>
<dl class="section return"><dt>Returns</dt><dd>0..n </dd></dl>

</div>
</div>
<a id="a1bc01ee0b7011b7cc2d42ce314bfe0ef" name="a1bc01ee0b7011b7cc2d42ce314bfe0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc01ee0b7011b7cc2d42ce314bfe0ef">&#9670;&nbsp;</a></span>get_current_idasgn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_current_idasgn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of the the current signature. </p>
<dl class="section return"><dt>Returns</dt><dd>0..n-1 </dd></dl>

</div>
</div>
<a id="adac32c36269d53db5a14273b7ee09d03" name="adac32c36269d53db5a14273b7ee09d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac32c36269d53db5a14273b7ee09d03">&#9670;&nbsp;</a></span>calc_idasgn_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export calc_idasgn_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get state of a signature in the list of planned signatures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of signature in the list (0..<a class="el" href="funcs_8hpp.html#a053a76d76510369e88182b93c1289ce8" title="Get number of signatures in the list of planned and applied signatures.">get_idasgn_qty()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>state of signature or <a class="el" href="funcs_8hpp.html#adccd43014c7fe84025391684eca0c483" title="bad number of signature">IDASGN_BADARG</a> </dd></dl>

</div>
</div>
<a id="a3431fb53c0c6e4ec9519348d60722a5b" name="a3431fb53c0c6e4ec9519348d60722a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3431fb53c0c6e4ec9519348d60722a5b">&#9670;&nbsp;</a></span>del_idasgn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export del_idasgn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove signature from the list of planned signatures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of signature in the list (0..<a class="el" href="funcs_8hpp.html#a053a76d76510369e88182b93c1289ce8" title="Get number of signatures in the list of planned and applied signatures.">get_idasgn_qty()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="funcs_8hpp.html#ac254d7fc6f7d0f1fc23d9ba2b9b0d7f5" title="ok">IDASGN_OK</a>, <a class="el" href="funcs_8hpp.html#adccd43014c7fe84025391684eca0c483" title="bad number of signature">IDASGN_BADARG</a>, <a class="el" href="funcs_8hpp.html#a0ed1e8d15a128423ad7e6ec66a3b1084" title="signature is already applied">IDASGN_APPLIED</a> </dd></dl>

</div>
</div>
<a id="a236eb154300e347420506e61ec20f76f" name="a236eb154300e347420506e61ec20f76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236eb154300e347420506e61ec20f76f">&#9670;&nbsp;</a></span>get_idasgn_desc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> ida_export get_idasgn_desc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>signame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>optlibs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about a signature in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signame</td><td>buffer for the name of the signature. (short form, only base name without the directory part will be stored). if signame == nullptr, then the name won't be returned. </td></tr>
    <tr><td class="paramname">optlibs</td><td>buffer for the names of the optional libraries if optlibs == nullptr, then the optional libraries are not returned </td></tr>
    <tr><td class="paramname">n</td><td>number of signature in the list (0..<a class="el" href="funcs_8hpp.html#a053a76d76510369e88182b93c1289ce8" title="Get number of signatures in the list of planned and applied signatures.">get_idasgn_qty()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of successfully recognized modules using this signature. -1 means the 'n' is a bad argument, i.e. no signature with this number exists.. </dd></dl>

</div>
</div>
<a id="ac0b459d3bef78a730d0c641c5767f22b" name="ac0b459d3bef78a730d0c641c5767f22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b459d3bef78a730d0c641c5767f22b">&#9670;&nbsp;</a></span>get_idasgn_header_by_short_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman idasgn_t *ida_export get_idasgn_header_by_short_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get idasgn header by a short signature name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>short name of a signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if can't find the signature </dd></dl>

</div>
</div>
<a id="ad85bd713ec5c3fda0e79ca0203107c03" name="ad85bd713ec5c3fda0e79ca0203107c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85bd713ec5c3fda0e79ca0203107c03">&#9670;&nbsp;</a></span>get_idasgn_title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_idasgn_title </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get full description of the signature by its short name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the output buffer </td></tr>
    <tr><td class="paramname">name</td><td>short name of a signature </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of signature description or -1 </dd></dl>

</div>
</div>
<a id="af1c187a31ca0b6379001ed49babe03cc" name="af1c187a31ca0b6379001ed49babe03cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c187a31ca0b6379001ed49babe03cc">&#9670;&nbsp;</a></span>determine_rtl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export determine_rtl </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine compiler/vendor using the startup signatures. </p>
<p >If determined, then appropriate signature files are included into the list of planned signature files. </p>

</div>
</div>
<a id="a2a89d1f765c7d13738e85333473a2f6e" name="a2a89d1f765c7d13738e85333473a2f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a89d1f765c7d13738e85333473a2f6e">&#9670;&nbsp;</a></span>apply_startup_sig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export apply_startup_sig </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>startup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a startup signature file to the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>address to apply the signature to; usually <a class="el" href="structidainfo.html#ab8b6edf1a30a7fcd0899d2ab657e692a" title="Linear address of program entry point.">idainfo::start_ea</a> </td></tr>
    <tr><td class="paramname">startup</td><td>the name of the signature file without path and extension </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully applied the signature </dd></dl>

</div>
</div>
<a id="afb69ff17eadf468ac080c807027d5526" name="afb69ff17eadf468ac080c807027d5526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb69ff17eadf468ac080c807027d5526">&#9670;&nbsp;</a></span>try_to_add_libfunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export try_to_add_libfunc </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the currently loaded signature file to the specified address. </p>
<p >If a library function is found, then create a function and name it accordingly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___l_i_b_f_u_n_c__.html">Library function codes</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
