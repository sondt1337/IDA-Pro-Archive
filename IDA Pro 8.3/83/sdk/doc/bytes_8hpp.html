<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: bytes.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bytes.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains functions that deal with individual byte characteristics.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoctet__generator__t.html">octet_generator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get 8 bits of the program at 'ea'.  <a href="structoctet__generator__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdata__type__t.html">data_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a data type.  <a href="structdata__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdata__format__t.html">data_format_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a data format.  <a href="structdata__format__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcompiled__binpat__t.html">compiled_binpat_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhidden__range__t.html">hidden_range_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hidden ranges - address ranges which can be replaced by their descriptions.  <a href="structhidden__range__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9e19f02291abf44b1085a054451b2fa4"><td class="memItemLeft" align="right" valign="top"><a id="a9e19f02291abf44b1085a054451b2fa4" name="a9e19f02291abf44b1085a054451b2fa4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ITEM_END_FIXUP</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a9e19f02291abf44b1085a054451b2fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop at the first fixup <br /></td></tr>
<tr class="separator:a9e19f02291abf44b1085a054451b2fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4b59c6b40268ce8458dd8ac3943744"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#acd4b59c6b40268ce8458dd8ac3943744">ITEM_END_INITED</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:acd4b59c6b40268ce8458dd8ac3943744"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop when initialization changes i.e.  <a href="bytes_8hpp.html#acd4b59c6b40268ce8458dd8ac3943744">More...</a><br /></td></tr>
<tr class="separator:acd4b59c6b40268ce8458dd8ac3943744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea13487068716c9257da0bae472f8871"><td class="memItemLeft" align="right" valign="top"><a id="aea13487068716c9257da0bae472f8871" name="aea13487068716c9257da0bae472f8871"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ITEM_END_NAME</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:aea13487068716c9257da0bae472f8871"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop at the first named location <br /></td></tr>
<tr class="separator:aea13487068716c9257da0bae472f8871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb7e759f8c4385e37eb5dc5dd715df7"><td class="memItemLeft" align="right" valign="top"><a id="a8fb7e759f8c4385e37eb5dc5dd715df7" name="a8fb7e759f8c4385e37eb5dc5dd715df7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ITEM_END_XREF</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a8fb7e759f8c4385e37eb5dc5dd715df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop at the first referenced location <br /></td></tr>
<tr class="separator:a8fb7e759f8c4385e37eb5dc5dd715df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d17030d2a562f8b77e1d346d1d70c5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a3d17030d2a562f8b77e1d346d1d70c5f">GFE_VALUE</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a3d17030d2a562f8b77e1d346d1d70c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get flags with <a class="el" href="bytes_8hpp.html#aee726806a07a06c9a7dcba795485e11c" title="Byte has value ?">FF_IVL</a> &amp; <a class="el" href="bytes_8hpp.html#ad190bb3962a654369210c8e14e23aa09" title="Mask for byte value.">MS_VAL</a>.  <a href="bytes_8hpp.html#a3d17030d2a562f8b77e1d346d1d70c5f">More...</a><br /></td></tr>
<tr class="separator:a3d17030d2a562f8b77e1d346d1d70c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af079bca6c1e74b1cba97a6b8a6d3b648"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#af079bca6c1e74b1cba97a6b8a6d3b648">GFE_IDB_VALUE</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:af079bca6c1e74b1cba97a6b8a6d3b648"><td class="mdescLeft">&#160;</td><td class="mdescRight">get flags with <a class="el" href="bytes_8hpp.html#aee726806a07a06c9a7dcba795485e11c" title="Byte has value ?">FF_IVL</a> &amp; <a class="el" href="bytes_8hpp.html#ad190bb3962a654369210c8e14e23aa09" title="Mask for byte value.">MS_VAL</a>.  <a href="bytes_8hpp.html#af079bca6c1e74b1cba97a6b8a6d3b648">More...</a><br /></td></tr>
<tr class="separator:af079bca6c1e74b1cba97a6b8a6d3b648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad190bb3962a654369210c8e14e23aa09"><td class="memItemLeft" align="right" valign="top"><a id="ad190bb3962a654369210c8e14e23aa09" name="ad190bb3962a654369210c8e14e23aa09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MS_VAL</b>&#160;&#160;&#160;0x000000FFLLU</td></tr>
<tr class="memdesc:ad190bb3962a654369210c8e14e23aa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for byte value. <br /></td></tr>
<tr class="separator:ad190bb3962a654369210c8e14e23aa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee726806a07a06c9a7dcba795485e11c"><td class="memItemLeft" align="right" valign="top"><a id="aee726806a07a06c9a7dcba795485e11c" name="aee726806a07a06c9a7dcba795485e11c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_IVL</b>&#160;&#160;&#160;0x00000100LLU</td></tr>
<tr class="memdesc:aee726806a07a06c9a7dcba795485e11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte has value ? <br /></td></tr>
<tr class="separator:aee726806a07a06c9a7dcba795485e11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d8f0e465c80c8fe55a935559d80fcf"><td class="memItemLeft" align="right" valign="top"><a id="ad0d8f0e465c80c8fe55a935559d80fcf" name="ad0d8f0e465c80c8fe55a935559d80fcf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GMB_READALL</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ad0d8f0e465c80c8fe55a935559d80fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to read all bytes; if this bit is not set, fail at first uninited byte <br /></td></tr>
<tr class="separator:ad0d8f0e465c80c8fe55a935559d80fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99481a092dc371f6636721f11bb0e450"><td class="memItemLeft" align="right" valign="top"><a id="a99481a092dc371f6636721f11bb0e450" name="a99481a092dc371f6636721f11bb0e450"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GMB_WAITBOX</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:a99481a092dc371f6636721f11bb0e450"><td class="mdescLeft">&#160;</td><td class="mdescRight">show wait box (may return -1 in this case) <br /></td></tr>
<tr class="separator:a99481a092dc371f6636721f11bb0e450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630a903251f31c6f099cfce708498d99"><td class="memItemLeft" align="right" valign="top"><a id="a630a903251f31c6f099cfce708498d99" name="a630a903251f31c6f099cfce708498d99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MS_CLS</b>&#160;&#160;&#160;0x00000600LU</td></tr>
<tr class="memdesc:a630a903251f31c6f099cfce708498d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for typing. <br /></td></tr>
<tr class="separator:a630a903251f31c6f099cfce708498d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1e52d0b6bcfce13bfb81dcb793f447"><td class="memItemLeft" align="right" valign="top"><a id="acb1e52d0b6bcfce13bfb81dcb793f447" name="acb1e52d0b6bcfce13bfb81dcb793f447"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_CODE</b>&#160;&#160;&#160;0x00000600LU</td></tr>
<tr class="memdesc:acb1e52d0b6bcfce13bfb81dcb793f447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code ? <br /></td></tr>
<tr class="separator:acb1e52d0b6bcfce13bfb81dcb793f447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5493ad1870bae8ce9f5877aa4d571ba"><td class="memItemLeft" align="right" valign="top"><a id="ac5493ad1870bae8ce9f5877aa4d571ba" name="ac5493ad1870bae8ce9f5877aa4d571ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_DATA</b>&#160;&#160;&#160;0x00000400LU</td></tr>
<tr class="memdesc:ac5493ad1870bae8ce9f5877aa4d571ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data ? <br /></td></tr>
<tr class="separator:ac5493ad1870bae8ce9f5877aa4d571ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeead14ecfc3f786262724e1c972d9578"><td class="memItemLeft" align="right" valign="top"><a id="aeead14ecfc3f786262724e1c972d9578" name="aeead14ecfc3f786262724e1c972d9578"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_TAIL</b>&#160;&#160;&#160;0x00000200LU</td></tr>
<tr class="memdesc:aeead14ecfc3f786262724e1c972d9578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tail ? <br /></td></tr>
<tr class="separator:aeead14ecfc3f786262724e1c972d9578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29948064e290fa7beaf29dd59554bb24"><td class="memItemLeft" align="right" valign="top"><a id="a29948064e290fa7beaf29dd59554bb24" name="a29948064e290fa7beaf29dd59554bb24"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_UNK</b>&#160;&#160;&#160;0x00000000LU</td></tr>
<tr class="memdesc:a29948064e290fa7beaf29dd59554bb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unknown ? <br /></td></tr>
<tr class="separator:a29948064e290fa7beaf29dd59554bb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c15a46c8b13af0ca2eba81c518f6e85"><td class="memItemLeft" align="right" valign="top"><a id="a9c15a46c8b13af0ca2eba81c518f6e85" name="a9c15a46c8b13af0ca2eba81c518f6e85"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DELIT_SIMPLE</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:a9c15a46c8b13af0ca2eba81c518f6e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">simply undefine the specified item(s) <br /></td></tr>
<tr class="separator:a9c15a46c8b13af0ca2eba81c518f6e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b692b10e0343910ae487c7b16be500"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a22b692b10e0343910ae487c7b16be500">DELIT_EXPAND</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a22b692b10e0343910ae487c7b16be500"><td class="mdescLeft">&#160;</td><td class="mdescRight">propagate undefined items; for example if removing an instruction removes all references to the next instruction, then plan to convert to unexplored the next instruction too.  <a href="bytes_8hpp.html#a22b692b10e0343910ae487c7b16be500">More...</a><br /></td></tr>
<tr class="separator:a22b692b10e0343910ae487c7b16be500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25f19f8244498e366ee6d4e67c1f87f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa25f19f8244498e366ee6d4e67c1f87f">DELIT_DELNAMES</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:aa25f19f8244498e366ee6d4e67c1f87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete any names at the specified address range (except for the starting address).  <a href="bytes_8hpp.html#aa25f19f8244498e366ee6d4e67c1f87f">More...</a><br /></td></tr>
<tr class="separator:aa25f19f8244498e366ee6d4e67c1f87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1474329a9302a019197e0c4b9bcc87cb"><td class="memItemLeft" align="right" valign="top"><a id="a1474329a9302a019197e0c4b9bcc87cb" name="a1474329a9302a019197e0c4b9bcc87cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DELIT_NOTRUNC</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a1474329a9302a019197e0c4b9bcc87cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't truncate the current function even if <a class="el" href="ida_8hpp.html#a3c25b68da3beb76b2710bbaf22481d1f" title="Truncate functions upon code deletion.">AF_TRFUNC</a> is set <br /></td></tr>
<tr class="separator:a1474329a9302a019197e0c4b9bcc87cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961a68bf588417b7af6b18f1e06a3188"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a961a68bf588417b7af6b18f1e06a3188">DELIT_NOUNAME</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a961a68bf588417b7af6b18f1e06a3188"><td class="mdescLeft">&#160;</td><td class="mdescRight">reject to delete if a user name is in address range (except for the starting address).  <a href="bytes_8hpp.html#a961a68bf588417b7af6b18f1e06a3188">More...</a><br /></td></tr>
<tr class="separator:a961a68bf588417b7af6b18f1e06a3188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9449948e27d8358dfc5675a91af223c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a9449948e27d8358dfc5675a91af223c2">DELIT_NOCMT</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a9449948e27d8358dfc5675a91af223c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">reject to delete if a comment is in address range (except for the starting address).  <a href="bytes_8hpp.html#a9449948e27d8358dfc5675a91af223c2">More...</a><br /></td></tr>
<tr class="separator:a9449948e27d8358dfc5675a91af223c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cccdca4c55b3979526fa54491accf0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a88cccdca4c55b3979526fa54491accf0">DELIT_KEEPFUNC</a>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a88cccdca4c55b3979526fa54491accf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not undefine the function start.  <a href="bytes_8hpp.html#a88cccdca4c55b3979526fa54491accf0">More...</a><br /></td></tr>
<tr class="separator:a88cccdca4c55b3979526fa54491accf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d8165f474f9ce7b446a01cd62c2487"><td class="memItemLeft" align="right" valign="top"><a id="a12d8165f474f9ce7b446a01cd62c2487" name="a12d8165f474f9ce7b446a01cd62c2487"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MS_COMM</b>&#160;&#160;&#160;0x000FF800</td></tr>
<tr class="memdesc:a12d8165f474f9ce7b446a01cd62c2487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of common bits. <br /></td></tr>
<tr class="separator:a12d8165f474f9ce7b446a01cd62c2487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6bc18df575117f77e88358999ae774"><td class="memItemLeft" align="right" valign="top"><a id="a9d6bc18df575117f77e88358999ae774" name="a9d6bc18df575117f77e88358999ae774"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_COMM</b>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="memdesc:a9d6bc18df575117f77e88358999ae774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has comment ? <br /></td></tr>
<tr class="separator:a9d6bc18df575117f77e88358999ae774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994226340d4ab0a913663fc0aaffce8e"><td class="memItemLeft" align="right" valign="top"><a id="a994226340d4ab0a913663fc0aaffce8e" name="a994226340d4ab0a913663fc0aaffce8e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_REF</b>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="memdesc:a994226340d4ab0a913663fc0aaffce8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">has references <br /></td></tr>
<tr class="separator:a994226340d4ab0a913663fc0aaffce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05134ba46e9573b1444b30a5b9ef7e14"><td class="memItemLeft" align="right" valign="top"><a id="a05134ba46e9573b1444b30a5b9ef7e14" name="a05134ba46e9573b1444b30a5b9ef7e14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_LINE</b>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="memdesc:a05134ba46e9573b1444b30a5b9ef7e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has next or prev lines ? <br /></td></tr>
<tr class="separator:a05134ba46e9573b1444b30a5b9ef7e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bee89a4355fe06b0cf8f8881475960c"><td class="memItemLeft" align="right" valign="top"><a id="a4bee89a4355fe06b0cf8f8881475960c" name="a4bee89a4355fe06b0cf8f8881475960c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_NAME</b>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="memdesc:a4bee89a4355fe06b0cf8f8881475960c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has name ? <br /></td></tr>
<tr class="separator:a4bee89a4355fe06b0cf8f8881475960c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46eea0cd558a2594c66d6cc3241833c6"><td class="memItemLeft" align="right" valign="top"><a id="a46eea0cd558a2594c66d6cc3241833c6" name="a46eea0cd558a2594c66d6cc3241833c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_LABL</b>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="memdesc:a46eea0cd558a2594c66d6cc3241833c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has dummy name? <br /></td></tr>
<tr class="separator:a46eea0cd558a2594c66d6cc3241833c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8042b10b442ee112b6d00e14bc135623"><td class="memItemLeft" align="right" valign="top"><a id="a8042b10b442ee112b6d00e14bc135623" name="a8042b10b442ee112b6d00e14bc135623"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_FLOW</b>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="memdesc:a8042b10b442ee112b6d00e14bc135623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exec flow from prev instruction. <br /></td></tr>
<tr class="separator:a8042b10b442ee112b6d00e14bc135623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb69389901255a7f2cfaeb81336a620"><td class="memItemLeft" align="right" valign="top"><a id="adeb69389901255a7f2cfaeb81336a620" name="adeb69389901255a7f2cfaeb81336a620"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_SIGN</b>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="memdesc:adeb69389901255a7f2cfaeb81336a620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverted sign of operands. <br /></td></tr>
<tr class="separator:adeb69389901255a7f2cfaeb81336a620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cac9e7dc42b33513c0224d0e245c49"><td class="memItemLeft" align="right" valign="top"><a id="a58cac9e7dc42b33513c0224d0e245c49" name="a58cac9e7dc42b33513c0224d0e245c49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_BNOT</b>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="memdesc:a58cac9e7dc42b33513c0224d0e245c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise negation of operands. <br /></td></tr>
<tr class="separator:a58cac9e7dc42b33513c0224d0e245c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bb5ad0320c00cd43c208362c523b6c"><td class="memItemLeft" align="right" valign="top"><a id="a21bb5ad0320c00cd43c208362c523b6c" name="a21bb5ad0320c00cd43c208362c523b6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_UNUSED</b>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="memdesc:a21bb5ad0320c00cd43c208362c523b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">unused bit (was used for variable bytes) <br /></td></tr>
<tr class="separator:a21bb5ad0320c00cd43c208362c523b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa5094f3e997ff568895358880357d9"><td class="memItemLeft" align="right" valign="top"><a id="a6aa5094f3e997ff568895358880357d9" name="a6aa5094f3e997ff568895358880357d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_ANYNAME</b>&#160;&#160;&#160;(<a class="el" href="bytes_8hpp.html#a46eea0cd558a2594c66d6cc3241833c6">FF_LABL</a>|<a class="el" href="bytes_8hpp.html#a4bee89a4355fe06b0cf8f8881475960c">FF_NAME</a>)</td></tr>
<tr class="separator:a6aa5094f3e997ff568895358880357d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05f3aaeed494db31faa7b2e3478c34b"><td class="memItemLeft" align="right" valign="top"><a id="af05f3aaeed494db31faa7b2e3478c34b" name="af05f3aaeed494db31faa7b2e3478c34b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MS_N_TYPE</b>&#160;&#160;&#160;0xFLLU</td></tr>
<tr class="memdesc:af05f3aaeed494db31faa7b2e3478c34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for nth arg. <br /></td></tr>
<tr class="separator:af05f3aaeed494db31faa7b2e3478c34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c2790d79da470e90cd88987a06ea0a"><td class="memItemLeft" align="right" valign="top"><a id="ac0c2790d79da470e90cd88987a06ea0a" name="ac0c2790d79da470e90cd88987a06ea0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_VOID</b>&#160;&#160;&#160;0x0</td></tr>
<tr class="memdesc:ac0c2790d79da470e90cd88987a06ea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void (unknown)? <br /></td></tr>
<tr class="separator:ac0c2790d79da470e90cd88987a06ea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc3da461a08842c5eb3e01484efb426"><td class="memItemLeft" align="right" valign="top"><a id="addc3da461a08842c5eb3e01484efb426" name="addc3da461a08842c5eb3e01484efb426"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_NUMH</b>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:addc3da461a08842c5eb3e01484efb426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hexadecimal number? <br /></td></tr>
<tr class="separator:addc3da461a08842c5eb3e01484efb426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f25dc7b7dcd0a65051a8ae4c0fff59"><td class="memItemLeft" align="right" valign="top"><a id="a77f25dc7b7dcd0a65051a8ae4c0fff59" name="a77f25dc7b7dcd0a65051a8ae4c0fff59"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_NUMD</b>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:a77f25dc7b7dcd0a65051a8ae4c0fff59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decimal number? <br /></td></tr>
<tr class="separator:a77f25dc7b7dcd0a65051a8ae4c0fff59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50dc9686e4392086b58cb3c88310621f"><td class="memItemLeft" align="right" valign="top"><a id="a50dc9686e4392086b58cb3c88310621f" name="a50dc9686e4392086b58cb3c88310621f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_CHAR</b>&#160;&#160;&#160;0x3</td></tr>
<tr class="memdesc:a50dc9686e4392086b58cb3c88310621f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Char ('x')? <br /></td></tr>
<tr class="separator:a50dc9686e4392086b58cb3c88310621f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308eda7c982aed1f8ccbe810a8cb68b5"><td class="memItemLeft" align="right" valign="top"><a id="a308eda7c982aed1f8ccbe810a8cb68b5" name="a308eda7c982aed1f8ccbe810a8cb68b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_SEG</b>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:a308eda7c982aed1f8ccbe810a8cb68b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment? <br /></td></tr>
<tr class="separator:a308eda7c982aed1f8ccbe810a8cb68b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84fa6a1c52b7c0b06b42013255a250a"><td class="memItemLeft" align="right" valign="top"><a id="ac84fa6a1c52b7c0b06b42013255a250a" name="ac84fa6a1c52b7c0b06b42013255a250a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_OFF</b>&#160;&#160;&#160;0x5</td></tr>
<tr class="memdesc:ac84fa6a1c52b7c0b06b42013255a250a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset? <br /></td></tr>
<tr class="separator:ac84fa6a1c52b7c0b06b42013255a250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0045d5bb303dace559216a588b01b706"><td class="memItemLeft" align="right" valign="top"><a id="a0045d5bb303dace559216a588b01b706" name="a0045d5bb303dace559216a588b01b706"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_NUMB</b>&#160;&#160;&#160;0x6</td></tr>
<tr class="memdesc:a0045d5bb303dace559216a588b01b706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary number? <br /></td></tr>
<tr class="separator:a0045d5bb303dace559216a588b01b706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33be253746a871d61d16b4ba4e2f53da"><td class="memItemLeft" align="right" valign="top"><a id="a33be253746a871d61d16b4ba4e2f53da" name="a33be253746a871d61d16b4ba4e2f53da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_NUMO</b>&#160;&#160;&#160;0x7</td></tr>
<tr class="memdesc:a33be253746a871d61d16b4ba4e2f53da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Octal number? <br /></td></tr>
<tr class="separator:a33be253746a871d61d16b4ba4e2f53da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7727ef2ca6fb0b527c9d7916394ad603"><td class="memItemLeft" align="right" valign="top"><a id="a7727ef2ca6fb0b527c9d7916394ad603" name="a7727ef2ca6fb0b527c9d7916394ad603"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_ENUM</b>&#160;&#160;&#160;0x8</td></tr>
<tr class="memdesc:a7727ef2ca6fb0b527c9d7916394ad603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration? <br /></td></tr>
<tr class="separator:a7727ef2ca6fb0b527c9d7916394ad603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece22da4baf5737458f760fdb591334d"><td class="memItemLeft" align="right" valign="top"><a id="aece22da4baf5737458f760fdb591334d" name="aece22da4baf5737458f760fdb591334d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_FOP</b>&#160;&#160;&#160;0x9</td></tr>
<tr class="memdesc:aece22da4baf5737458f760fdb591334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forced operand? <br /></td></tr>
<tr class="separator:aece22da4baf5737458f760fdb591334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210df34af74334c1669104b18edb8a3e"><td class="memItemLeft" align="right" valign="top"><a id="a210df34af74334c1669104b18edb8a3e" name="a210df34af74334c1669104b18edb8a3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_STRO</b>&#160;&#160;&#160;0xA</td></tr>
<tr class="memdesc:a210df34af74334c1669104b18edb8a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct offset? <br /></td></tr>
<tr class="separator:a210df34af74334c1669104b18edb8a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e19521ae3f02a3a9a743e44a486206"><td class="memItemLeft" align="right" valign="top"><a id="ad0e19521ae3f02a3a9a743e44a486206" name="ad0e19521ae3f02a3a9a743e44a486206"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_STK</b>&#160;&#160;&#160;0xB</td></tr>
<tr class="memdesc:ad0e19521ae3f02a3a9a743e44a486206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack variable? <br /></td></tr>
<tr class="separator:ad0e19521ae3f02a3a9a743e44a486206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328847f654df02226280007b59451adb"><td class="memItemLeft" align="right" valign="top"><a id="a328847f654df02226280007b59451adb" name="a328847f654df02226280007b59451adb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_FLT</b>&#160;&#160;&#160;0xC</td></tr>
<tr class="memdesc:a328847f654df02226280007b59451adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point number? <br /></td></tr>
<tr class="separator:a328847f654df02226280007b59451adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80aa00b85cf8771a788bff67dd86ddef"><td class="memItemLeft" align="right" valign="top"><a id="a80aa00b85cf8771a788bff67dd86ddef" name="a80aa00b85cf8771a788bff67dd86ddef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_N_CUST</b>&#160;&#160;&#160;0xD</td></tr>
<tr class="memdesc:a80aa00b85cf8771a788bff67dd86ddef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom representation? <br /></td></tr>
<tr class="separator:a80aa00b85cf8771a788bff67dd86ddef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ff56ce8ed4030acdca9d9314038dfb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ae3ff56ce8ed4030acdca9d9314038dfb">OPND_OUTER</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:ae3ff56ce8ed4030acdca9d9314038dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">outer offset base (combined with operand number).  <a href="bytes_8hpp.html#ae3ff56ce8ed4030acdca9d9314038dfb">More...</a><br /></td></tr>
<tr class="separator:ae3ff56ce8ed4030acdca9d9314038dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3177b4c883cc4b74938f6fb7559587c0"><td class="memItemLeft" align="right" valign="top"><a id="a3177b4c883cc4b74938f6fb7559587c0" name="a3177b4c883cc4b74938f6fb7559587c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OPND_MASK</b>&#160;&#160;&#160;0x0F</td></tr>
<tr class="memdesc:a3177b4c883cc4b74938f6fb7559587c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask for operand number <br /></td></tr>
<tr class="separator:a3177b4c883cc4b74938f6fb7559587c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c9062b3ef1f5460266a4a6426ff0fe"><td class="memItemLeft" align="right" valign="top"><a id="a88c9062b3ef1f5460266a4a6426ff0fe" name="a88c9062b3ef1f5460266a4a6426ff0fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>OPND_ALL</b>&#160;&#160;&#160;<a class="el" href="bytes_8hpp.html#a3177b4c883cc4b74938f6fb7559587c0">OPND_MASK</a></td></tr>
<tr class="memdesc:a88c9062b3ef1f5460266a4a6426ff0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">all operands <br /></td></tr>
<tr class="separator:a88c9062b3ef1f5460266a4a6426ff0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15fa9a90fbd9080a18471dcc51c5f63"><td class="memItemLeft" align="right" valign="top"><a id="aa15fa9a90fbd9080a18471dcc51c5f63" name="aa15fa9a90fbd9080a18471dcc51c5f63"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DT_TYPE</b>&#160;&#160;&#160;0xF0000000</td></tr>
<tr class="memdesc:aa15fa9a90fbd9080a18471dcc51c5f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for DATA typing. <br /></td></tr>
<tr class="separator:aa15fa9a90fbd9080a18471dcc51c5f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e184e1e9e9986dccb2bf75a5cc281a"><td class="memItemLeft" align="right" valign="top"><a id="a31e184e1e9e9986dccb2bf75a5cc281a" name="a31e184e1e9e9986dccb2bf75a5cc281a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_BYTE</b>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="memdesc:a31e184e1e9e9986dccb2bf75a5cc281a"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte <br /></td></tr>
<tr class="separator:a31e184e1e9e9986dccb2bf75a5cc281a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700e6fe75ce2d59afe9f0337419e5fb3"><td class="memItemLeft" align="right" valign="top"><a id="a700e6fe75ce2d59afe9f0337419e5fb3" name="a700e6fe75ce2d59afe9f0337419e5fb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_WORD</b>&#160;&#160;&#160;0x10000000</td></tr>
<tr class="memdesc:a700e6fe75ce2d59afe9f0337419e5fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">word <br /></td></tr>
<tr class="separator:a700e6fe75ce2d59afe9f0337419e5fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113c39256aa0eb30138fc3dcbbb1b224"><td class="memItemLeft" align="right" valign="top"><a id="a113c39256aa0eb30138fc3dcbbb1b224" name="a113c39256aa0eb30138fc3dcbbb1b224"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_DWORD</b>&#160;&#160;&#160;0x20000000</td></tr>
<tr class="memdesc:a113c39256aa0eb30138fc3dcbbb1b224"><td class="mdescLeft">&#160;</td><td class="mdescRight">double word <br /></td></tr>
<tr class="separator:a113c39256aa0eb30138fc3dcbbb1b224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d61c8ba1d3bedefbd3e619f1f4116a"><td class="memItemLeft" align="right" valign="top"><a id="a74d61c8ba1d3bedefbd3e619f1f4116a" name="a74d61c8ba1d3bedefbd3e619f1f4116a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_QWORD</b>&#160;&#160;&#160;0x30000000</td></tr>
<tr class="memdesc:a74d61c8ba1d3bedefbd3e619f1f4116a"><td class="mdescLeft">&#160;</td><td class="mdescRight">quadro word <br /></td></tr>
<tr class="separator:a74d61c8ba1d3bedefbd3e619f1f4116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0cb6734338e1ed1a3188d6b4c70b8f"><td class="memItemLeft" align="right" valign="top"><a id="a8b0cb6734338e1ed1a3188d6b4c70b8f" name="a8b0cb6734338e1ed1a3188d6b4c70b8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_TBYTE</b>&#160;&#160;&#160;0x40000000</td></tr>
<tr class="memdesc:a8b0cb6734338e1ed1a3188d6b4c70b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">tbyte <br /></td></tr>
<tr class="separator:a8b0cb6734338e1ed1a3188d6b4c70b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa320c33a480cc1403e0c7912ee1bd522"><td class="memItemLeft" align="right" valign="top"><a id="aa320c33a480cc1403e0c7912ee1bd522" name="aa320c33a480cc1403e0c7912ee1bd522"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_STRLIT</b>&#160;&#160;&#160;0x50000000</td></tr>
<tr class="memdesc:aa320c33a480cc1403e0c7912ee1bd522"><td class="mdescLeft">&#160;</td><td class="mdescRight">string literal <br /></td></tr>
<tr class="separator:aa320c33a480cc1403e0c7912ee1bd522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303e1d05f0fd18c165ff0c2c7e4aa4de"><td class="memItemLeft" align="right" valign="top"><a id="a303e1d05f0fd18c165ff0c2c7e4aa4de" name="a303e1d05f0fd18c165ff0c2c7e4aa4de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_STRUCT</b>&#160;&#160;&#160;0x60000000</td></tr>
<tr class="memdesc:a303e1d05f0fd18c165ff0c2c7e4aa4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct variable <br /></td></tr>
<tr class="separator:a303e1d05f0fd18c165ff0c2c7e4aa4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6102a6e3eebb8350527c7613792080ae"><td class="memItemLeft" align="right" valign="top"><a id="a6102a6e3eebb8350527c7613792080ae" name="a6102a6e3eebb8350527c7613792080ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_OWORD</b>&#160;&#160;&#160;0x70000000</td></tr>
<tr class="memdesc:a6102a6e3eebb8350527c7613792080ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">octaword/xmm word (16 bytes/128 bits) <br /></td></tr>
<tr class="separator:a6102a6e3eebb8350527c7613792080ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1e062047911a7fda90a84959fa49bc"><td class="memItemLeft" align="right" valign="top"><a id="adc1e062047911a7fda90a84959fa49bc" name="adc1e062047911a7fda90a84959fa49bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_FLOAT</b>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:adc1e062047911a7fda90a84959fa49bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">float <br /></td></tr>
<tr class="separator:adc1e062047911a7fda90a84959fa49bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709bb154304e65d8991bc081a182ce2e"><td class="memItemLeft" align="right" valign="top"><a id="a709bb154304e65d8991bc081a182ce2e" name="a709bb154304e65d8991bc081a182ce2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_DOUBLE</b>&#160;&#160;&#160;0x90000000</td></tr>
<tr class="memdesc:a709bb154304e65d8991bc081a182ce2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">double <br /></td></tr>
<tr class="separator:a709bb154304e65d8991bc081a182ce2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0adb817e6662035bd7d06346c01c864"><td class="memItemLeft" align="right" valign="top"><a id="aa0adb817e6662035bd7d06346c01c864" name="aa0adb817e6662035bd7d06346c01c864"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_PACKREAL</b>&#160;&#160;&#160;0xA0000000</td></tr>
<tr class="memdesc:aa0adb817e6662035bd7d06346c01c864"><td class="mdescLeft">&#160;</td><td class="mdescRight">packed decimal real <br /></td></tr>
<tr class="separator:aa0adb817e6662035bd7d06346c01c864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f222cbe3cbe2570892096fc7dc1e8c"><td class="memItemLeft" align="right" valign="top"><a id="a61f222cbe3cbe2570892096fc7dc1e8c" name="a61f222cbe3cbe2570892096fc7dc1e8c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_ALIGN</b>&#160;&#160;&#160;0xB0000000</td></tr>
<tr class="memdesc:a61f222cbe3cbe2570892096fc7dc1e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">alignment directive <br /></td></tr>
<tr class="separator:a61f222cbe3cbe2570892096fc7dc1e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f933094d6c5c52e6f9861d533d1382"><td class="memItemLeft" align="right" valign="top"><a id="a19f933094d6c5c52e6f9861d533d1382" name="a19f933094d6c5c52e6f9861d533d1382"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_CUSTOM</b>&#160;&#160;&#160;0xD0000000</td></tr>
<tr class="memdesc:a19f933094d6c5c52e6f9861d533d1382"><td class="mdescLeft">&#160;</td><td class="mdescRight">custom data type <br /></td></tr>
<tr class="separator:a19f933094d6c5c52e6f9861d533d1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5878e95aef45b3816e5cfcf16cacb9"><td class="memItemLeft" align="right" valign="top"><a id="a4c5878e95aef45b3816e5cfcf16cacb9" name="a4c5878e95aef45b3816e5cfcf16cacb9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_YWORD</b>&#160;&#160;&#160;0xE0000000</td></tr>
<tr class="memdesc:a4c5878e95aef45b3816e5cfcf16cacb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ymm word (32 bytes/256 bits) <br /></td></tr>
<tr class="separator:a4c5878e95aef45b3816e5cfcf16cacb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c513c72624ec1d284f2c3e9f295a6e8"><td class="memItemLeft" align="right" valign="top"><a id="a3c513c72624ec1d284f2c3e9f295a6e8" name="a3c513c72624ec1d284f2c3e9f295a6e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_ZWORD</b>&#160;&#160;&#160;0xF0000000</td></tr>
<tr class="memdesc:a3c513c72624ec1d284f2c3e9f295a6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">zmm word (64 bytes/512 bits) <br /></td></tr>
<tr class="separator:a3c513c72624ec1d284f2c3e9f295a6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab515dd7718288c757c1cba570a710896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ab515dd7718288c757c1cba570a710896">ALOPT_IGNHEADS</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ab515dd7718288c757c1cba570a710896"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't stop if another data item is encountered.  <a href="bytes_8hpp.html#ab515dd7718288c757c1cba570a710896">More...</a><br /></td></tr>
<tr class="separator:ab515dd7718288c757c1cba570a710896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf395d86b486517c3cc5eb4a58520ca3"><td class="memItemLeft" align="right" valign="top"><a id="adf395d86b486517c3cc5eb4a58520ca3" name="adf395d86b486517c3cc5eb4a58520ca3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ALOPT_IGNPRINT</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:adf395d86b486517c3cc5eb4a58520ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, don't stop at non-printable codepoints, but only at the terminating character (or not unicode-mapped character (e.g., 0x8f in CP1252)) <br /></td></tr>
<tr class="separator:adf395d86b486517c3cc5eb4a58520ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8f8e66acfe569719d195aec70ab78f"><td class="memItemLeft" align="right" valign="top"><a id="aae8f8e66acfe569719d195aec70ab78f" name="aae8f8e66acfe569719d195aec70ab78f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ALOPT_IGNCLT</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:aae8f8e66acfe569719d195aec70ab78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, don't stop at codepoints that are not part of the current 'culture'; accept all those that are graphical (this is typically used used by user-initiated actions creating string literals.) <br /></td></tr>
<tr class="separator:aae8f8e66acfe569719d195aec70ab78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86e241f7cae7281412eb1d40d503beb"><td class="memItemLeft" align="right" valign="top"><a id="af86e241f7cae7281412eb1d40d503beb" name="af86e241f7cae7281412eb1d40d503beb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ALOPT_MAX4K</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:af86e241f7cae7281412eb1d40d503beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">if string length is more than 4K, return the accumulated length <br /></td></tr>
<tr class="separator:af86e241f7cae7281412eb1d40d503beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5c3c90be522fb41e6fdac5b5f31116"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a2d5c3c90be522fb41e6fdac5b5f31116">ALOPT_ONLYTERM</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a2d5c3c90be522fb41e6fdac5b5f31116"><td class="mdescLeft">&#160;</td><td class="mdescRight">only the termination characters can be at the string end.  <a href="bytes_8hpp.html#a2d5c3c90be522fb41e6fdac5b5f31116">More...</a><br /></td></tr>
<tr class="separator:a2d5c3c90be522fb41e6fdac5b5f31116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888b2ff38fbe15c6647f35bbbd353c97"><td class="memItemLeft" align="right" valign="top"><a id="a888b2ff38fbe15c6647f35bbbd353c97" name="a888b2ff38fbe15c6647f35bbbd353c97"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRCONV_ESCAPE</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:a888b2ff38fbe15c6647f35bbbd353c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert non-printable characters to C escapes (<br  />
, \xNN, \uNNNN) <br /></td></tr>
<tr class="separator:a888b2ff38fbe15c6647f35bbbd353c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d42fda7a9cebc1ae84bf61ce82286b"><td class="memItemLeft" align="right" valign="top"><a id="ac9d42fda7a9cebc1ae84bf61ce82286b" name="ac9d42fda7a9cebc1ae84bf61ce82286b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRCONV_REPLCHAR</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:ac9d42fda7a9cebc1ae84bf61ce82286b"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert non-printable characters to the Unicode replacement character (U+FFFD) <br /></td></tr>
<tr class="separator:ac9d42fda7a9cebc1ae84bf61ce82286b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afede03762eff206fbc9eb2f14aa011d5"><td class="memItemLeft" align="right" valign="top"><a id="afede03762eff206fbc9eb2f14aa011d5" name="afede03762eff206fbc9eb2f14aa011d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRCONV_INCLLEN</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:afede03762eff206fbc9eb2f14aa011d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">for Pascal-style strings, include the prefixing length byte(s) as C-escaped sequence <br /></td></tr>
<tr class="separator:afede03762eff206fbc9eb2f14aa011d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55520a48755b26a37c63b59250b5ad4c"><td class="memItemLeft" align="right" valign="top"><a id="a55520a48755b26a37c63b59250b5ad4c" name="a55520a48755b26a37c63b59250b5ad4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PSTF_TNORM</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a55520a48755b26a37c63b59250b5ad4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">use normal name <br /></td></tr>
<tr class="separator:a55520a48755b26a37c63b59250b5ad4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4129f54c57630bff48b9fa71cbef31b1"><td class="memItemLeft" align="right" valign="top"><a id="a4129f54c57630bff48b9fa71cbef31b1" name="a4129f54c57630bff48b9fa71cbef31b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PSTF_TBRIEF</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a4129f54c57630bff48b9fa71cbef31b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">use brief name (e.g., in the 'Strings' window) <br /></td></tr>
<tr class="separator:a4129f54c57630bff48b9fa71cbef31b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c76ea69adb0d8c484a6fe77673e873"><td class="memItemLeft" align="right" valign="top"><a id="a44c76ea69adb0d8c484a6fe77673e873" name="a44c76ea69adb0d8c484a6fe77673e873"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PSTF_TINLIN</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a44c76ea69adb0d8c484a6fe77673e873"><td class="mdescLeft">&#160;</td><td class="mdescRight">use 'inline' name (e.g., in the structures comments) <br /></td></tr>
<tr class="separator:a44c76ea69adb0d8c484a6fe77673e873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81c3982cae280236b0cf597d0ed81df"><td class="memItemLeft" align="right" valign="top"><a id="ae81c3982cae280236b0cf597d0ed81df" name="ae81c3982cae280236b0cf597d0ed81df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PSTF_TMASK</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ae81c3982cae280236b0cf597d0ed81df"><td class="mdescLeft">&#160;</td><td class="mdescRight">type mask <br /></td></tr>
<tr class="separator:ae81c3982cae280236b0cf597d0ed81df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50c7640745f0bab67b3d9fc642e6729"><td class="memItemLeft" align="right" valign="top"><a id="ac50c7640745f0bab67b3d9fc642e6729" name="ac50c7640745f0bab67b3d9fc642e6729"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PSTF_HOTKEY</b>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:ac50c7640745f0bab67b3d9fc642e6729"><td class="mdescLeft">&#160;</td><td class="mdescRight">have hotkey markers part of the name <br /></td></tr>
<tr class="separator:ac50c7640745f0bab67b3d9fc642e6729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76b4134e191a511a0461697144e01dd"><td class="memItemLeft" align="right" valign="top"><a id="ae76b4134e191a511a0461697144e01dd" name="ae76b4134e191a511a0461697144e01dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PSTF_ENC</b>&#160;&#160;&#160;0x8</td></tr>
<tr class="memdesc:ae76b4134e191a511a0461697144e01dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">if encoding is specified, append it <br /></td></tr>
<tr class="separator:ae76b4134e191a511a0461697144e01dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac535796e6900f5cdad7d5b95f445d66b"><td class="memItemLeft" align="right" valign="top"><a id="ac535796e6900f5cdad7d5b95f445d66b" name="ac535796e6900f5cdad7d5b95f445d66b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PSTF_ONLY_ENC</b>&#160;&#160;&#160;0xB</td></tr>
<tr class="memdesc:ac535796e6900f5cdad7d5b95f445d66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate only the encoding name <br /></td></tr>
<tr class="separator:ac535796e6900f5cdad7d5b95f445d66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0793209a0a00bc39014ff3a4c5fae1"><td class="memItemLeft" align="right" valign="top"><a id="a0b0793209a0a00bc39014ff3a4c5fae1" name="a0b0793209a0a00bc39014ff3a4c5fae1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MS_CODE</b>&#160;&#160;&#160;0xF0000000LU</td></tr>
<tr class="memdesc:a0b0793209a0a00bc39014ff3a4c5fae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask for code bits. <br /></td></tr>
<tr class="separator:a0b0793209a0a00bc39014ff3a4c5fae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030498a74ca4ffd002e415aaa65d4a09"><td class="memItemLeft" align="right" valign="top"><a id="a030498a74ca4ffd002e415aaa65d4a09" name="a030498a74ca4ffd002e415aaa65d4a09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_FUNC</b>&#160;&#160;&#160;0x10000000LU</td></tr>
<tr class="memdesc:a030498a74ca4ffd002e415aaa65d4a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">function start? <br /></td></tr>
<tr class="separator:a030498a74ca4ffd002e415aaa65d4a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea2ec7d412b8d21330145f9bd8d7543"><td class="memItemLeft" align="right" valign="top"><a id="acea2ec7d412b8d21330145f9bd8d7543" name="acea2ec7d412b8d21330145f9bd8d7543"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_IMMD</b>&#160;&#160;&#160;0x40000000LU</td></tr>
<tr class="memdesc:acea2ec7d412b8d21330145f9bd8d7543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has Immediate value ? <br /></td></tr>
<tr class="separator:acea2ec7d412b8d21330145f9bd8d7543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3868bbb0c79f098fa47864144ad21e29"><td class="memItemLeft" align="right" valign="top"><a id="a3868bbb0c79f098fa47864144ad21e29" name="a3868bbb0c79f098fa47864144ad21e29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FF_JUMP</b>&#160;&#160;&#160;0x80000000LU</td></tr>
<tr class="memdesc:a3868bbb0c79f098fa47864144ad21e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has jump table or switch_info? <br /></td></tr>
<tr class="separator:a3868bbb0c79f098fa47864144ad21e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b8c2af1a6c1132095c17ae1165b073"><td class="memItemLeft" align="right" valign="top"><a id="a64b8c2af1a6c1132095c17ae1165b073" name="a64b8c2af1a6c1132095c17ae1165b073"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DTP_NODUP</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a64b8c2af1a6c1132095c17ae1165b073"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not use dup construct <br /></td></tr>
<tr class="separator:a64b8c2af1a6c1132095c17ae1165b073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae08a5108faeede508d484c750d0cfd"><td class="memItemLeft" align="right" valign="top"><a id="abae08a5108faeede508d484c750d0cfd" name="abae08a5108faeede508d484c750d0cfd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PBSENC_DEF1BPU</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:abae08a5108faeede508d484c750d0cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b77a00b8c7fdbc832089905f0c65858"><td class="memItemLeft" align="right" valign="top"><a id="a2b77a00b8c7fdbc832089905f0c65858" name="a2b77a00b8c7fdbc832089905f0c65858"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PBSENC_ALL</b>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a2b77a00b8c7fdbc832089905f0c65858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99047fb3efd3a20d6408fe254986857c"><td class="memItemLeft" align="right" valign="top"><a id="a99047fb3efd3a20d6408fe254986857c" name="a99047fb3efd3a20d6408fe254986857c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIN_SEARCH_CASE</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:a99047fb3efd3a20d6408fe254986857c"><td class="mdescLeft">&#160;</td><td class="mdescRight">case sensitive <br /></td></tr>
<tr class="separator:a99047fb3efd3a20d6408fe254986857c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29b9e150427231bd65e722d6da5d99a"><td class="memItemLeft" align="right" valign="top"><a id="aa29b9e150427231bd65e722d6da5d99a" name="aa29b9e150427231bd65e722d6da5d99a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIN_SEARCH_NOCASE</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:aa29b9e150427231bd65e722d6da5d99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">case insensitive <br /></td></tr>
<tr class="separator:aa29b9e150427231bd65e722d6da5d99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f5626f845da7e4d154298df7e578c5"><td class="memItemLeft" align="right" valign="top"><a id="ac5f5626f845da7e4d154298df7e578c5" name="ac5f5626f845da7e4d154298df7e578c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIN_SEARCH_NOBREAK</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ac5f5626f845da7e4d154298df7e578c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't check for Ctrl-Break <br /></td></tr>
<tr class="separator:ac5f5626f845da7e4d154298df7e578c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e83ee3339007b1a705d90dbd3ebbd79"><td class="memItemLeft" align="right" valign="top"><a id="a5e83ee3339007b1a705d90dbd3ebbd79" name="a5e83ee3339007b1a705d90dbd3ebbd79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIN_SEARCH_INITED</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:a5e83ee3339007b1a705d90dbd3ebbd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">find_byte, find_byter: any initilized value <br /></td></tr>
<tr class="separator:a5e83ee3339007b1a705d90dbd3ebbd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aab574623b349dd89ca861199966da4"><td class="memItemLeft" align="right" valign="top"><a id="a1aab574623b349dd89ca861199966da4" name="a1aab574623b349dd89ca861199966da4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIN_SEARCH_NOSHOW</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:a1aab574623b349dd89ca861199966da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't show search progress or update screen <br /></td></tr>
<tr class="separator:a1aab574623b349dd89ca861199966da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae693e84230e8c73a77b586476d2228d"><td class="memItemLeft" align="right" valign="top"><a id="aae693e84230e8c73a77b586476d2228d" name="aae693e84230e8c73a77b586476d2228d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIN_SEARCH_FORWARD</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:aae693e84230e8c73a77b586476d2228d"><td class="mdescLeft">&#160;</td><td class="mdescRight">search forward for bytes <br /></td></tr>
<tr class="separator:aae693e84230e8c73a77b586476d2228d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61febafd80579e98ab86c9f82b6c7fb"><td class="memItemLeft" align="right" valign="top"><a id="aa61febafd80579e98ab86c9f82b6c7fb" name="aa61febafd80579e98ab86c9f82b6c7fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIN_SEARCH_BACKWARD</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:aa61febafd80579e98ab86c9f82b6c7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">search backward for bytes <br /></td></tr>
<tr class="separator:aa61febafd80579e98ab86c9f82b6c7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b75766aaa28ee75ce2f0f23999781e7"><td class="memItemLeft" align="right" valign="top"><a id="a8b75766aaa28ee75ce2f0f23999781e7" name="a8b75766aaa28ee75ce2f0f23999781e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BIN_SEARCH_BITMASK</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:a8b75766aaa28ee75ce2f0f23999781e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">searching using strict bit mask <br /></td></tr>
<tr class="separator:a8b75766aaa28ee75ce2f0f23999781e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80006fc5cd3a216c0f514baad625c4d"><td class="memItemLeft" align="right" valign="top"><a id="aa80006fc5cd3a216c0f514baad625c4d" name="aa80006fc5cd3a216c0f514baad625c4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SKIP_FF_MASK</b>&#160;&#160;&#160;((const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *)0xFF)</td></tr>
<tr class="memdesc:aa80006fc5cd3a216c0f514baad625c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="bytes_8hpp.html#a7abd041353225e8daedd30f5d3df5fa1" title="Compare &#39;len&#39; bytes of the program starting from &#39;ea&#39; with &#39;image&#39;.">equal_bytes()</a> to skip 0xFF when searching the program. <br /></td></tr>
<tr class="separator:aa80006fc5cd3a216c0f514baad625c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b144490a5e9652704222ac2b636d4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a71b144490a5e9652704222ac2b636d4c">GET_ITEM_HEAD_BODY</a></td></tr>
<tr class="separator:a71b144490a5e9652704222ac2b636d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a320dc6698b7075a653144bbdf202b30e"><td class="memItemLeft" align="right" valign="top"><a id="a320dc6698b7075a653144bbdf202b30e" name="a320dc6698b7075a653144bbdf202b30e"></a>
typedef <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>enum_t</b></td></tr>
<tr class="separator:a320dc6698b7075a653144bbdf202b30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5185f9d189b9af5cbf47bdbaa3888eb"><td class="memItemLeft" align="right" valign="top"><a id="ad5185f9d189b9af5cbf47bdbaa3888eb" name="ad5185f9d189b9af5cbf47bdbaa3888eb"></a>
typedef bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>testf_t</b>(<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> flags, void *ud)</td></tr>
<tr class="memdesc:ad5185f9d189b9af5cbf47bdbaa3888eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag tester - see <a class="el" href="bytes_8hpp.html#acbed8e273e00e37da0acaa1a39bebe4a" title="Find next address with a flag satisfying the function &#39;testf&#39;.">next_that()</a>, <a class="el" href="bytes_8hpp.html#a4ed0dfef3c1ad728e3aa06ea077ba982" title="Find previous address with a flag satisfying the function &#39;testf&#39;.">prev_that()</a> <br /></td></tr>
<tr class="separator:ad5185f9d189b9af5cbf47bdbaa3888eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2808f4f5c5def4fb4738e218ae4af52"><td class="memItemLeft" align="right" valign="top"><a id="ad2808f4f5c5def4fb4738e218ae4af52" name="ad2808f4f5c5def4fb4738e218ae4af52"></a>
typedef bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>may_destroy_cb_t</b>(ea_t)</td></tr>
<tr class="memdesc:ad2808f4f5c5def4fb4738e218ae4af52"><td class="mdescLeft">&#160;</td><td class="mdescRight">del_items' callback function <br /></td></tr>
<tr class="separator:ad2808f4f5c5def4fb4738e218ae4af52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a4caba6273ed59a121fdac08d46cc0"><td class="memItemLeft" align="right" valign="top"><a id="a06a4caba6273ed59a121fdac08d46cc0" name="a06a4caba6273ed59a121fdac08d46cc0"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structcompiled__binpat__t.html">compiled_binpat_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>compiled_binpat_vec_t</b></td></tr>
<tr class="separator:a06a4caba6273ed59a121fdac08d46cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65aceba8ff4d52c9ebc9e6ee39a57515"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a65aceba8ff4d52c9ebc9e6ee39a57515">enable_flags</a> (ea_t start_ea, ea_t end_ea, <a class="el" href="ida_8hpp.html#ac437eddfbf695e39512a625d8bcf94c9">storage_type_t</a> stt)</td></tr>
<tr class="memdesc:a65aceba8ff4d52c9ebc9e6ee39a57515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate flags for address range.  <a href="bytes_8hpp.html#a65aceba8ff4d52c9ebc9e6ee39a57515">More...</a><br /></td></tr>
<tr class="separator:a65aceba8ff4d52c9ebc9e6ee39a57515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc5e1d82712ed05774378545c468757"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a8bc5e1d82712ed05774378545c468757">disable_flags</a> (ea_t start_ea, ea_t end_ea)</td></tr>
<tr class="memdesc:a8bc5e1d82712ed05774378545c468757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate flags for address range.  <a href="bytes_8hpp.html#a8bc5e1d82712ed05774378545c468757">More...</a><br /></td></tr>
<tr class="separator:a8bc5e1d82712ed05774378545c468757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68e23a2cf2a6befa42bb48693b89aa2"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#af68e23a2cf2a6befa42bb48693b89aa2">change_storage_type</a> (ea_t start_ea, ea_t end_ea, <a class="el" href="ida_8hpp.html#ac437eddfbf695e39512a625d8bcf94c9">storage_type_t</a> stt)</td></tr>
<tr class="memdesc:af68e23a2cf2a6befa42bb48693b89aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change flag storage type for address range.  <a href="bytes_8hpp.html#af68e23a2cf2a6befa42bb48693b89aa2">More...</a><br /></td></tr>
<tr class="separator:af68e23a2cf2a6befa42bb48693b89aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17500720aed6570f7ae22f683bfa2be5"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a17500720aed6570f7ae22f683bfa2be5">next_addr</a> (ea_t ea)</td></tr>
<tr class="memdesc:a17500720aed6570f7ae22f683bfa2be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next address in the program (i.e.  <a href="bytes_8hpp.html#a17500720aed6570f7ae22f683bfa2be5">More...</a><br /></td></tr>
<tr class="separator:a17500720aed6570f7ae22f683bfa2be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d97557521f544efbaef7054a92b341f"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a5d97557521f544efbaef7054a92b341f">prev_addr</a> (ea_t ea)</td></tr>
<tr class="memdesc:a5d97557521f544efbaef7054a92b341f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get previous address in the program.  <a href="bytes_8hpp.html#a5d97557521f544efbaef7054a92b341f">More...</a><br /></td></tr>
<tr class="separator:a5d97557521f544efbaef7054a92b341f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d3eeadd3381eec7751e5692153c0b0"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ac9d3eeadd3381eec7751e5692153c0b0">next_chunk</a> (ea_t ea)</td></tr>
<tr class="memdesc:ac9d3eeadd3381eec7751e5692153c0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first address of next contiguous chunk in the program.  <a href="bytes_8hpp.html#ac9d3eeadd3381eec7751e5692153c0b0">More...</a><br /></td></tr>
<tr class="separator:ac9d3eeadd3381eec7751e5692153c0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa31a0226a82fce1a1a916ee297862d8"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#afa31a0226a82fce1a1a916ee297862d8">prev_chunk</a> (ea_t ea)</td></tr>
<tr class="memdesc:afa31a0226a82fce1a1a916ee297862d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last address of previous contiguous chunk in the program.  <a href="bytes_8hpp.html#afa31a0226a82fce1a1a916ee297862d8">More...</a><br /></td></tr>
<tr class="separator:afa31a0226a82fce1a1a916ee297862d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd0f2cd0f755bc4926b9c8eb7bfcbc3"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#abbd0f2cd0f755bc4926b9c8eb7bfcbc3">chunk_start</a> (ea_t ea)</td></tr>
<tr class="memdesc:abbd0f2cd0f755bc4926b9c8eb7bfcbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get start of the contiguous address block containing 'ea'.  <a href="bytes_8hpp.html#abbd0f2cd0f755bc4926b9c8eb7bfcbc3">More...</a><br /></td></tr>
<tr class="separator:abbd0f2cd0f755bc4926b9c8eb7bfcbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d130a713d9931620af352d45d85a1d"><td class="memItemLeft" align="right" valign="top">idaman asize_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a70d130a713d9931620af352d45d85a1d">chunk_size</a> (ea_t ea)</td></tr>
<tr class="memdesc:a70d130a713d9931620af352d45d85a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of the contiguous address block containing 'ea'.  <a href="bytes_8hpp.html#a70d130a713d9931620af352d45d85a1d">More...</a><br /></td></tr>
<tr class="separator:a70d130a713d9931620af352d45d85a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e96596f4ff633104dc88e05559526b"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad6e96596f4ff633104dc88e05559526b">find_free_chunk</a> (ea_t start, asize_t size, asize_t alignment)</td></tr>
<tr class="memdesc:ad6e96596f4ff633104dc88e05559526b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a hole in the addressing space of the program.  <a href="bytes_8hpp.html#ad6e96596f4ff633104dc88e05559526b">More...</a><br /></td></tr>
<tr class="separator:ad6e96596f4ff633104dc88e05559526b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbed8e273e00e37da0acaa1a39bebe4a"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#acbed8e273e00e37da0acaa1a39bebe4a">next_that</a> (ea_t ea, ea_t maxea, <a class="el" href="bytes_8hpp.html#ad5185f9d189b9af5cbf47bdbaa3888eb">testf_t</a> *testf, void *ud=nullptr)</td></tr>
<tr class="memdesc:acbed8e273e00e37da0acaa1a39bebe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find next address with a flag satisfying the function 'testf'.  <a href="bytes_8hpp.html#acbed8e273e00e37da0acaa1a39bebe4a">More...</a><br /></td></tr>
<tr class="separator:acbed8e273e00e37da0acaa1a39bebe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579bb032b20e7777b40975763c4dfd8e"><td class="memItemLeft" align="right" valign="top"><a id="a579bb032b20e7777b40975763c4dfd8e" name="a579bb032b20e7777b40975763c4dfd8e"></a>
ea_t idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>next_unknown</b> (ea_t ea, ea_t maxea)</td></tr>
<tr class="memdesc:a579bb032b20e7777b40975763c4dfd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="bytes_8hpp.html#acbed8e273e00e37da0acaa1a39bebe4a" title="Find next address with a flag satisfying the function &#39;testf&#39;.">next_that()</a>, but will find the next address that is unexplored. <br /></td></tr>
<tr class="separator:a579bb032b20e7777b40975763c4dfd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed0dfef3c1ad728e3aa06ea077ba982"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a4ed0dfef3c1ad728e3aa06ea077ba982">prev_that</a> (ea_t ea, ea_t minea, <a class="el" href="bytes_8hpp.html#ad5185f9d189b9af5cbf47bdbaa3888eb">testf_t</a> *testf, void *ud=nullptr)</td></tr>
<tr class="memdesc:a4ed0dfef3c1ad728e3aa06ea077ba982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find previous address with a flag satisfying the function 'testf'.  <a href="bytes_8hpp.html#a4ed0dfef3c1ad728e3aa06ea077ba982">More...</a><br /></td></tr>
<tr class="separator:a4ed0dfef3c1ad728e3aa06ea077ba982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bf55c03c21d1950b755e500576f3aa"><td class="memItemLeft" align="right" valign="top"><a id="a22bf55c03c21d1950b755e500576f3aa" name="a22bf55c03c21d1950b755e500576f3aa"></a>
ea_t idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>prev_unknown</b> (ea_t ea, ea_t minea)</td></tr>
<tr class="memdesc:a22bf55c03c21d1950b755e500576f3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="bytes_8hpp.html#a4ed0dfef3c1ad728e3aa06ea077ba982" title="Find previous address with a flag satisfying the function &#39;testf&#39;.">prev_that()</a>, but will find the previous address that is unexplored. <br /></td></tr>
<tr class="separator:a22bf55c03c21d1950b755e500576f3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043acfcdbffac18739612799b53d0171"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a043acfcdbffac18739612799b53d0171">prev_head</a> (ea_t ea, ea_t minea)</td></tr>
<tr class="memdesc:a043acfcdbffac18739612799b53d0171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get start of previous defined item.  <a href="bytes_8hpp.html#a043acfcdbffac18739612799b53d0171">More...</a><br /></td></tr>
<tr class="separator:a043acfcdbffac18739612799b53d0171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad518592ca7940ed8b019ed4d35661287"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad518592ca7940ed8b019ed4d35661287">next_head</a> (ea_t ea, ea_t maxea)</td></tr>
<tr class="memdesc:ad518592ca7940ed8b019ed4d35661287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get start of next defined item.  <a href="bytes_8hpp.html#ad518592ca7940ed8b019ed4d35661287">More...</a><br /></td></tr>
<tr class="separator:ad518592ca7940ed8b019ed4d35661287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7388e6b8b1ed7dc4bc377bb74dcf72"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a5e7388e6b8b1ed7dc4bc377bb74dcf72">prev_not_tail</a> (ea_t ea)</td></tr>
<tr class="memdesc:a5e7388e6b8b1ed7dc4bc377bb74dcf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of previous non-tail byte.  <a href="bytes_8hpp.html#a5e7388e6b8b1ed7dc4bc377bb74dcf72">More...</a><br /></td></tr>
<tr class="separator:a5e7388e6b8b1ed7dc4bc377bb74dcf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3da655e70ee8cf9f4d4bdfd5fda1af7"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ae3da655e70ee8cf9f4d4bdfd5fda1af7">next_not_tail</a> (ea_t ea)</td></tr>
<tr class="memdesc:ae3da655e70ee8cf9f4d4bdfd5fda1af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of next non-tail byte.  <a href="bytes_8hpp.html#ae3da655e70ee8cf9f4d4bdfd5fda1af7">More...</a><br /></td></tr>
<tr class="separator:ae3da655e70ee8cf9f4d4bdfd5fda1af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346f18163e4b8852a60b42dc399c6c11"><td class="memItemLeft" align="right" valign="top">ea_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a346f18163e4b8852a60b42dc399c6c11">adjust_visea</a> (ea_t ea)</td></tr>
<tr class="memdesc:a346f18163e4b8852a60b42dc399c6c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the address and get the nearest visible address.  <a href="bytes_8hpp.html#a346f18163e4b8852a60b42dc399c6c11">More...</a><br /></td></tr>
<tr class="separator:a346f18163e4b8852a60b42dc399c6c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d617220c6ce6bd182ec26a11d952a6"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a58d617220c6ce6bd182ec26a11d952a6">prev_visea</a> (ea_t ea)</td></tr>
<tr class="memdesc:a58d617220c6ce6bd182ec26a11d952a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get previous visible address.  <a href="bytes_8hpp.html#a58d617220c6ce6bd182ec26a11d952a6">More...</a><br /></td></tr>
<tr class="separator:a58d617220c6ce6bd182ec26a11d952a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cbe4f435300c277e90fb04208debe0"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa9cbe4f435300c277e90fb04208debe0">next_visea</a> (ea_t ea)</td></tr>
<tr class="memdesc:aa9cbe4f435300c277e90fb04208debe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next visible address.  <a href="bytes_8hpp.html#aa9cbe4f435300c277e90fb04208debe0">More...</a><br /></td></tr>
<tr class="separator:aa9cbe4f435300c277e90fb04208debe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac684f6c17e65bbe208810d1156cf0c81"><td class="memItemLeft" align="right" valign="top"><a id="ac684f6c17e65bbe208810d1156cf0c81" name="ac684f6c17e65bbe208810d1156cf0c81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_first_visea</b> (ea_t ea)</td></tr>
<tr class="memdesc:ac684f6c17e65bbe208810d1156cf0c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is an address the first visible address? <br /></td></tr>
<tr class="separator:ac684f6c17e65bbe208810d1156cf0c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af841bc06f50bd53a5d568b7d87cfcc89"><td class="memItemLeft" align="right" valign="top"><a id="af841bc06f50bd53a5d568b7d87cfcc89" name="af841bc06f50bd53a5d568b7d87cfcc89"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_last_visea</b> (ea_t ea)</td></tr>
<tr class="memdesc:af841bc06f50bd53a5d568b7d87cfcc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is an address the last visible address? <br /></td></tr>
<tr class="separator:af841bc06f50bd53a5d568b7d87cfcc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2083612b09134e707696a9a09a1eccc2"><td class="memItemLeft" align="right" valign="top"><a id="a2083612b09134e707696a9a09a1eccc2" name="a2083612b09134e707696a9a09a1eccc2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_visible_finally</b> (ea_t ea)</td></tr>
<tr class="memdesc:a2083612b09134e707696a9a09a1eccc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the address visible on the screen (not hidden)? <br /></td></tr>
<tr class="separator:a2083612b09134e707696a9a09a1eccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044e286f44e046227a1f3d9706dfd271"><td class="memItemLeft" align="right" valign="top">ea_t idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a044e286f44e046227a1f3d9706dfd271">get_item_head</a> (ea_t ea)</td></tr>
<tr class="memdesc:a044e286f44e046227a1f3d9706dfd271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start address of the item at 'ea'.  <a href="bytes_8hpp.html#a044e286f44e046227a1f3d9706dfd271">More...</a><br /></td></tr>
<tr class="separator:a044e286f44e046227a1f3d9706dfd271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac187ddfe69e383fd2398ad9a0545cd40"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ac187ddfe69e383fd2398ad9a0545cd40">get_item_end</a> (ea_t ea)</td></tr>
<tr class="memdesc:ac187ddfe69e383fd2398ad9a0545cd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end address of the item at 'ea'.  <a href="bytes_8hpp.html#ac187ddfe69e383fd2398ad9a0545cd40">More...</a><br /></td></tr>
<tr class="separator:ac187ddfe69e383fd2398ad9a0545cd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8309ae0c7eaca34bdd287da8efdabef"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ab8309ae0c7eaca34bdd287da8efdabef">calc_max_item_end</a> (ea_t ea, int how=15)</td></tr>
<tr class="memdesc:ab8309ae0c7eaca34bdd287da8efdabef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate maximal reasonable end address of a new item.  <a href="bytes_8hpp.html#ab8309ae0c7eaca34bdd287da8efdabef">More...</a><br /></td></tr>
<tr class="separator:ab8309ae0c7eaca34bdd287da8efdabef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34792242834806a65b5f3be1036bf516"><td class="memItemLeft" align="right" valign="top">asize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a34792242834806a65b5f3be1036bf516">get_item_size</a> (ea_t ea)</td></tr>
<tr class="memdesc:a34792242834806a65b5f3be1036bf516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of item (instruction/data) in bytes.  <a href="bytes_8hpp.html#a34792242834806a65b5f3be1036bf516">More...</a><br /></td></tr>
<tr class="separator:a34792242834806a65b5f3be1036bf516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0835c2b8ba7a457f13833194b122104b"><td class="memItemLeft" align="right" valign="top"><a id="a0835c2b8ba7a457f13833194b122104b" name="a0835c2b8ba7a457f13833194b122104b"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_mapped</b> (ea_t ea)</td></tr>
<tr class="memdesc:a0835c2b8ba7a457f13833194b122104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the specified address 'ea' present in the program? <br /></td></tr>
<tr class="separator:a0835c2b8ba7a457f13833194b122104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22e22cc77f4599c7a61db9924602491"><td class="memItemLeft" align="right" valign="top"><a id="ae22e22cc77f4599c7a61db9924602491" name="ae22e22cc77f4599c7a61db9924602491"></a>
idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_flags_ex</b> (ea_t ea, int how)</td></tr>
<tr class="memdesc:ae22e22cc77f4599c7a61db9924602491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flags for the specified address, extended form. <br /></td></tr>
<tr class="separator:ae22e22cc77f4599c7a61db9924602491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd753c28e511662d2dfc0c067aca6a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#abdd753c28e511662d2dfc0c067aca6a5">get_flags</a> (ea_t ea)</td></tr>
<tr class="memdesc:abdd753c28e511662d2dfc0c067aca6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get flags with <a class="el" href="bytes_8hpp.html#aee726806a07a06c9a7dcba795485e11c" title="Byte has value ?">FF_IVL</a> &amp; <a class="el" href="bytes_8hpp.html#ad190bb3962a654369210c8e14e23aa09" title="Mask for byte value.">MS_VAL</a>.  <a href="bytes_8hpp.html#abdd753c28e511662d2dfc0c067aca6a5">More...</a><br /></td></tr>
<tr class="separator:abdd753c28e511662d2dfc0c067aca6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf1a84e4214394dd94de375c532b576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a4bf1a84e4214394dd94de375c532b576">get_full_flags</a> (ea_t ea)</td></tr>
<tr class="memdesc:a4bf1a84e4214394dd94de375c532b576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flags value for address 'ea'.  <a href="bytes_8hpp.html#a4bf1a84e4214394dd94de375c532b576">More...</a><br /></td></tr>
<tr class="separator:a4bf1a84e4214394dd94de375c532b576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521642616ea4f0238d7602780d7c58ec"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a521642616ea4f0238d7602780d7c58ec">get_item_flag</a> (ea_t from, int n, ea_t ea, bool appzero)</td></tr>
<tr class="memdesc:a521642616ea4f0238d7602780d7c58ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flag of the item at 'ea' even if it is a tail byte of some array or structure.  <a href="bytes_8hpp.html#a521642616ea4f0238d7602780d7c58ec">More...</a><br /></td></tr>
<tr class="separator:a521642616ea4f0238d7602780d7c58ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412b10a79f596eb2e18c6c42e9ed5fed"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a412b10a79f596eb2e18c6c42e9ed5fed">get_item_refinfo</a> (<a class="el" href="structrefinfo__t.html">refinfo_t</a> *ri, ea_t ea, int n)</td></tr>
<tr class="memdesc:a412b10a79f596eb2e18c6c42e9ed5fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get refinfo of the item at 'ea'.  <a href="bytes_8hpp.html#a412b10a79f596eb2e18c6c42e9ed5fed">More...</a><br /></td></tr>
<tr class="separator:a412b10a79f596eb2e18c6c42e9ed5fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb772ecf9be1bddbe62dc4c0f957cec"><td class="memItemLeft" align="right" valign="top"><a id="aeeb772ecf9be1bddbe62dc4c0f957cec" name="aeeb772ecf9be1bddbe62dc4c0f957cec"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_value</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:aeeb772ecf9be1bddbe62dc4c0f957cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do flags contain byte value? <br /></td></tr>
<tr class="separator:aeeb772ecf9be1bddbe62dc4c0f957cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d9631e3d05e66cdcf761c56127bbb0"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad8d9631e3d05e66cdcf761c56127bbb0">del_value</a> (ea_t ea)</td></tr>
<tr class="memdesc:ad8d9631e3d05e66cdcf761c56127bbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete byte value from flags.  <a href="bytes_8hpp.html#ad8d9631e3d05e66cdcf761c56127bbb0">More...</a><br /></td></tr>
<tr class="separator:ad8d9631e3d05e66cdcf761c56127bbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d71a49a507bdc3edd296abff0dc53b"><td class="memItemLeft" align="right" valign="top"><a id="ad9d71a49a507bdc3edd296abff0dc53b" name="ad9d71a49a507bdc3edd296abff0dc53b"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_loaded</b> (ea_t ea)</td></tr>
<tr class="memdesc:ad9d71a49a507bdc3edd296abff0dc53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the specified address have a byte value (is initialized?) <br /></td></tr>
<tr class="separator:ad9d71a49a507bdc3edd296abff0dc53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc205e32314437fc526186f33867bdf2"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#acc205e32314437fc526186f33867bdf2">nbits</a> (ea_t ea)</td></tr>
<tr class="memdesc:acc205e32314437fc526186f33867bdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bits in a byte at the given address.  <a href="bytes_8hpp.html#acc205e32314437fc526186f33867bdf2">More...</a><br /></td></tr>
<tr class="separator:acc205e32314437fc526186f33867bdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0858fbd5811a483a01c76c8c777c7967"><td class="memItemLeft" align="right" valign="top"><a id="a0858fbd5811a483a01c76c8c777c7967" name="a0858fbd5811a483a01c76c8c777c7967"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>bytesize</b> (ea_t ea)</td></tr>
<tr class="memdesc:a0858fbd5811a483a01c76c8c777c7967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of bytes required to store a byte at the given address. <br /></td></tr>
<tr class="separator:a0858fbd5811a483a01c76c8c777c7967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06299d4eec6753242edc18605abc33e4"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a06299d4eec6753242edc18605abc33e4">get_byte</a> (ea_t ea)</td></tr>
<tr class="memdesc:a06299d4eec6753242edc18605abc33e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one byte (8-bit) of the program at 'ea'.  <a href="bytes_8hpp.html#a06299d4eec6753242edc18605abc33e4">More...</a><br /></td></tr>
<tr class="separator:a06299d4eec6753242edc18605abc33e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3087f886cfc0dfb455ee306a56134fd9"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a3087f886cfc0dfb455ee306a56134fd9">get_db_byte</a> (ea_t ea)</td></tr>
<tr class="memdesc:a3087f886cfc0dfb455ee306a56134fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one byte (8-bit) of the program at 'ea' from the database.  <a href="bytes_8hpp.html#a3087f886cfc0dfb455ee306a56134fd9">More...</a><br /></td></tr>
<tr class="separator:a3087f886cfc0dfb455ee306a56134fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd70a4257a8fea2c4efc4d9d54e1684"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a1fd70a4257a8fea2c4efc4d9d54e1684">get_word</a> (ea_t ea)</td></tr>
<tr class="memdesc:a1fd70a4257a8fea2c4efc4d9d54e1684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one word (16-bit) of the program at 'ea'.  <a href="bytes_8hpp.html#a1fd70a4257a8fea2c4efc4d9d54e1684">More...</a><br /></td></tr>
<tr class="separator:a1fd70a4257a8fea2c4efc4d9d54e1684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf321ff9471e7096e0664f5eb2691ddb"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#acf321ff9471e7096e0664f5eb2691ddb">get_dword</a> (ea_t ea)</td></tr>
<tr class="memdesc:acf321ff9471e7096e0664f5eb2691ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one dword (32-bit) of the program at 'ea'.  <a href="bytes_8hpp.html#acf321ff9471e7096e0664f5eb2691ddb">More...</a><br /></td></tr>
<tr class="separator:acf321ff9471e7096e0664f5eb2691ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f04d044e6ad886568d17ef2d0cac11"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a96f04d044e6ad886568d17ef2d0cac11">get_qword</a> (ea_t ea)</td></tr>
<tr class="memdesc:a96f04d044e6ad886568d17ef2d0cac11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one qword (64-bit) of the program at 'ea'.  <a href="bytes_8hpp.html#a96f04d044e6ad886568d17ef2d0cac11">More...</a><br /></td></tr>
<tr class="separator:a96f04d044e6ad886568d17ef2d0cac11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40de3d071cd123794b60f9cb9bb6c1f"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad40de3d071cd123794b60f9cb9bb6c1f">get_wide_byte</a> (ea_t ea)</td></tr>
<tr class="memdesc:ad40de3d071cd123794b60f9cb9bb6c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one wide byte of the program at 'ea'.  <a href="bytes_8hpp.html#ad40de3d071cd123794b60f9cb9bb6c1f">More...</a><br /></td></tr>
<tr class="separator:ad40de3d071cd123794b60f9cb9bb6c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf36b6506cc50142a0f3501223e5e1b"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#afdf36b6506cc50142a0f3501223e5e1b">get_wide_word</a> (ea_t ea)</td></tr>
<tr class="memdesc:afdf36b6506cc50142a0f3501223e5e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one wide word (2 'byte') of the program at 'ea'.  <a href="bytes_8hpp.html#afdf36b6506cc50142a0f3501223e5e1b">More...</a><br /></td></tr>
<tr class="separator:afdf36b6506cc50142a0f3501223e5e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef2fe75eeacd4443379e4569bc7ec09"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a8ef2fe75eeacd4443379e4569bc7ec09">get_wide_dword</a> (ea_t ea)</td></tr>
<tr class="memdesc:a8ef2fe75eeacd4443379e4569bc7ec09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get two wide words (4 'bytes') of the program at 'ea'.  <a href="bytes_8hpp.html#a8ef2fe75eeacd4443379e4569bc7ec09">More...</a><br /></td></tr>
<tr class="separator:a8ef2fe75eeacd4443379e4569bc7ec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e55e9afd4062dcdb5035945e8be7b5"><td class="memItemLeft" align="right" valign="top"><a id="ac1e55e9afd4062dcdb5035945e8be7b5" name="ac1e55e9afd4062dcdb5035945e8be7b5"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_octet2</b> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *out, <a class="el" href="structoctet__generator__t.html">octet_generator_t</a> *ogen)</td></tr>
<tr class="separator:ac1e55e9afd4062dcdb5035945e8be7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a52c1d3f9a1e4c08f8deabe40e4a1b"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a04a52c1d3f9a1e4c08f8deabe40e4a1b">get_16bit</a> (ea_t ea)</td></tr>
<tr class="memdesc:a04a52c1d3f9a1e4c08f8deabe40e4a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get 16bits of the program at 'ea'.  <a href="bytes_8hpp.html#a04a52c1d3f9a1e4c08f8deabe40e4a1b">More...</a><br /></td></tr>
<tr class="separator:a04a52c1d3f9a1e4c08f8deabe40e4a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f8cb0a2a422519ffd6f0e3f74c9fcf"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a07f8cb0a2a422519ffd6f0e3f74c9fcf">get_32bit</a> (ea_t ea)</td></tr>
<tr class="memdesc:a07f8cb0a2a422519ffd6f0e3f74c9fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get not more than 32bits of the program at 'ea'.  <a href="bytes_8hpp.html#a07f8cb0a2a422519ffd6f0e3f74c9fcf">More...</a><br /></td></tr>
<tr class="separator:a07f8cb0a2a422519ffd6f0e3f74c9fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1213a5c7408571d91eb6f21d51dc8363"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a1213a5c7408571d91eb6f21d51dc8363">get_64bit</a> (ea_t ea)</td></tr>
<tr class="memdesc:a1213a5c7408571d91eb6f21d51dc8363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get not more than 64bits of the program at 'ea'.  <a href="bytes_8hpp.html#a1213a5c7408571d91eb6f21d51dc8363">More...</a><br /></td></tr>
<tr class="separator:a1213a5c7408571d91eb6f21d51dc8363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9386fa3dd9ca94b46897a3617e244ce0"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a9386fa3dd9ca94b46897a3617e244ce0">get_data_value</a> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *v, ea_t ea, asize_t size)</td></tr>
<tr class="memdesc:a9386fa3dd9ca94b46897a3617e244ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value at of the item at 'ea'.  <a href="bytes_8hpp.html#a9386fa3dd9ca94b46897a3617e244ce0">More...</a><br /></td></tr>
<tr class="separator:a9386fa3dd9ca94b46897a3617e244ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83781763f1aab3612e16fa65a02e15e"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ae83781763f1aab3612e16fa65a02e15e">visit_patched_bytes</a> (ea_t ea1, ea_t ea2, int(idaapi *cb)(ea_t ea, <a class="el" href="pro_8h.html#a42ae75d34f73b9e691bd16aaddb897e5">qoff64_t</a> fpos, uint64 o, uint64 v, void *ud), void *ud=nullptr)</td></tr>
<tr class="memdesc:ae83781763f1aab3612e16fa65a02e15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all the patched bytes one byte at a time.  <a href="bytes_8hpp.html#ae83781763f1aab3612e16fa65a02e15e">More...</a><br /></td></tr>
<tr class="separator:ae83781763f1aab3612e16fa65a02e15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8775c2f57cb46b8b4db51ea1c711f5c1"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a8775c2f57cb46b8b4db51ea1c711f5c1">get_original_byte</a> (ea_t ea)</td></tr>
<tr class="memdesc:a8775c2f57cb46b8b4db51ea1c711f5c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get original byte value (that was before patching).  <a href="bytes_8hpp.html#a8775c2f57cb46b8b4db51ea1c711f5c1">More...</a><br /></td></tr>
<tr class="separator:a8775c2f57cb46b8b4db51ea1c711f5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff867ae9455f3513557f9478e25ebe0d"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aff867ae9455f3513557f9478e25ebe0d">get_original_word</a> (ea_t ea)</td></tr>
<tr class="memdesc:aff867ae9455f3513557f9478e25ebe0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get original word value (that was before patching).  <a href="bytes_8hpp.html#aff867ae9455f3513557f9478e25ebe0d">More...</a><br /></td></tr>
<tr class="separator:aff867ae9455f3513557f9478e25ebe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf127c9ef3a53ae35227fa4f6ef9614e"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#adf127c9ef3a53ae35227fa4f6ef9614e">get_original_dword</a> (ea_t ea)</td></tr>
<tr class="memdesc:adf127c9ef3a53ae35227fa4f6ef9614e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get original dword (that was before patching) This function works for wide byte processors too.  <a href="bytes_8hpp.html#adf127c9ef3a53ae35227fa4f6ef9614e">More...</a><br /></td></tr>
<tr class="separator:adf127c9ef3a53ae35227fa4f6ef9614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c744b5bb83b9c33b081c8526194a33f"><td class="memItemLeft" align="right" valign="top">idaman uint64 ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a6c744b5bb83b9c33b081c8526194a33f">get_original_qword</a> (ea_t ea)</td></tr>
<tr class="memdesc:a6c744b5bb83b9c33b081c8526194a33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get original qword value (that was before patching) This function DOESN'T work for wide byte processors too.  <a href="bytes_8hpp.html#a6c744b5bb83b9c33b081c8526194a33f">More...</a><br /></td></tr>
<tr class="separator:a6c744b5bb83b9c33b081c8526194a33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58bf511be9b66ff3cb6210bd46b728e"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa58bf511be9b66ff3cb6210bd46b728e">put_byte</a> (ea_t ea, uint64 x)</td></tr>
<tr class="memdesc:aa58bf511be9b66ff3cb6210bd46b728e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of one byte of the program.  <a href="bytes_8hpp.html#aa58bf511be9b66ff3cb6210bd46b728e">More...</a><br /></td></tr>
<tr class="separator:aa58bf511be9b66ff3cb6210bd46b728e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305f6bc74464314cd5c71ecc6e313d7e"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a305f6bc74464314cd5c71ecc6e313d7e">put_word</a> (ea_t ea, uint64 x)</td></tr>
<tr class="memdesc:a305f6bc74464314cd5c71ecc6e313d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of one word of the program.  <a href="bytes_8hpp.html#a305f6bc74464314cd5c71ecc6e313d7e">More...</a><br /></td></tr>
<tr class="separator:a305f6bc74464314cd5c71ecc6e313d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e943eefd745ed67ed1bd496b069b3c"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa3e943eefd745ed67ed1bd496b069b3c">put_dword</a> (ea_t ea, uint64 x)</td></tr>
<tr class="memdesc:aa3e943eefd745ed67ed1bd496b069b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of one dword of the program.  <a href="bytes_8hpp.html#aa3e943eefd745ed67ed1bd496b069b3c">More...</a><br /></td></tr>
<tr class="separator:aa3e943eefd745ed67ed1bd496b069b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189e23a271fbef7e207f2925c4d36d4f"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a189e23a271fbef7e207f2925c4d36d4f">put_qword</a> (ea_t ea, uint64 x)</td></tr>
<tr class="memdesc:a189e23a271fbef7e207f2925c4d36d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value of one qword (8 bytes) of the program.  <a href="bytes_8hpp.html#a189e23a271fbef7e207f2925c4d36d4f">More...</a><br /></td></tr>
<tr class="separator:a189e23a271fbef7e207f2925c4d36d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b7cfe135b9d484a7461e90b8fd2f90"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a50b7cfe135b9d484a7461e90b8fd2f90">patch_byte</a> (ea_t ea, uint64 x)</td></tr>
<tr class="memdesc:a50b7cfe135b9d484a7461e90b8fd2f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch a byte of the program.  <a href="bytes_8hpp.html#a50b7cfe135b9d484a7461e90b8fd2f90">More...</a><br /></td></tr>
<tr class="separator:a50b7cfe135b9d484a7461e90b8fd2f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c639943ff3928ba71152b842db7c28f"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a6c639943ff3928ba71152b842db7c28f">patch_word</a> (ea_t ea, uint64 x)</td></tr>
<tr class="memdesc:a6c639943ff3928ba71152b842db7c28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch a word of the program.  <a href="bytes_8hpp.html#a6c639943ff3928ba71152b842db7c28f">More...</a><br /></td></tr>
<tr class="separator:a6c639943ff3928ba71152b842db7c28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4957f5a2ba97db1cb73d8d234c67f624"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a4957f5a2ba97db1cb73d8d234c67f624">patch_dword</a> (ea_t ea, uint64 x)</td></tr>
<tr class="memdesc:a4957f5a2ba97db1cb73d8d234c67f624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch a dword of the program.  <a href="bytes_8hpp.html#a4957f5a2ba97db1cb73d8d234c67f624">More...</a><br /></td></tr>
<tr class="separator:a4957f5a2ba97db1cb73d8d234c67f624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152740498421568caab14010f25623ee"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a152740498421568caab14010f25623ee">patch_qword</a> (ea_t ea, uint64 x)</td></tr>
<tr class="memdesc:a152740498421568caab14010f25623ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch a qword of the program.  <a href="bytes_8hpp.html#a152740498421568caab14010f25623ee">More...</a><br /></td></tr>
<tr class="separator:a152740498421568caab14010f25623ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4ba1861324425115b5b589f0daac96"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aeb4ba1861324425115b5b589f0daac96">revert_byte</a> (ea_t ea)</td></tr>
<tr class="memdesc:aeb4ba1861324425115b5b589f0daac96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revert patched byte.  <a href="bytes_8hpp.html#aeb4ba1861324425115b5b589f0daac96">More...</a><br /></td></tr>
<tr class="separator:aeb4ba1861324425115b5b589f0daac96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac758a752fcfa6c60bb29a979fa883ed3"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ac758a752fcfa6c60bb29a979fa883ed3">add_byte</a> (ea_t ea, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> value)</td></tr>
<tr class="memdesc:ac758a752fcfa6c60bb29a979fa883ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a value to one byte of the program.  <a href="bytes_8hpp.html#ac758a752fcfa6c60bb29a979fa883ed3">More...</a><br /></td></tr>
<tr class="separator:ac758a752fcfa6c60bb29a979fa883ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd8330410af1e2d7ef9d583ce90360b"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a9fd8330410af1e2d7ef9d583ce90360b">add_word</a> (ea_t ea, uint64 value)</td></tr>
<tr class="memdesc:a9fd8330410af1e2d7ef9d583ce90360b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a value to one word of the program.  <a href="bytes_8hpp.html#a9fd8330410af1e2d7ef9d583ce90360b">More...</a><br /></td></tr>
<tr class="separator:a9fd8330410af1e2d7ef9d583ce90360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1458b218c7aa19ba9c8bf19e7c03b4bb"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a1458b218c7aa19ba9c8bf19e7c03b4bb">add_dword</a> (ea_t ea, uint64 value)</td></tr>
<tr class="memdesc:a1458b218c7aa19ba9c8bf19e7c03b4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a value to one dword of the program.  <a href="bytes_8hpp.html#a1458b218c7aa19ba9c8bf19e7c03b4bb">More...</a><br /></td></tr>
<tr class="separator:a1458b218c7aa19ba9c8bf19e7c03b4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b93a89622f2303c2fdd2f3e80213c34"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a9b93a89622f2303c2fdd2f3e80213c34">add_qword</a> (ea_t ea, uint64 value)</td></tr>
<tr class="memdesc:a9b93a89622f2303c2fdd2f3e80213c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a value to one qword of the program.  <a href="bytes_8hpp.html#a9b93a89622f2303c2fdd2f3e80213c34">More...</a><br /></td></tr>
<tr class="separator:a9b93a89622f2303c2fdd2f3e80213c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac283b1622ebfcbdda1f02da7451d1fac"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ac283b1622ebfcbdda1f02da7451d1fac">get_zero_ranges</a> (<a class="el" href="classrangeset__t.html">rangeset_t</a> *zranges, const <a class="el" href="structrange__t.html">range_t</a> *range)</td></tr>
<tr class="memdesc:ac283b1622ebfcbdda1f02da7451d1fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return set of ranges with zero initialized bytes.  <a href="bytes_8hpp.html#ac283b1622ebfcbdda1f02da7451d1fac">More...</a><br /></td></tr>
<tr class="separator:ac283b1622ebfcbdda1f02da7451d1fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287b095087ec2a98a90c66472b779a0d"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a287b095087ec2a98a90c66472b779a0d">get_bytes</a> (void *buf, <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> size, ea_t ea, int gmb_flags=0, void *mask=nullptr)</td></tr>
<tr class="memdesc:a287b095087ec2a98a90c66472b779a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified number of bytes of the program into the buffer.  <a href="bytes_8hpp.html#a287b095087ec2a98a90c66472b779a0d">More...</a><br /></td></tr>
<tr class="separator:a287b095087ec2a98a90c66472b779a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ca5e83ff1f167ef3c0aa6737a03c18"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa1ca5e83ff1f167ef3c0aa6737a03c18">put_bytes</a> (ea_t ea, const void *buf, size_t size)</td></tr>
<tr class="memdesc:aa1ca5e83ff1f167ef3c0aa6737a03c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the specified number of bytes of the program.  <a href="bytes_8hpp.html#aa1ca5e83ff1f167ef3c0aa6737a03c18">More...</a><br /></td></tr>
<tr class="separator:aa1ca5e83ff1f167ef3c0aa6737a03c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351950abd6c5309a1464bbbfc793f8e0"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a351950abd6c5309a1464bbbfc793f8e0">patch_bytes</a> (ea_t ea, const void *buf, size_t size)</td></tr>
<tr class="memdesc:a351950abd6c5309a1464bbbfc793f8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch the specified number of bytes of the program.  <a href="bytes_8hpp.html#a351950abd6c5309a1464bbbfc793f8e0">More...</a><br /></td></tr>
<tr class="separator:a351950abd6c5309a1464bbbfc793f8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03e9f7523417bd008d959ff31200aca"><td class="memItemLeft" align="right" valign="top"><a id="ad03e9f7523417bd008d959ff31200aca" name="ad03e9f7523417bd008d959ff31200aca"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_code</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:ad03e9f7523417bd008d959ff31200aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote start of an instruction? <br /></td></tr>
<tr class="separator:ad03e9f7523417bd008d959ff31200aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74466afc67d006638ae9191fa284329a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a74466afc67d006638ae9191fa284329a">f_is_code</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a74466afc67d006638ae9191fa284329a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote start of an instruction?  <a href="bytes_8hpp.html#a74466afc67d006638ae9191fa284329a">More...</a><br /></td></tr>
<tr class="separator:a74466afc67d006638ae9191fa284329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fe26c9ce26a68bbf11c4fc29cdce15"><td class="memItemLeft" align="right" valign="top"><a id="a26fe26c9ce26a68bbf11c4fc29cdce15" name="a26fe26c9ce26a68bbf11c4fc29cdce15"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_data</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a26fe26c9ce26a68bbf11c4fc29cdce15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote start of data? <br /></td></tr>
<tr class="separator:a26fe26c9ce26a68bbf11c4fc29cdce15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b84edd77d2e71c447de32b8fb0023be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a2b84edd77d2e71c447de32b8fb0023be">f_is_data</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a2b84edd77d2e71c447de32b8fb0023be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote start of data?  <a href="bytes_8hpp.html#a2b84edd77d2e71c447de32b8fb0023be">More...</a><br /></td></tr>
<tr class="separator:a2b84edd77d2e71c447de32b8fb0023be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b50d7414beff1932b552865b365722e"><td class="memItemLeft" align="right" valign="top"><a id="a3b50d7414beff1932b552865b365722e" name="a3b50d7414beff1932b552865b365722e"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_tail</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a3b50d7414beff1932b552865b365722e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote tail byte? <br /></td></tr>
<tr class="separator:a3b50d7414beff1932b552865b365722e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877e4fa95d7b97d06017f715a97e4285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a877e4fa95d7b97d06017f715a97e4285">f_is_tail</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a877e4fa95d7b97d06017f715a97e4285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote tail byte?  <a href="bytes_8hpp.html#a877e4fa95d7b97d06017f715a97e4285">More...</a><br /></td></tr>
<tr class="separator:a877e4fa95d7b97d06017f715a97e4285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9897a28b84c9ca1f17e98c24b54395a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a9897a28b84c9ca1f17e98c24b54395a2">is_not_tail</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a9897a28b84c9ca1f17e98c24b54395a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote tail byte?  <a href="bytes_8hpp.html#a9897a28b84c9ca1f17e98c24b54395a2">More...</a><br /></td></tr>
<tr class="separator:a9897a28b84c9ca1f17e98c24b54395a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f474c83aceb757371c8dbee8ff80f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa6f474c83aceb757371c8dbee8ff80f9">f_is_not_tail</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:aa6f474c83aceb757371c8dbee8ff80f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote tail byte?  <a href="bytes_8hpp.html#aa6f474c83aceb757371c8dbee8ff80f9">More...</a><br /></td></tr>
<tr class="separator:aa6f474c83aceb757371c8dbee8ff80f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1574e15547e558eb739088e5f3f3ce6"><td class="memItemLeft" align="right" valign="top"><a id="aa1574e15547e558eb739088e5f3f3ce6" name="aa1574e15547e558eb739088e5f3f3ce6"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_unknown</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:aa1574e15547e558eb739088e5f3f3ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote unexplored byte? <br /></td></tr>
<tr class="separator:aa1574e15547e558eb739088e5f3f3ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af787fb5ec9d60f317e85567ab52f1b3b"><td class="memItemLeft" align="right" valign="top"><a id="af787fb5ec9d60f317e85567ab52f1b3b" name="af787fb5ec9d60f317e85567ab52f1b3b"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_head</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:af787fb5ec9d60f317e85567ab52f1b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote start of instruction OR data? <br /></td></tr>
<tr class="separator:af787fb5ec9d60f317e85567ab52f1b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440c2c80ffda8a46c58005de4f15163f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a440c2c80ffda8a46c58005de4f15163f">f_is_head</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a440c2c80ffda8a46c58005de4f15163f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does flag denote start of instruction OR data?  <a href="bytes_8hpp.html#a440c2c80ffda8a46c58005de4f15163f">More...</a><br /></td></tr>
<tr class="separator:a440c2c80ffda8a46c58005de4f15163f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8678caab70bfedb5e1bd46436fec0aec"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a8678caab70bfedb5e1bd46436fec0aec">del_items</a> (ea_t ea, int flags=0, asize_t nbytes=1, <a class="el" href="bytes_8hpp.html#ad2808f4f5c5def4fb4738e218ae4af52">may_destroy_cb_t</a> *may_destroy=nullptr)</td></tr>
<tr class="memdesc:a8678caab70bfedb5e1bd46436fec0aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert item (instruction/data) to unexplored bytes.  <a href="bytes_8hpp.html#a8678caab70bfedb5e1bd46436fec0aec">More...</a><br /></td></tr>
<tr class="separator:a8678caab70bfedb5e1bd46436fec0aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94adb77aabb78f9944ff29a1eb38e544"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a94adb77aabb78f9944ff29a1eb38e544">is_manual_insn</a> (ea_t ea)</td></tr>
<tr class="memdesc:a94adb77aabb78f9944ff29a1eb38e544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the instruction overridden?  <a href="bytes_8hpp.html#a94adb77aabb78f9944ff29a1eb38e544">More...</a><br /></td></tr>
<tr class="separator:a94adb77aabb78f9944ff29a1eb38e544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbcd2b16bf5b747fe15eacc08049070"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a2cbcd2b16bf5b747fe15eacc08049070">get_manual_insn</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, ea_t ea)</td></tr>
<tr class="memdesc:a2cbcd2b16bf5b747fe15eacc08049070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the user-specified string for the manual instruction.  <a href="bytes_8hpp.html#a2cbcd2b16bf5b747fe15eacc08049070">More...</a><br /></td></tr>
<tr class="separator:a2cbcd2b16bf5b747fe15eacc08049070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7477b2cc88c2cb6628681e2df057993"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad7477b2cc88c2cb6628681e2df057993">set_manual_insn</a> (ea_t ea, const char *manual_insn)</td></tr>
<tr class="memdesc:ad7477b2cc88c2cb6628681e2df057993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set manual instruction string.  <a href="bytes_8hpp.html#ad7477b2cc88c2cb6628681e2df057993">More...</a><br /></td></tr>
<tr class="separator:ad7477b2cc88c2cb6628681e2df057993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb3ebd4251afc33d496c5cfa770e51b"><td class="memItemLeft" align="right" valign="top"><a id="aeeb3ebd4251afc33d496c5cfa770e51b" name="aeeb3ebd4251afc33d496c5cfa770e51b"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_flow</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:aeeb3ebd4251afc33d496c5cfa770e51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the previous instruction exist and pass execution flow to the current byte? <br /></td></tr>
<tr class="separator:aeeb3ebd4251afc33d496c5cfa770e51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87abef8ed90bc341f143a16ce1e34bdf"><td class="memItemLeft" align="right" valign="top"><a id="a87abef8ed90bc341f143a16ce1e34bdf" name="a87abef8ed90bc341f143a16ce1e34bdf"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_extra_cmts</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a87abef8ed90bc341f143a16ce1e34bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have additional anterior or posterior lines? <br /></td></tr>
<tr class="separator:a87abef8ed90bc341f143a16ce1e34bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddcd4c8a009de053dedfe5c66513efa"><td class="memItemLeft" align="right" valign="top"><a id="a1ddcd4c8a009de053dedfe5c66513efa" name="a1ddcd4c8a009de053dedfe5c66513efa"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_has_extra_cmts</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> f, void *)</td></tr>
<tr class="separator:a1ddcd4c8a009de053dedfe5c66513efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3cdb839ae4686976cd5be362f342e2"><td class="memItemLeft" align="right" valign="top"><a id="aab3cdb839ae4686976cd5be362f342e2" name="aab3cdb839ae4686976cd5be362f342e2"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_cmt</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:aab3cdb839ae4686976cd5be362f342e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have an indented comment? <br /></td></tr>
<tr class="separator:aab3cdb839ae4686976cd5be362f342e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183a32e031f152f1f235dd23b732066d"><td class="memItemLeft" align="right" valign="top"><a id="a183a32e031f152f1f235dd23b732066d" name="a183a32e031f152f1f235dd23b732066d"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_has_cmt</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> f, void *)</td></tr>
<tr class="separator:a183a32e031f152f1f235dd23b732066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b34993b743cc90451ce8fbc7222fb9"><td class="memItemLeft" align="right" valign="top"><a id="a43b34993b743cc90451ce8fbc7222fb9" name="a43b34993b743cc90451ce8fbc7222fb9"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_xref</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a43b34993b743cc90451ce8fbc7222fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have cross-references to it? <br /></td></tr>
<tr class="separator:a43b34993b743cc90451ce8fbc7222fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e97254e6ecab6513ac1c023cf6cdca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a4e97254e6ecab6513ac1c023cf6cdca9">f_has_xref</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> f, void *)</td></tr>
<tr class="memdesc:a4e97254e6ecab6513ac1c023cf6cdca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have cross-references to it?  <a href="bytes_8hpp.html#a4e97254e6ecab6513ac1c023cf6cdca9">More...</a><br /></td></tr>
<tr class="separator:a4e97254e6ecab6513ac1c023cf6cdca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81497ee34a88b2ab0c3d386de2217e09"><td class="memItemLeft" align="right" valign="top"><a id="a81497ee34a88b2ab0c3d386de2217e09" name="a81497ee34a88b2ab0c3d386de2217e09"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_name</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a81497ee34a88b2ab0c3d386de2217e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have non-trivial (non-dummy) name? <br /></td></tr>
<tr class="separator:a81497ee34a88b2ab0c3d386de2217e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d1672102a9aa8ba9e050e5bb2af8cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad6d1672102a9aa8ba9e050e5bb2af8cc">f_has_name</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> f, void *)</td></tr>
<tr class="memdesc:ad6d1672102a9aa8ba9e050e5bb2af8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have non-trivial (non-dummy) name?  <a href="bytes_8hpp.html#ad6d1672102a9aa8ba9e050e5bb2af8cc">More...</a><br /></td></tr>
<tr class="separator:ad6d1672102a9aa8ba9e050e5bb2af8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d89bd2d76a53a688eee3e9f556cf82d"><td class="memItemLeft" align="right" valign="top"><a id="a2d89bd2d76a53a688eee3e9f556cf82d" name="a2d89bd2d76a53a688eee3e9f556cf82d"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_dummy_name</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a2d89bd2d76a53a688eee3e9f556cf82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have dummy (auto-generated, with special prefix) name? <br /></td></tr>
<tr class="separator:a2d89bd2d76a53a688eee3e9f556cf82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574315600e9d76f8fe8865cfe4794529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a574315600e9d76f8fe8865cfe4794529">f_has_dummy_name</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> f, void *)</td></tr>
<tr class="memdesc:a574315600e9d76f8fe8865cfe4794529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have dummy (auto-generated, with special prefix) name?  <a href="bytes_8hpp.html#a574315600e9d76f8fe8865cfe4794529">More...</a><br /></td></tr>
<tr class="separator:a574315600e9d76f8fe8865cfe4794529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69dcba9650af2bace104f83083e23e1"><td class="memItemLeft" align="right" valign="top"><a id="ad69dcba9650af2bace104f83083e23e1" name="ad69dcba9650af2bace104f83083e23e1"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_auto_name</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:ad69dcba9650af2bace104f83083e23e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have auto-generated (no special prefix) name? <br /></td></tr>
<tr class="separator:ad69dcba9650af2bace104f83083e23e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294f88737fce2962b0089ee3b3f1c13b"><td class="memItemLeft" align="right" valign="top"><a id="a294f88737fce2962b0089ee3b3f1c13b" name="a294f88737fce2962b0089ee3b3f1c13b"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_any_name</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a294f88737fce2962b0089ee3b3f1c13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have any name? <br /></td></tr>
<tr class="separator:a294f88737fce2962b0089ee3b3f1c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdf4af28c50c8aa1a370809d30d1753"><td class="memItemLeft" align="right" valign="top"><a id="aabdf4af28c50c8aa1a370809d30d1753" name="aabdf4af28c50c8aa1a370809d30d1753"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_user_name</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:aabdf4af28c50c8aa1a370809d30d1753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have user-specified name? <br /></td></tr>
<tr class="separator:aabdf4af28c50c8aa1a370809d30d1753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc970a54e3cfdd9fbe9c8912e80b2d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#acc970a54e3cfdd9fbe9c8912e80b2d94">f_has_user_name</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:acc970a54e3cfdd9fbe9c8912e80b2d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the current byte have user-specified name?  <a href="bytes_8hpp.html#acc970a54e3cfdd9fbe9c8912e80b2d94">More...</a><br /></td></tr>
<tr class="separator:acc970a54e3cfdd9fbe9c8912e80b2d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeda3aee7159d2b18d452427d6d7983"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aadeda3aee7159d2b18d452427d6d7983">is_invsign</a> (ea_t ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:aadeda3aee7159d2b18d452427d6d7983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should sign of n-th operand inverted during output?.  <a href="bytes_8hpp.html#aadeda3aee7159d2b18d452427d6d7983">More...</a><br /></td></tr>
<tr class="separator:aadeda3aee7159d2b18d452427d6d7983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a502d23bb9f0b468fd029eb3198f4f"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad5a502d23bb9f0b468fd029eb3198f4f">toggle_sign</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:ad5a502d23bb9f0b468fd029eb3198f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle sign of n-th operand.  <a href="bytes_8hpp.html#ad5a502d23bb9f0b468fd029eb3198f4f">More...</a><br /></td></tr>
<tr class="separator:ad5a502d23bb9f0b468fd029eb3198f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031a58c79b794a26cb7c2c3927bde634"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a031a58c79b794a26cb7c2c3927bde634">is_bnot</a> (ea_t ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a031a58c79b794a26cb7c2c3927bde634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should we negate the operand?.  <a href="bytes_8hpp.html#a031a58c79b794a26cb7c2c3927bde634">More...</a><br /></td></tr>
<tr class="separator:a031a58c79b794a26cb7c2c3927bde634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318a24ff8222478f7f3a7a74867b1719"><td class="memItemLeft" align="right" valign="top"><a id="a318a24ff8222478f7f3a7a74867b1719" name="a318a24ff8222478f7f3a7a74867b1719"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>toggle_bnot</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a318a24ff8222478f7f3a7a74867b1719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle binary negation of operand. also see <a class="el" href="bytes_8hpp.html#a031a58c79b794a26cb7c2c3927bde634" title="Should we negate the operand?.">is_bnot()</a> <br /></td></tr>
<tr class="separator:a318a24ff8222478f7f3a7a74867b1719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139412c7891bce63f6a60a9005c28384"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a139412c7891bce63f6a60a9005c28384">is_lzero</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a139412c7891bce63f6a60a9005c28384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display leading zeroes? Display leading zeroes in operands.  <a href="bytes_8hpp.html#a139412c7891bce63f6a60a9005c28384">More...</a><br /></td></tr>
<tr class="separator:a139412c7891bce63f6a60a9005c28384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96993e94d7866bef258bdb6c0ae91e06"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a96993e94d7866bef258bdb6c0ae91e06">set_lzero</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a96993e94d7866bef258bdb6c0ae91e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set toggle lzero bit.  <a href="bytes_8hpp.html#a96993e94d7866bef258bdb6c0ae91e06">More...</a><br /></td></tr>
<tr class="separator:a96993e94d7866bef258bdb6c0ae91e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09986a5cdd1cb36da5b9fca5a1f838d"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ae09986a5cdd1cb36da5b9fca5a1f838d">clr_lzero</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:ae09986a5cdd1cb36da5b9fca5a1f838d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear toggle lzero bit.  <a href="bytes_8hpp.html#ae09986a5cdd1cb36da5b9fca5a1f838d">More...</a><br /></td></tr>
<tr class="separator:ae09986a5cdd1cb36da5b9fca5a1f838d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9ea0c1d37ac65ee89b5a982b6fa780"><td class="memItemLeft" align="right" valign="top">bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a3c9ea0c1d37ac65ee89b5a982b6fa780">toggle_lzero</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a3c9ea0c1d37ac65ee89b5a982b6fa780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle lzero bit.  <a href="bytes_8hpp.html#a3c9ea0c1d37ac65ee89b5a982b6fa780">More...</a><br /></td></tr>
<tr class="separator:a3c9ea0c1d37ac65ee89b5a982b6fa780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba225b3a29ef2708e422e55940b726a7"><td class="memItemLeft" align="right" valign="top"><a id="aba225b3a29ef2708e422e55940b726a7" name="aba225b3a29ef2708e422e55940b726a7"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>leading_zero_important</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:aba225b3a29ef2708e422e55940b726a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if leading zeroes are important. <br /></td></tr>
<tr class="separator:aba225b3a29ef2708e422e55940b726a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed13fecca2a1a5dc459d43c4ed5a6a96"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aed13fecca2a1a5dc459d43c4ed5a6a96">get_operand_type_shift</a> (<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> n)</td></tr>
<tr class="memdesc:aed13fecca2a1a5dc459d43c4ed5a6a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the shift in `flags64_t` for the nibble representing operand `n`'s type.  <a href="bytes_8hpp.html#aed13fecca2a1a5dc459d43c4ed5a6a96">More...</a><br /></td></tr>
<tr class="separator:aed13fecca2a1a5dc459d43c4ed5a6a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f2ca8cbc1c576af86ef2159a360050"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a36f2ca8cbc1c576af86ef2159a360050">get_operand_flag</a> (<a class="el" href="pro_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> typebits, int n)</td></tr>
<tr class="memdesc:a36f2ca8cbc1c576af86ef2159a360050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place operand `n`'s type flag in the right nibble of a 64-bit flags set.  <a href="bytes_8hpp.html#a36f2ca8cbc1c576af86ef2159a360050">More...</a><br /></td></tr>
<tr class="separator:a36f2ca8cbc1c576af86ef2159a360050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745316ecd14383d243ec2c202897eba6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a745316ecd14383d243ec2c202897eba6">is_flag_for_operand</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, <a class="el" href="pro_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a> typebits, int n)</td></tr>
<tr class="memdesc:a745316ecd14383d243ec2c202897eba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the 64-bit flags set has the expected type for operand `n`.  <a href="bytes_8hpp.html#a745316ecd14383d243ec2c202897eba6">More...</a><br /></td></tr>
<tr class="separator:a745316ecd14383d243ec2c202897eba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3037e8c98e6f648489387d282d09e30"><td class="memItemLeft" align="right" valign="top"><a id="ad3037e8c98e6f648489387d282d09e30" name="ad3037e8c98e6f648489387d282d09e30"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_defarg0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:ad3037e8c98e6f648489387d282d09e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand defined? Initially operand has no defined representation. <br /></td></tr>
<tr class="separator:ad3037e8c98e6f648489387d282d09e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699b111e73c47da120eb6ce7f3593125"><td class="memItemLeft" align="right" valign="top"><a id="a699b111e73c47da120eb6ce7f3593125" name="a699b111e73c47da120eb6ce7f3593125"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_defarg1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a699b111e73c47da120eb6ce7f3593125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand defined? Initially operand has no defined representation. <br /></td></tr>
<tr class="separator:a699b111e73c47da120eb6ce7f3593125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51f127e7228145b86aa2d60b10b08cf"><td class="memItemLeft" align="right" valign="top"><a id="ad51f127e7228145b86aa2d60b10b08cf" name="ad51f127e7228145b86aa2d60b10b08cf"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_off0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:ad51f127e7228145b86aa2d60b10b08cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand offset? (example: push offset xxx) <br /></td></tr>
<tr class="separator:ad51f127e7228145b86aa2d60b10b08cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd0fc94fc938787ba5a07a84be0ae04"><td class="memItemLeft" align="right" valign="top"><a id="a3fd0fc94fc938787ba5a07a84be0ae04" name="a3fd0fc94fc938787ba5a07a84be0ae04"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_off1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a3fd0fc94fc938787ba5a07a84be0ae04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand offset? (example: mov ax, offset xxx) <br /></td></tr>
<tr class="separator:a3fd0fc94fc938787ba5a07a84be0ae04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c42a27c90d7071b0b1ef228546242e"><td class="memItemLeft" align="right" valign="top"><a id="a25c42a27c90d7071b0b1ef228546242e" name="a25c42a27c90d7071b0b1ef228546242e"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_char0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a25c42a27c90d7071b0b1ef228546242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand character constant? (example: push 'a') <br /></td></tr>
<tr class="separator:a25c42a27c90d7071b0b1ef228546242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51eb8f62445feceb88e8281ded1489be"><td class="memItemLeft" align="right" valign="top"><a id="a51eb8f62445feceb88e8281ded1489be" name="a51eb8f62445feceb88e8281ded1489be"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_char1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a51eb8f62445feceb88e8281ded1489be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand character constant? (example: mov al, 'a') <br /></td></tr>
<tr class="separator:a51eb8f62445feceb88e8281ded1489be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca57ed8139275fe17aa81607f5e7d30"><td class="memItemLeft" align="right" valign="top"><a id="a3ca57ed8139275fe17aa81607f5e7d30" name="a3ca57ed8139275fe17aa81607f5e7d30"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_seg0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a3ca57ed8139275fe17aa81607f5e7d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand segment selector? (example: push seg seg001) <br /></td></tr>
<tr class="separator:a3ca57ed8139275fe17aa81607f5e7d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcab9c0858e385b57e5ff91fa1222ccd"><td class="memItemLeft" align="right" valign="top"><a id="afcab9c0858e385b57e5ff91fa1222ccd" name="afcab9c0858e385b57e5ff91fa1222ccd"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_seg1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:afcab9c0858e385b57e5ff91fa1222ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand segment selector? (example: mov dx, seg dseg) <br /></td></tr>
<tr class="separator:afcab9c0858e385b57e5ff91fa1222ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a24e3c2c39279587ecd7c72928a542"><td class="memItemLeft" align="right" valign="top"><a id="ae2a24e3c2c39279587ecd7c72928a542" name="ae2a24e3c2c39279587ecd7c72928a542"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_enum0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:ae2a24e3c2c39279587ecd7c72928a542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand a symbolic constant (enum member)? <br /></td></tr>
<tr class="separator:ae2a24e3c2c39279587ecd7c72928a542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c7a7e4ae65ac3e90cde10d79726094"><td class="memItemLeft" align="right" valign="top"><a id="a36c7a7e4ae65ac3e90cde10d79726094" name="a36c7a7e4ae65ac3e90cde10d79726094"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_enum1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a36c7a7e4ae65ac3e90cde10d79726094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand a symbolic constant (enum member)? <br /></td></tr>
<tr class="separator:a36c7a7e4ae65ac3e90cde10d79726094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13989f33309c7d3b8fa327a917837642"><td class="memItemLeft" align="right" valign="top"><a id="a13989f33309c7d3b8fa327a917837642" name="a13989f33309c7d3b8fa327a917837642"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_stroff0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a13989f33309c7d3b8fa327a917837642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand an offset within a struct? <br /></td></tr>
<tr class="separator:a13989f33309c7d3b8fa327a917837642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb862876935e8f3396636e3ad54a06b"><td class="memItemLeft" align="right" valign="top"><a id="abbb862876935e8f3396636e3ad54a06b" name="abbb862876935e8f3396636e3ad54a06b"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_stroff1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:abbb862876935e8f3396636e3ad54a06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand an offset within a struct? <br /></td></tr>
<tr class="separator:abbb862876935e8f3396636e3ad54a06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2762929f1f9e90e450d2ff7e96b9b6"><td class="memItemLeft" align="right" valign="top"><a id="aef2762929f1f9e90e450d2ff7e96b9b6" name="aef2762929f1f9e90e450d2ff7e96b9b6"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_stkvar0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:aef2762929f1f9e90e450d2ff7e96b9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand a stack variable? <br /></td></tr>
<tr class="separator:aef2762929f1f9e90e450d2ff7e96b9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2c408c2a7a94e6f4d5ee68f42f5198"><td class="memItemLeft" align="right" valign="top"><a id="ada2c408c2a7a94e6f4d5ee68f42f5198" name="ada2c408c2a7a94e6f4d5ee68f42f5198"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_stkvar1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:ada2c408c2a7a94e6f4d5ee68f42f5198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand a stack variable? <br /></td></tr>
<tr class="separator:ada2c408c2a7a94e6f4d5ee68f42f5198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f056cd7e2f93cbeebec9893f191dca1"><td class="memItemLeft" align="right" valign="top"><a id="a1f056cd7e2f93cbeebec9893f191dca1" name="a1f056cd7e2f93cbeebec9893f191dca1"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_float0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a1f056cd7e2f93cbeebec9893f191dca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand a floating point number? <br /></td></tr>
<tr class="separator:a1f056cd7e2f93cbeebec9893f191dca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8538643ff81696c9ab198c1d1439a67a"><td class="memItemLeft" align="right" valign="top"><a id="a8538643ff81696c9ab198c1d1439a67a" name="a8538643ff81696c9ab198c1d1439a67a"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_float1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a8538643ff81696c9ab198c1d1439a67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand a floating point number? <br /></td></tr>
<tr class="separator:a8538643ff81696c9ab198c1d1439a67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9a2106fc97173b5d3531ce48077267"><td class="memItemLeft" align="right" valign="top"><a id="a2d9a2106fc97173b5d3531ce48077267" name="a2d9a2106fc97173b5d3531ce48077267"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_custfmt0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a2d9a2106fc97173b5d3531ce48077267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first operand use a custom data representation? <br /></td></tr>
<tr class="separator:a2d9a2106fc97173b5d3531ce48077267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0e766cfa2c9fcf01fc53d76c2cd212"><td class="memItemLeft" align="right" valign="top"><a id="a9e0e766cfa2c9fcf01fc53d76c2cd212" name="a9e0e766cfa2c9fcf01fc53d76c2cd212"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_custfmt1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a9e0e766cfa2c9fcf01fc53d76c2cd212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the second operand use a custom data representation? <br /></td></tr>
<tr class="separator:a9e0e766cfa2c9fcf01fc53d76c2cd212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c56ffcced32d75ce082a780f2279507"><td class="memItemLeft" align="right" valign="top"><a id="a4c56ffcced32d75ce082a780f2279507" name="a4c56ffcced32d75ce082a780f2279507"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_numop0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a4c56ffcced32d75ce082a780f2279507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first operand a number (i.e. binary, octal, decimal or hex?) <br /></td></tr>
<tr class="separator:a4c56ffcced32d75ce082a780f2279507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f00bfc7dc93cf839c0a3f063d74001"><td class="memItemLeft" align="right" valign="top"><a id="a95f00bfc7dc93cf839c0a3f063d74001" name="a95f00bfc7dc93cf839c0a3f063d74001"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_numop1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a95f00bfc7dc93cf839c0a3f063d74001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the second operand a number (i.e. binary, octal, decimal or hex?) <br /></td></tr>
<tr class="separator:a95f00bfc7dc93cf839c0a3f063d74001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024c442c7b304f021ecd6134569415aa"><td class="memItemLeft" align="right" valign="top"><a id="a024c442c7b304f021ecd6134569415aa" name="a024c442c7b304f021ecd6134569415aa"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_optype_flags0</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a024c442c7b304f021ecd6134569415aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flags for first operand. <br /></td></tr>
<tr class="separator:a024c442c7b304f021ecd6134569415aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644cb97b4e22fa567e7c67a552d18e32"><td class="memItemLeft" align="right" valign="top"><a id="a644cb97b4e22fa567e7c67a552d18e32" name="a644cb97b4e22fa567e7c67a552d18e32"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_optype_flags1</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a644cb97b4e22fa567e7c67a552d18e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flags for second operand. <br /></td></tr>
<tr class="separator:a644cb97b4e22fa567e7c67a552d18e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17de391d1433cb9cf8cb0522b8d5ce2d"><td class="memItemLeft" align="right" valign="top"><a id="a17de391d1433cb9cf8cb0522b8d5ce2d" name="a17de391d1433cb9cf8cb0522b8d5ce2d"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_defarg</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a17de391d1433cb9cf8cb0522b8d5ce2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">is defined? <br /></td></tr>
<tr class="separator:a17de391d1433cb9cf8cb0522b8d5ce2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4822b7f954d242b151550e6eb3d52d1b"><td class="memItemLeft" align="right" valign="top"><a id="a4822b7f954d242b151550e6eb3d52d1b" name="a4822b7f954d242b151550e6eb3d52d1b"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_off</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a4822b7f954d242b151550e6eb3d52d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">is offset? <br /></td></tr>
<tr class="separator:a4822b7f954d242b151550e6eb3d52d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8963bf3634ea4f5a781508fc92a145e"><td class="memItemLeft" align="right" valign="top"><a id="ab8963bf3634ea4f5a781508fc92a145e" name="ab8963bf3634ea4f5a781508fc92a145e"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_char</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:ab8963bf3634ea4f5a781508fc92a145e"><td class="mdescLeft">&#160;</td><td class="mdescRight">is character constant? <br /></td></tr>
<tr class="separator:ab8963bf3634ea4f5a781508fc92a145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451c7c849509a47c4eb1da885f6242c7"><td class="memItemLeft" align="right" valign="top"><a id="a451c7c849509a47c4eb1da885f6242c7" name="a451c7c849509a47c4eb1da885f6242c7"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_seg</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a451c7c849509a47c4eb1da885f6242c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">is segment? <br /></td></tr>
<tr class="separator:a451c7c849509a47c4eb1da885f6242c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02556cc3e3bb425b36931e2f4d2abf25"><td class="memItemLeft" align="right" valign="top"><a id="a02556cc3e3bb425b36931e2f4d2abf25" name="a02556cc3e3bb425b36931e2f4d2abf25"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_enum</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a02556cc3e3bb425b36931e2f4d2abf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">is enum? <br /></td></tr>
<tr class="separator:a02556cc3e3bb425b36931e2f4d2abf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46118f35343d10a75bd8488693f40822"><td class="memItemLeft" align="right" valign="top"><a id="a46118f35343d10a75bd8488693f40822" name="a46118f35343d10a75bd8488693f40822"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_manual</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a46118f35343d10a75bd8488693f40822"><td class="mdescLeft">&#160;</td><td class="mdescRight">is forced operand? (use <a class="el" href="bytes_8hpp.html#a34b34b8cb7a47c749063f436b4848a2d" title="Is operand manually defined?.">is_forced_operand()</a>) <br /></td></tr>
<tr class="separator:a46118f35343d10a75bd8488693f40822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1a8ceb861c483cf83fc1bffd10b734"><td class="memItemLeft" align="right" valign="top"><a id="a2a1a8ceb861c483cf83fc1bffd10b734" name="a2a1a8ceb861c483cf83fc1bffd10b734"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_stroff</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a2a1a8ceb861c483cf83fc1bffd10b734"><td class="mdescLeft">&#160;</td><td class="mdescRight">is struct offset? <br /></td></tr>
<tr class="separator:a2a1a8ceb861c483cf83fc1bffd10b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0f96c6bcbd691773e8505cff0e0234"><td class="memItemLeft" align="right" valign="top"><a id="a4b0f96c6bcbd691773e8505cff0e0234" name="a4b0f96c6bcbd691773e8505cff0e0234"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_stkvar</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a4b0f96c6bcbd691773e8505cff0e0234"><td class="mdescLeft">&#160;</td><td class="mdescRight">is stack variable? <br /></td></tr>
<tr class="separator:a4b0f96c6bcbd691773e8505cff0e0234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35d58054aaec259acdfd02a4ea8f8ec"><td class="memItemLeft" align="right" valign="top"><a id="ac35d58054aaec259acdfd02a4ea8f8ec" name="ac35d58054aaec259acdfd02a4ea8f8ec"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_fltnum</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:ac35d58054aaec259acdfd02a4ea8f8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">is floating point number? <br /></td></tr>
<tr class="separator:ac35d58054aaec259acdfd02a4ea8f8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4617a55dadf559fd96fbf08523da2c9"><td class="memItemLeft" align="right" valign="top"><a id="ae4617a55dadf559fd96fbf08523da2c9" name="ae4617a55dadf559fd96fbf08523da2c9"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_custfmt</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:ae4617a55dadf559fd96fbf08523da2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">is custom data format? <br /></td></tr>
<tr class="separator:ae4617a55dadf559fd96fbf08523da2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6079e6c6bc615ef3dfec7a2d27c2fd78"><td class="memItemLeft" align="right" valign="top"><a id="a6079e6c6bc615ef3dfec7a2d27c2fd78" name="a6079e6c6bc615ef3dfec7a2d27c2fd78"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_numop</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a6079e6c6bc615ef3dfec7a2d27c2fd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">is number (bin, oct, dec, hex)? <br /></td></tr>
<tr class="separator:a6079e6c6bc615ef3dfec7a2d27c2fd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e86a96c6bb2ccb064a291c69be2e709"><td class="memItemLeft" align="right" valign="top"><a id="a7e86a96c6bb2ccb064a291c69be2e709" name="a7e86a96c6bb2ccb064a291c69be2e709"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_suspop</b> (ea_t ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a7e86a96c6bb2ccb064a291c69be2e709"><td class="mdescLeft">&#160;</td><td class="mdescRight">is suspicious operand? <br /></td></tr>
<tr class="separator:a7e86a96c6bb2ccb064a291c69be2e709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ed0642d8f3498976b7a8c01c72f99f"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a71ed0642d8f3498976b7a8c01c72f99f">op_adds_xrefs</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a71ed0642d8f3498976b7a8c01c72f99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should processor module create xrefs from the operand?.  <a href="bytes_8hpp.html#a71ed0642d8f3498976b7a8c01c72f99f">More...</a><br /></td></tr>
<tr class="separator:a71ed0642d8f3498976b7a8c01c72f99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6766a54bd62934647966171b02f9a21c"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a6766a54bd62934647966171b02f9a21c">set_op_type</a> (ea_t ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> type, int n)</td></tr>
<tr class="memdesc:a6766a54bd62934647966171b02f9a21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(internal function) change representation of operand(s).  <a href="bytes_8hpp.html#a6766a54bd62934647966171b02f9a21c">More...</a><br /></td></tr>
<tr class="separator:a6766a54bd62934647966171b02f9a21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b0a61cca8477694fe22002746db49b"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ab8b0a61cca8477694fe22002746db49b">op_seg</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:ab8b0a61cca8477694fe22002746db49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set operand representation to be 'segment'.  <a href="bytes_8hpp.html#ab8b0a61cca8477694fe22002746db49b">More...</a><br /></td></tr>
<tr class="separator:ab8b0a61cca8477694fe22002746db49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d475b8d1d98eb38c5652370d46f25b"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a86d475b8d1d98eb38c5652370d46f25b">op_enum</a> (ea_t ea, int n, <a class="el" href="kernwin_8hpp.html#a320dc6698b7075a653144bbdf202b30e">enum_t</a> id, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> serial)</td></tr>
<tr class="memdesc:a86d475b8d1d98eb38c5652370d46f25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set operand representation to be 'enum_t'.  <a href="bytes_8hpp.html#a86d475b8d1d98eb38c5652370d46f25b">More...</a><br /></td></tr>
<tr class="separator:a86d475b8d1d98eb38c5652370d46f25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0306c235939b0bfc270772909020e853"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="kernwin_8hpp.html#a320dc6698b7075a653144bbdf202b30e">enum_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a0306c235939b0bfc270772909020e853">get_enum_id</a> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *serial, ea_t ea, int n)</td></tr>
<tr class="memdesc:a0306c235939b0bfc270772909020e853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get enum id of 'enum' operand.  <a href="bytes_8hpp.html#a0306c235939b0bfc270772909020e853">More...</a><br /></td></tr>
<tr class="separator:a0306c235939b0bfc270772909020e853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045f11dbaa25bef9d56e63c0a3bbdb08"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a045f11dbaa25bef9d56e63c0a3bbdb08">op_stroff</a> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int n, const <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *path, int path_len, adiff_t delta)</td></tr>
<tr class="memdesc:a045f11dbaa25bef9d56e63c0a3bbdb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set operand representation to be 'struct offset'.  <a href="bytes_8hpp.html#a045f11dbaa25bef9d56e63c0a3bbdb08">More...</a><br /></td></tr>
<tr class="separator:a045f11dbaa25bef9d56e63c0a3bbdb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b9a68c2c5d67ce0155d56fe9070d92"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a05b9a68c2c5d67ce0155d56fe9070d92">get_stroff_path</a> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *path, adiff_t *delta, ea_t ea, int n)</td></tr>
<tr class="memdesc:a05b9a68c2c5d67ce0155d56fe9070d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get struct path of operand.  <a href="bytes_8hpp.html#a05b9a68c2c5d67ce0155d56fe9070d92">More...</a><br /></td></tr>
<tr class="separator:a05b9a68c2c5d67ce0155d56fe9070d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01aa1c70776d2b8b2c62d5e676cd80b"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa01aa1c70776d2b8b2c62d5e676cd80b">op_stkvar</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:aa01aa1c70776d2b8b2c62d5e676cd80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set operand representation to be 'stack variable'.  <a href="bytes_8hpp.html#aa01aa1c70776d2b8b2c62d5e676cd80b">More...</a><br /></td></tr>
<tr class="separator:aa01aa1c70776d2b8b2c62d5e676cd80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30692393915a1ac0c0129f778e4f81fe"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a30692393915a1ac0c0129f778e4f81fe">set_forced_operand</a> (ea_t ea, int n, const char *op)</td></tr>
<tr class="memdesc:a30692393915a1ac0c0129f778e4f81fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set forced operand.  <a href="bytes_8hpp.html#a30692393915a1ac0c0129f778e4f81fe">More...</a><br /></td></tr>
<tr class="separator:a30692393915a1ac0c0129f778e4f81fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5020260196a9d4b57633a762c0c3f2"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a0c5020260196a9d4b57633a762c0c3f2">get_forced_operand</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, ea_t ea, int n)</td></tr>
<tr class="memdesc:a0c5020260196a9d4b57633a762c0c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get forced operand.  <a href="bytes_8hpp.html#a0c5020260196a9d4b57633a762c0c3f2">More...</a><br /></td></tr>
<tr class="separator:a0c5020260196a9d4b57633a762c0c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b34b8cb7a47c749063f436b4848a2d"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a34b34b8cb7a47c749063f436b4848a2d">is_forced_operand</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a34b34b8cb7a47c749063f436b4848a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is operand manually defined?.  <a href="bytes_8hpp.html#a34b34b8cb7a47c749063f436b4848a2d">More...</a><br /></td></tr>
<tr class="separator:a34b34b8cb7a47c749063f436b4848a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1824b59c8bb168e99b556b82ef34bf"><td class="memItemLeft" align="right" valign="top"><a id="a2e1824b59c8bb168e99b556b82ef34bf" name="a2e1824b59c8bb168e99b556b82ef34bf"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>combine_flags</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="separator:a2e1824b59c8bb168e99b556b82ef34bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85d89d054af7549f1f09e669bb587f0"><td class="memItemLeft" align="right" valign="top"><a id="af85d89d054af7549f1f09e669bb587f0" name="af85d89d054af7549f1f09e669bb587f0"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>char_flag</b> (void)</td></tr>
<tr class="memdesc:af85d89d054af7549f1f09e669bb587f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">see FF_opbits <br /></td></tr>
<tr class="separator:af85d89d054af7549f1f09e669bb587f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5616f10cc0356c28f43e92a34ca16f8d"><td class="memItemLeft" align="right" valign="top"><a id="a5616f10cc0356c28f43e92a34ca16f8d" name="a5616f10cc0356c28f43e92a34ca16f8d"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>off_flag</b> (void)</td></tr>
<tr class="memdesc:a5616f10cc0356c28f43e92a34ca16f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">see FF_opbits <br /></td></tr>
<tr class="separator:a5616f10cc0356c28f43e92a34ca16f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2130d0e8d763ef1b809f2049358683e2"><td class="memItemLeft" align="right" valign="top"><a id="a2130d0e8d763ef1b809f2049358683e2" name="a2130d0e8d763ef1b809f2049358683e2"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>enum_flag</b> (void)</td></tr>
<tr class="memdesc:a2130d0e8d763ef1b809f2049358683e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">see FF_opbits <br /></td></tr>
<tr class="separator:a2130d0e8d763ef1b809f2049358683e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1c743d62fcf259f087f51bec9bc377"><td class="memItemLeft" align="right" valign="top"><a id="a4e1c743d62fcf259f087f51bec9bc377" name="a4e1c743d62fcf259f087f51bec9bc377"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>stroff_flag</b> (void)</td></tr>
<tr class="memdesc:a4e1c743d62fcf259f087f51bec9bc377"><td class="mdescLeft">&#160;</td><td class="mdescRight">see FF_opbits <br /></td></tr>
<tr class="separator:a4e1c743d62fcf259f087f51bec9bc377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcd724f4ba1be946ef2731f33288f60"><td class="memItemLeft" align="right" valign="top"><a id="affcd724f4ba1be946ef2731f33288f60" name="affcd724f4ba1be946ef2731f33288f60"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>stkvar_flag</b> (void)</td></tr>
<tr class="memdesc:affcd724f4ba1be946ef2731f33288f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">see FF_opbits <br /></td></tr>
<tr class="separator:affcd724f4ba1be946ef2731f33288f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029f4e4dea9404095a675d72df980934"><td class="memItemLeft" align="right" valign="top"><a id="a029f4e4dea9404095a675d72df980934" name="a029f4e4dea9404095a675d72df980934"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>flt_flag</b> (void)</td></tr>
<tr class="memdesc:a029f4e4dea9404095a675d72df980934"><td class="mdescLeft">&#160;</td><td class="mdescRight">see FF_opbits <br /></td></tr>
<tr class="separator:a029f4e4dea9404095a675d72df980934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30076fe30e659fb948f2c7197ab87792"><td class="memItemLeft" align="right" valign="top"><a id="a30076fe30e659fb948f2c7197ab87792" name="a30076fe30e659fb948f2c7197ab87792"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>custfmt_flag</b> (void)</td></tr>
<tr class="memdesc:a30076fe30e659fb948f2c7197ab87792"><td class="mdescLeft">&#160;</td><td class="mdescRight">see FF_opbits <br /></td></tr>
<tr class="separator:a30076fe30e659fb948f2c7197ab87792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377b85a2b84fa1df427da72c42ab5110"><td class="memItemLeft" align="right" valign="top"><a id="a377b85a2b84fa1df427da72c42ab5110" name="a377b85a2b84fa1df427da72c42ab5110"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>seg_flag</b> (void)</td></tr>
<tr class="memdesc:a377b85a2b84fa1df427da72c42ab5110"><td class="mdescLeft">&#160;</td><td class="mdescRight">see FF_opbits <br /></td></tr>
<tr class="separator:a377b85a2b84fa1df427da72c42ab5110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2c2c18f6359471b6ab5908f175469e"><td class="memItemLeft" align="right" valign="top"><a id="acc2c2c18f6359471b6ab5908f175469e" name="acc2c2c18f6359471b6ab5908f175469e"></a>
idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>num_flag</b> (void)</td></tr>
<tr class="memdesc:acc2c2c18f6359471b6ab5908f175469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of default base (bin, oct, dec, hex) <br /></td></tr>
<tr class="separator:acc2c2c18f6359471b6ab5908f175469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9016f0611b8b3578401e7c3f2c55cd91"><td class="memItemLeft" align="right" valign="top"><a id="a9016f0611b8b3578401e7c3f2c55cd91" name="a9016f0611b8b3578401e7c3f2c55cd91"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>hex_flag</b> (void)</td></tr>
<tr class="memdesc:a9016f0611b8b3578401e7c3f2c55cd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number flag of the base, regardless of current processor - better to use <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a> <br /></td></tr>
<tr class="separator:a9016f0611b8b3578401e7c3f2c55cd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0caa5301feb96d4c8fa6caf9eb65d0f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#af0caa5301feb96d4c8fa6caf9eb65d0f">dec_flag</a> (void)</td></tr>
<tr class="memdesc:af0caa5301feb96d4c8fa6caf9eb65d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number flag of the base, regardless of current processor - better to use <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a>  <a href="bytes_8hpp.html#af0caa5301feb96d4c8fa6caf9eb65d0f">More...</a><br /></td></tr>
<tr class="separator:af0caa5301feb96d4c8fa6caf9eb65d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf779f23aa13d2af88398101f42ea115"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#acf779f23aa13d2af88398101f42ea115">oct_flag</a> (void)</td></tr>
<tr class="memdesc:acf779f23aa13d2af88398101f42ea115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number flag of the base, regardless of current processor - better to use <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a>  <a href="bytes_8hpp.html#acf779f23aa13d2af88398101f42ea115">More...</a><br /></td></tr>
<tr class="separator:acf779f23aa13d2af88398101f42ea115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11d9660b1084b938b265b699a47a4eb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ab11d9660b1084b938b265b699a47a4eb">bin_flag</a> (void)</td></tr>
<tr class="memdesc:ab11d9660b1084b938b265b699a47a4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number flag of the base, regardless of current processor - better to use <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a>  <a href="bytes_8hpp.html#ab11d9660b1084b938b265b699a47a4eb">More...</a><br /></td></tr>
<tr class="separator:ab11d9660b1084b938b265b699a47a4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0295e1cf57d6f60f16aa702c096af9"><td class="memItemLeft" align="right" valign="top"><a id="adf0295e1cf57d6f60f16aa702c096af9" name="adf0295e1cf57d6f60f16aa702c096af9"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>op_chr</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:adf0295e1cf57d6f60f16aa702c096af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set op type to <a class="el" href="bytes_8hpp.html#af85d89d054af7549f1f09e669bb587f0" title="see FF_opbits">char_flag()</a> <br /></td></tr>
<tr class="separator:adf0295e1cf57d6f60f16aa702c096af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb5e2ddd05e952cf01441deb704fa20"><td class="memItemLeft" align="right" valign="top"><a id="a7cb5e2ddd05e952cf01441deb704fa20" name="a7cb5e2ddd05e952cf01441deb704fa20"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>op_num</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a7cb5e2ddd05e952cf01441deb704fa20"><td class="mdescLeft">&#160;</td><td class="mdescRight">set op type to <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a> <br /></td></tr>
<tr class="separator:a7cb5e2ddd05e952cf01441deb704fa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a75b188796c73be1cd02ad829e9c003"><td class="memItemLeft" align="right" valign="top"><a id="a3a75b188796c73be1cd02ad829e9c003" name="a3a75b188796c73be1cd02ad829e9c003"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>op_hex</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a3a75b188796c73be1cd02ad829e9c003"><td class="mdescLeft">&#160;</td><td class="mdescRight">set op type to <a class="el" href="bytes_8hpp.html#a9016f0611b8b3578401e7c3f2c55cd91" title="Get number flag of the base, regardless of current processor - better to use num_flag()">hex_flag()</a> <br /></td></tr>
<tr class="separator:a3a75b188796c73be1cd02ad829e9c003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fc23f7331f5187eace66897b8e2bfc"><td class="memItemLeft" align="right" valign="top"><a id="a84fc23f7331f5187eace66897b8e2bfc" name="a84fc23f7331f5187eace66897b8e2bfc"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>op_dec</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a84fc23f7331f5187eace66897b8e2bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">set op type to <a class="el" href="bytes_8hpp.html#af0caa5301feb96d4c8fa6caf9eb65d0f" title="Get number flag of the base, regardless of current processor - better to use num_flag()">dec_flag()</a> <br /></td></tr>
<tr class="separator:a84fc23f7331f5187eace66897b8e2bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061587ee57e5454a47d449d1e35dd2b4"><td class="memItemLeft" align="right" valign="top"><a id="a061587ee57e5454a47d449d1e35dd2b4" name="a061587ee57e5454a47d449d1e35dd2b4"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>op_oct</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:a061587ee57e5454a47d449d1e35dd2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">set op type to <a class="el" href="bytes_8hpp.html#acf779f23aa13d2af88398101f42ea115" title="Get number flag of the base, regardless of current processor - better to use num_flag()">oct_flag()</a> <br /></td></tr>
<tr class="separator:a061587ee57e5454a47d449d1e35dd2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0dc35c076ef810542901b566545d25"><td class="memItemLeft" align="right" valign="top"><a id="afa0dc35c076ef810542901b566545d25" name="afa0dc35c076ef810542901b566545d25"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>op_bin</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:afa0dc35c076ef810542901b566545d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">set op type to <a class="el" href="bytes_8hpp.html#ab11d9660b1084b938b265b699a47a4eb" title="Get number flag of the base, regardless of current processor - better to use num_flag()">bin_flag()</a> <br /></td></tr>
<tr class="separator:afa0dc35c076ef810542901b566545d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba581bada7325e01513f001459cf9c35"><td class="memItemLeft" align="right" valign="top"><a id="aba581bada7325e01513f001459cf9c35" name="aba581bada7325e01513f001459cf9c35"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>op_flt</b> (ea_t ea, int n)</td></tr>
<tr class="memdesc:aba581bada7325e01513f001459cf9c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">set op type to <a class="el" href="bytes_8hpp.html#a029f4e4dea9404095a675d72df980934" title="see FF_opbits">flt_flag()</a> <br /></td></tr>
<tr class="separator:aba581bada7325e01513f001459cf9c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca3f9ede442712637f767efafeb1d47"><td class="memItemLeft" align="right" valign="top"><a id="abca3f9ede442712637f767efafeb1d47" name="abca3f9ede442712637f767efafeb1d47"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>op_custfmt</b> (ea_t ea, int n, int fid)</td></tr>
<tr class="memdesc:abca3f9ede442712637f767efafeb1d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom data format for operand (fid-custom data format id) <br /></td></tr>
<tr class="separator:abca3f9ede442712637f767efafeb1d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2af9a3b5eaf1be072e8052ac0322b90"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa2af9a3b5eaf1be072e8052ac0322b90">clr_op_type</a> (ea_t ea, int n)</td></tr>
<tr class="memdesc:aa2af9a3b5eaf1be072e8052ac0322b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove operand representation information.  <a href="bytes_8hpp.html#aa2af9a3b5eaf1be072e8052ac0322b90">More...</a><br /></td></tr>
<tr class="separator:aa2af9a3b5eaf1be072e8052ac0322b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6154881265dd78649e6f4c526e70528"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa6154881265dd78649e6f4c526e70528">get_default_radix</a> (void)</td></tr>
<tr class="memdesc:aa6154881265dd78649e6f4c526e70528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default base of number for the current processor.  <a href="bytes_8hpp.html#aa6154881265dd78649e6f4c526e70528">More...</a><br /></td></tr>
<tr class="separator:aa6154881265dd78649e6f4c526e70528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a59b1f28010bc41cb41369dbba81a8"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a09a59b1f28010bc41cb41369dbba81a8">get_radix</a> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, int n)</td></tr>
<tr class="memdesc:a09a59b1f28010bc41cb41369dbba81a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get radix of the operand, in: flags.  <a href="bytes_8hpp.html#a09a59b1f28010bc41cb41369dbba81a8">More...</a><br /></td></tr>
<tr class="separator:a09a59b1f28010bc41cb41369dbba81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86f6368f613f444dfdadc1ab266eabf"><td class="memItemLeft" align="right" valign="top"><a id="ac86f6368f613f444dfdadc1ab266eabf" name="ac86f6368f613f444dfdadc1ab266eabf"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>code_flag</b> (void)</td></tr>
<tr class="memdesc:ac86f6368f613f444dfdadc1ab266eabf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#acb1e52d0b6bcfce13bfb81dcb793f447" title="Code ?">FF_CODE</a> <br /></td></tr>
<tr class="separator:ac86f6368f613f444dfdadc1ab266eabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6376a30aecda71f92475c02eeeee99ae"><td class="memItemLeft" align="right" valign="top"><a id="a6376a30aecda71f92475c02eeeee99ae" name="a6376a30aecda71f92475c02eeeee99ae"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>byte_flag</b> (void)</td></tr>
<tr class="memdesc:a6376a30aecda71f92475c02eeeee99ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a byte. <br /></td></tr>
<tr class="separator:a6376a30aecda71f92475c02eeeee99ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f96b780b188c1268b8de2ee66b84c61"><td class="memItemLeft" align="right" valign="top"><a id="a0f96b780b188c1268b8de2ee66b84c61" name="a0f96b780b188c1268b8de2ee66b84c61"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>word_flag</b> (void)</td></tr>
<tr class="memdesc:a0f96b780b188c1268b8de2ee66b84c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a word. <br /></td></tr>
<tr class="separator:a0f96b780b188c1268b8de2ee66b84c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4b5071a94b5adf90a69496ff60aa3a"><td class="memItemLeft" align="right" valign="top"><a id="a4c4b5071a94b5adf90a69496ff60aa3a" name="a4c4b5071a94b5adf90a69496ff60aa3a"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>dword_flag</b> (void)</td></tr>
<tr class="memdesc:a4c4b5071a94b5adf90a69496ff60aa3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a double word. <br /></td></tr>
<tr class="separator:a4c4b5071a94b5adf90a69496ff60aa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8af3f2da8765cc657f9c599857dbf9"><td class="memItemLeft" align="right" valign="top"><a id="a6d8af3f2da8765cc657f9c599857dbf9" name="a6d8af3f2da8765cc657f9c599857dbf9"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>qword_flag</b> (void)</td></tr>
<tr class="memdesc:a6d8af3f2da8765cc657f9c599857dbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a quad word. <br /></td></tr>
<tr class="separator:a6d8af3f2da8765cc657f9c599857dbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f9c2a7c6862e361ac3da48cde838a4"><td class="memItemLeft" align="right" valign="top"><a id="ac6f9c2a7c6862e361ac3da48cde838a4" name="ac6f9c2a7c6862e361ac3da48cde838a4"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>oword_flag</b> (void)</td></tr>
<tr class="memdesc:ac6f9c2a7c6862e361ac3da48cde838a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a octaword. <br /></td></tr>
<tr class="separator:ac6f9c2a7c6862e361ac3da48cde838a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed7d363baa101f577f3a0cc0a65e111"><td class="memItemLeft" align="right" valign="top"><a id="a9ed7d363baa101f577f3a0cc0a65e111" name="a9ed7d363baa101f577f3a0cc0a65e111"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>yword_flag</b> (void)</td></tr>
<tr class="memdesc:a9ed7d363baa101f577f3a0cc0a65e111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a ymm word. <br /></td></tr>
<tr class="separator:a9ed7d363baa101f577f3a0cc0a65e111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47aecb75c50446eeea102de513e9510"><td class="memItemLeft" align="right" valign="top"><a id="aa47aecb75c50446eeea102de513e9510" name="aa47aecb75c50446eeea102de513e9510"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>zword_flag</b> (void)</td></tr>
<tr class="memdesc:aa47aecb75c50446eeea102de513e9510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a zmm word. <br /></td></tr>
<tr class="separator:aa47aecb75c50446eeea102de513e9510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524844621595870ba7cb91d0ea8db4da"><td class="memItemLeft" align="right" valign="top"><a id="a524844621595870ba7cb91d0ea8db4da" name="a524844621595870ba7cb91d0ea8db4da"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>tbyte_flag</b> (void)</td></tr>
<tr class="memdesc:a524844621595870ba7cb91d0ea8db4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a tbyte. <br /></td></tr>
<tr class="separator:a524844621595870ba7cb91d0ea8db4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97cf49dbc871b41b2deb67204e586bf"><td class="memItemLeft" align="right" valign="top"><a id="af97cf49dbc871b41b2deb67204e586bf" name="af97cf49dbc871b41b2deb67204e586bf"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>strlit_flag</b> (void)</td></tr>
<tr class="memdesc:af97cf49dbc871b41b2deb67204e586bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a string literal. <br /></td></tr>
<tr class="separator:af97cf49dbc871b41b2deb67204e586bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de69bfb8e13f7ec3df4cb6c1cc138da"><td class="memItemLeft" align="right" valign="top"><a id="a7de69bfb8e13f7ec3df4cb6c1cc138da" name="a7de69bfb8e13f7ec3df4cb6c1cc138da"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>stru_flag</b> (void)</td></tr>
<tr class="memdesc:a7de69bfb8e13f7ec3df4cb6c1cc138da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a struct. <br /></td></tr>
<tr class="separator:a7de69bfb8e13f7ec3df4cb6c1cc138da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b17539d4c9839ea94b9d721f950d0e"><td class="memItemLeft" align="right" valign="top"><a id="a15b17539d4c9839ea94b9d721f950d0e" name="a15b17539d4c9839ea94b9d721f950d0e"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>cust_flag</b> (void)</td></tr>
<tr class="memdesc:a15b17539d4c9839ea94b9d721f950d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing custom type data. <br /></td></tr>
<tr class="separator:a15b17539d4c9839ea94b9d721f950d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0c024b9fda2d92d01cb6e5a56502c2"><td class="memItemLeft" align="right" valign="top"><a id="a0a0c024b9fda2d92d01cb6e5a56502c2" name="a0a0c024b9fda2d92d01cb6e5a56502c2"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>align_flag</b> (void)</td></tr>
<tr class="memdesc:a0a0c024b9fda2d92d01cb6e5a56502c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing an alignment directive. <br /></td></tr>
<tr class="separator:a0a0c024b9fda2d92d01cb6e5a56502c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9645a5077b016aa873816b3b9e88a9"><td class="memItemLeft" align="right" valign="top"><a id="a7e9645a5077b016aa873816b3b9e88a9" name="a7e9645a5077b016aa873816b3b9e88a9"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>float_flag</b> (void)</td></tr>
<tr class="memdesc:a7e9645a5077b016aa873816b3b9e88a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a float. <br /></td></tr>
<tr class="separator:a7e9645a5077b016aa873816b3b9e88a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54c05b2455bae6d1fa282ef5dbadbde"><td class="memItemLeft" align="right" valign="top"><a id="ae54c05b2455bae6d1fa282ef5dbadbde" name="ae54c05b2455bae6d1fa282ef5dbadbde"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>double_flag</b> (void)</td></tr>
<tr class="memdesc:ae54c05b2455bae6d1fa282ef5dbadbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a double. <br /></td></tr>
<tr class="separator:ae54c05b2455bae6d1fa282ef5dbadbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2aaab446f03623296243ed962b91d5"><td class="memItemLeft" align="right" valign="top"><a id="a7c2aaab446f03623296243ed962b91d5" name="a7c2aaab446f03623296243ed962b91d5"></a>
constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>packreal_flag</b> (void)</td></tr>
<tr class="memdesc:a7c2aaab446f03623296243ed962b91d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a flags64_t representing a packed decimal real. <br /></td></tr>
<tr class="separator:a7c2aaab446f03623296243ed962b91d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0761cec5d29974c8c197d3d0f626ba0d"><td class="memItemLeft" align="right" valign="top"><a id="a0761cec5d29974c8c197d3d0f626ba0d" name="a0761cec5d29974c8c197d3d0f626ba0d"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_byte</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a0761cec5d29974c8c197d3d0f626ba0d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a31e184e1e9e9986dccb2bf75a5cc281a" title="byte">FF_BYTE</a> <br /></td></tr>
<tr class="separator:a0761cec5d29974c8c197d3d0f626ba0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6e0bc1e03f9e44bf61e6a69dc0ed5c"><td class="memItemLeft" align="right" valign="top"><a id="a2b6e0bc1e03f9e44bf61e6a69dc0ed5c" name="a2b6e0bc1e03f9e44bf61e6a69dc0ed5c"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_word</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a2b6e0bc1e03f9e44bf61e6a69dc0ed5c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a700e6fe75ce2d59afe9f0337419e5fb3" title="word">FF_WORD</a> <br /></td></tr>
<tr class="separator:a2b6e0bc1e03f9e44bf61e6a69dc0ed5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f775f64301e4d7054a321f4b3684394"><td class="memItemLeft" align="right" valign="top"><a id="a3f775f64301e4d7054a321f4b3684394" name="a3f775f64301e4d7054a321f4b3684394"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_dword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a3f775f64301e4d7054a321f4b3684394"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a113c39256aa0eb30138fc3dcbbb1b224" title="double word">FF_DWORD</a> <br /></td></tr>
<tr class="separator:a3f775f64301e4d7054a321f4b3684394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ceacea9adc703dfa01160af20bdedc"><td class="memItemLeft" align="right" valign="top"><a id="a28ceacea9adc703dfa01160af20bdedc" name="a28ceacea9adc703dfa01160af20bdedc"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_qword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a28ceacea9adc703dfa01160af20bdedc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a74d61c8ba1d3bedefbd3e619f1f4116a" title="quadro word">FF_QWORD</a> <br /></td></tr>
<tr class="separator:a28ceacea9adc703dfa01160af20bdedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d0a9b2454bd44571220d0557f48bab"><td class="memItemLeft" align="right" valign="top"><a id="a94d0a9b2454bd44571220d0557f48bab" name="a94d0a9b2454bd44571220d0557f48bab"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_oword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a94d0a9b2454bd44571220d0557f48bab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a6102a6e3eebb8350527c7613792080ae" title="octaword/xmm word (16 bytes/128 bits)">FF_OWORD</a> <br /></td></tr>
<tr class="separator:a94d0a9b2454bd44571220d0557f48bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb67e539a248a3a9b215da4ebb5d52c"><td class="memItemLeft" align="right" valign="top"><a id="aefb67e539a248a3a9b215da4ebb5d52c" name="aefb67e539a248a3a9b215da4ebb5d52c"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_yword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:aefb67e539a248a3a9b215da4ebb5d52c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a4c5878e95aef45b3816e5cfcf16cacb9" title="ymm word (32 bytes/256 bits)">FF_YWORD</a> <br /></td></tr>
<tr class="separator:aefb67e539a248a3a9b215da4ebb5d52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ea033cb4a025d61726444e7d09614"><td class="memItemLeft" align="right" valign="top"><a id="a2c2ea033cb4a025d61726444e7d09614" name="a2c2ea033cb4a025d61726444e7d09614"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_zword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a2c2ea033cb4a025d61726444e7d09614"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a3c513c72624ec1d284f2c3e9f295a6e8" title="zmm word (64 bytes/512 bits)">FF_ZWORD</a> <br /></td></tr>
<tr class="separator:a2c2ea033cb4a025d61726444e7d09614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcde5ca590796ee0b1df342d4a38f046"><td class="memItemLeft" align="right" valign="top"><a id="adcde5ca590796ee0b1df342d4a38f046" name="adcde5ca590796ee0b1df342d4a38f046"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_tbyte</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:adcde5ca590796ee0b1df342d4a38f046"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a8b0cb6734338e1ed1a3188d6b4c70b8f" title="tbyte">FF_TBYTE</a> <br /></td></tr>
<tr class="separator:adcde5ca590796ee0b1df342d4a38f046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01522575759c117d7f4680ad8ed8e3f7"><td class="memItemLeft" align="right" valign="top"><a id="a01522575759c117d7f4680ad8ed8e3f7" name="a01522575759c117d7f4680ad8ed8e3f7"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_float</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a01522575759c117d7f4680ad8ed8e3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#adc1e062047911a7fda90a84959fa49bc" title="float">FF_FLOAT</a> <br /></td></tr>
<tr class="separator:a01522575759c117d7f4680ad8ed8e3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eec24aa7f79d51fd67d6273de9d5b32"><td class="memItemLeft" align="right" valign="top"><a id="a8eec24aa7f79d51fd67d6273de9d5b32" name="a8eec24aa7f79d51fd67d6273de9d5b32"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_double</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a8eec24aa7f79d51fd67d6273de9d5b32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a709bb154304e65d8991bc081a182ce2e" title="double">FF_DOUBLE</a> <br /></td></tr>
<tr class="separator:a8eec24aa7f79d51fd67d6273de9d5b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4682b82e7dd895511dcf10ffd7042f81"><td class="memItemLeft" align="right" valign="top"><a id="a4682b82e7dd895511dcf10ffd7042f81" name="a4682b82e7dd895511dcf10ffd7042f81"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_pack_real</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a4682b82e7dd895511dcf10ffd7042f81"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#aa0adb817e6662035bd7d06346c01c864" title="packed decimal real">FF_PACKREAL</a> <br /></td></tr>
<tr class="separator:a4682b82e7dd895511dcf10ffd7042f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf05a152e4030faf22bf7853519822d"><td class="memItemLeft" align="right" valign="top"><a id="a7bf05a152e4030faf22bf7853519822d" name="a7bf05a152e4030faf22bf7853519822d"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_strlit</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a7bf05a152e4030faf22bf7853519822d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#aa320c33a480cc1403e0c7912ee1bd522" title="string literal">FF_STRLIT</a> <br /></td></tr>
<tr class="separator:a7bf05a152e4030faf22bf7853519822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784cc19c769229c8cd2da2d2198a4b05"><td class="memItemLeft" align="right" valign="top"><a id="a784cc19c769229c8cd2da2d2198a4b05" name="a784cc19c769229c8cd2da2d2198a4b05"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_struct</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a784cc19c769229c8cd2da2d2198a4b05"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a303e1d05f0fd18c165ff0c2c7e4aa4de" title="struct variable">FF_STRUCT</a> <br /></td></tr>
<tr class="separator:a784cc19c769229c8cd2da2d2198a4b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091a97613064431458acd6a7e32e1a96"><td class="memItemLeft" align="right" valign="top"><a id="a091a97613064431458acd6a7e32e1a96" name="a091a97613064431458acd6a7e32e1a96"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_align</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a091a97613064431458acd6a7e32e1a96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a61f222cbe3cbe2570892096fc7dc1e8c" title="alignment directive">FF_ALIGN</a> <br /></td></tr>
<tr class="separator:a091a97613064431458acd6a7e32e1a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5937408248d0167a51b6997811b2b71"><td class="memItemLeft" align="right" valign="top"><a id="ad5937408248d0167a51b6997811b2b71" name="ad5937408248d0167a51b6997811b2b71"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_custom</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:ad5937408248d0167a51b6997811b2b71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="bytes_8hpp.html#a19f933094d6c5c52e6f9861d533d1382" title="custom data type">FF_CUSTOM</a> <br /></td></tr>
<tr class="separator:ad5937408248d0167a51b6997811b2b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f08583930195765d7beda776fe1571"><td class="memItemLeft" align="right" valign="top"><a id="ae8f08583930195765d7beda776fe1571" name="ae8f08583930195765d7beda776fe1571"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_byte</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:ae8f08583930195765d7beda776fe1571"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a0761cec5d29974c8c197d3d0f626ba0d" title="FF_BYTE">is_byte()</a> <br /></td></tr>
<tr class="separator:ae8f08583930195765d7beda776fe1571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6989ac2c86edc3d49fd8a1438e5a3ba"><td class="memItemLeft" align="right" valign="top"><a id="af6989ac2c86edc3d49fd8a1438e5a3ba" name="af6989ac2c86edc3d49fd8a1438e5a3ba"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_word</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:af6989ac2c86edc3d49fd8a1438e5a3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a2b6e0bc1e03f9e44bf61e6a69dc0ed5c" title="FF_WORD">is_word()</a> <br /></td></tr>
<tr class="separator:af6989ac2c86edc3d49fd8a1438e5a3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbb375005493ad472f3e0c33a85b6ac"><td class="memItemLeft" align="right" valign="top"><a id="aadbb375005493ad472f3e0c33a85b6ac" name="aadbb375005493ad472f3e0c33a85b6ac"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_dword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:aadbb375005493ad472f3e0c33a85b6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a3f775f64301e4d7054a321f4b3684394" title="FF_DWORD">is_dword()</a> <br /></td></tr>
<tr class="separator:aadbb375005493ad472f3e0c33a85b6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7279eb42d21b133c3bb0e5dbd1e30c6a"><td class="memItemLeft" align="right" valign="top"><a id="a7279eb42d21b133c3bb0e5dbd1e30c6a" name="a7279eb42d21b133c3bb0e5dbd1e30c6a"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_qword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a7279eb42d21b133c3bb0e5dbd1e30c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a28ceacea9adc703dfa01160af20bdedc" title="FF_QWORD">is_qword()</a> <br /></td></tr>
<tr class="separator:a7279eb42d21b133c3bb0e5dbd1e30c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a4cc91d73bb7bde91278befe4f9aee"><td class="memItemLeft" align="right" valign="top"><a id="af5a4cc91d73bb7bde91278befe4f9aee" name="af5a4cc91d73bb7bde91278befe4f9aee"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_oword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:af5a4cc91d73bb7bde91278befe4f9aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a94d0a9b2454bd44571220d0557f48bab" title="FF_OWORD">is_oword()</a> <br /></td></tr>
<tr class="separator:af5a4cc91d73bb7bde91278befe4f9aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a853dcb3cd2ce408f091eec35f9a19d"><td class="memItemLeft" align="right" valign="top"><a id="a1a853dcb3cd2ce408f091eec35f9a19d" name="a1a853dcb3cd2ce408f091eec35f9a19d"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_yword</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a1a853dcb3cd2ce408f091eec35f9a19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#aefb67e539a248a3a9b215da4ebb5d52c" title="FF_YWORD">is_yword()</a> <br /></td></tr>
<tr class="separator:a1a853dcb3cd2ce408f091eec35f9a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099523c86f6df9273c5934380d5dc981"><td class="memItemLeft" align="right" valign="top"><a id="a099523c86f6df9273c5934380d5dc981" name="a099523c86f6df9273c5934380d5dc981"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_tbyte</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a099523c86f6df9273c5934380d5dc981"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#adcde5ca590796ee0b1df342d4a38f046" title="FF_TBYTE">is_tbyte()</a> <br /></td></tr>
<tr class="separator:a099523c86f6df9273c5934380d5dc981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe514d3a1883e286815708ce46c84745"><td class="memItemLeft" align="right" valign="top"><a id="afe514d3a1883e286815708ce46c84745" name="afe514d3a1883e286815708ce46c84745"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_float</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:afe514d3a1883e286815708ce46c84745"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a01522575759c117d7f4680ad8ed8e3f7" title="FF_FLOAT">is_float()</a> <br /></td></tr>
<tr class="separator:afe514d3a1883e286815708ce46c84745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbac08c1652590b0a5d4b2c5c121bd8f"><td class="memItemLeft" align="right" valign="top"><a id="afbac08c1652590b0a5d4b2c5c121bd8f" name="afbac08c1652590b0a5d4b2c5c121bd8f"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_double</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:afbac08c1652590b0a5d4b2c5c121bd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a8eec24aa7f79d51fd67d6273de9d5b32" title="FF_DOUBLE">is_double()</a> <br /></td></tr>
<tr class="separator:afbac08c1652590b0a5d4b2c5c121bd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d2a9d0241cf327ac481664a774ef0d"><td class="memItemLeft" align="right" valign="top"><a id="a91d2a9d0241cf327ac481664a774ef0d" name="a91d2a9d0241cf327ac481664a774ef0d"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_pack_real</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a91d2a9d0241cf327ac481664a774ef0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a4682b82e7dd895511dcf10ffd7042f81" title="FF_PACKREAL">is_pack_real()</a> <br /></td></tr>
<tr class="separator:a91d2a9d0241cf327ac481664a774ef0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6176ce1e71b304c05058820eb9596927"><td class="memItemLeft" align="right" valign="top"><a id="a6176ce1e71b304c05058820eb9596927" name="a6176ce1e71b304c05058820eb9596927"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_strlit</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a6176ce1e71b304c05058820eb9596927"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a7bf05a152e4030faf22bf7853519822d" title="FF_STRLIT">is_strlit()</a> <br /></td></tr>
<tr class="separator:a6176ce1e71b304c05058820eb9596927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4448e0b4d1950a7603f74262c693c28"><td class="memItemLeft" align="right" valign="top"><a id="ac4448e0b4d1950a7603f74262c693c28" name="ac4448e0b4d1950a7603f74262c693c28"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_struct</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:ac4448e0b4d1950a7603f74262c693c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a784cc19c769229c8cd2da2d2198a4b05" title="FF_STRUCT">is_struct()</a> <br /></td></tr>
<tr class="separator:ac4448e0b4d1950a7603f74262c693c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406ae48e82acb9225be42e8476df31c9"><td class="memItemLeft" align="right" valign="top"><a id="a406ae48e82acb9225be42e8476df31c9" name="a406ae48e82acb9225be42e8476df31c9"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_align</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:a406ae48e82acb9225be42e8476df31c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#a091a97613064431458acd6a7e32e1a96" title="FF_ALIGN">is_align()</a> <br /></td></tr>
<tr class="separator:a406ae48e82acb9225be42e8476df31c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe12e1cd6269deb4bea1607be3e1813"><td class="memItemLeft" align="right" valign="top"><a id="acbe12e1cd6269deb4bea1607be3e1813" name="acbe12e1cd6269deb4bea1607be3e1813"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>f_is_custom</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, void *)</td></tr>
<tr class="memdesc:acbe12e1cd6269deb4bea1607be3e1813"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="bytes_8hpp.html#ad5937408248d0167a51b6997811b2b71" title="FF_CUSTOM">is_custom()</a> <br /></td></tr>
<tr class="separator:acbe12e1cd6269deb4bea1607be3e1813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597910db5becbda18d32f9b96ba6f633"><td class="memItemLeft" align="right" valign="top"><a id="a597910db5becbda18d32f9b96ba6f633" name="a597910db5becbda18d32f9b96ba6f633"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_same_data_type</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F1, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F2)</td></tr>
<tr class="memdesc:a597910db5becbda18d32f9b96ba6f633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the given flags specify the same data type? <br /></td></tr>
<tr class="separator:a597910db5becbda18d32f9b96ba6f633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04173497ce9aa37187db3732328422d2"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a04173497ce9aa37187db3732328422d2">get_flags_by_size</a> (size_t size)</td></tr>
<tr class="memdesc:a04173497ce9aa37187db3732328422d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get flags from size (in bytes).  <a href="bytes_8hpp.html#a04173497ce9aa37187db3732328422d2">More...</a><br /></td></tr>
<tr class="separator:a04173497ce9aa37187db3732328422d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fa02b325a0d0eb6c19ca518a5da99d"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a10fa02b325a0d0eb6c19ca518a5da99d">create_data</a> (ea_t ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> dataflag, asize_t size, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> tid)</td></tr>
<tr class="memdesc:a10fa02b325a0d0eb6c19ca518a5da99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to data (byte, word, dword, etc).  <a href="bytes_8hpp.html#a10fa02b325a0d0eb6c19ca518a5da99d">More...</a><br /></td></tr>
<tr class="separator:a10fa02b325a0d0eb6c19ca518a5da99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20509b9e088327201e3fdadc60db28f"><td class="memItemLeft" align="right" valign="top"><a id="aa20509b9e088327201e3fdadc60db28f" name="aa20509b9e088327201e3fdadc60db28f"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>calc_dflags</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> f, bool force)</td></tr>
<tr class="separator:aa20509b9e088327201e3fdadc60db28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f832542ff93a48dfda8c8e08cfe0cf"><td class="memItemLeft" align="right" valign="top"><a id="aa7f832542ff93a48dfda8c8e08cfe0cf" name="aa7f832542ff93a48dfda8c8e08cfe0cf"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_byte</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:aa7f832542ff93a48dfda8c8e08cfe0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to byte. <br /></td></tr>
<tr class="separator:aa7f832542ff93a48dfda8c8e08cfe0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfb9da34afaa2872205987257b682f6"><td class="memItemLeft" align="right" valign="top"><a id="a0bfb9da34afaa2872205987257b682f6" name="a0bfb9da34afaa2872205987257b682f6"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_word</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:a0bfb9da34afaa2872205987257b682f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to word. <br /></td></tr>
<tr class="separator:a0bfb9da34afaa2872205987257b682f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa941e642acc5f769881a9c37c573c3c9"><td class="memItemLeft" align="right" valign="top"><a id="aa941e642acc5f769881a9c37c573c3c9" name="aa941e642acc5f769881a9c37c573c3c9"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_dword</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:aa941e642acc5f769881a9c37c573c3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to dword. <br /></td></tr>
<tr class="separator:aa941e642acc5f769881a9c37c573c3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673bb2e9a80f7a5b7c972ed0357d3d9c"><td class="memItemLeft" align="right" valign="top"><a id="a673bb2e9a80f7a5b7c972ed0357d3d9c" name="a673bb2e9a80f7a5b7c972ed0357d3d9c"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_qword</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:a673bb2e9a80f7a5b7c972ed0357d3d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to quadword. <br /></td></tr>
<tr class="separator:a673bb2e9a80f7a5b7c972ed0357d3d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf1614d46336400f286b2bc9ee8d92c"><td class="memItemLeft" align="right" valign="top"><a id="aaaf1614d46336400f286b2bc9ee8d92c" name="aaaf1614d46336400f286b2bc9ee8d92c"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_oword</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:aaaf1614d46336400f286b2bc9ee8d92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to octaword/xmm word. <br /></td></tr>
<tr class="separator:aaaf1614d46336400f286b2bc9ee8d92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3258ece6856d6a3046ce8152a83b7be3"><td class="memItemLeft" align="right" valign="top"><a id="a3258ece6856d6a3046ce8152a83b7be3" name="a3258ece6856d6a3046ce8152a83b7be3"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_yword</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:a3258ece6856d6a3046ce8152a83b7be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to ymm word. <br /></td></tr>
<tr class="separator:a3258ece6856d6a3046ce8152a83b7be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9535e772efe8e73ff6edb063125537"><td class="memItemLeft" align="right" valign="top"><a id="add9535e772efe8e73ff6edb063125537" name="add9535e772efe8e73ff6edb063125537"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_zword</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:add9535e772efe8e73ff6edb063125537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to zmm word. <br /></td></tr>
<tr class="separator:add9535e772efe8e73ff6edb063125537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53e1b36cbdd6ce7b9842a6cb2854df5"><td class="memItemLeft" align="right" valign="top"><a id="af53e1b36cbdd6ce7b9842a6cb2854df5" name="af53e1b36cbdd6ce7b9842a6cb2854df5"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_tbyte</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:af53e1b36cbdd6ce7b9842a6cb2854df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to tbyte. <br /></td></tr>
<tr class="separator:af53e1b36cbdd6ce7b9842a6cb2854df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab855ae2fbf525f3b6b7d31718da06761"><td class="memItemLeft" align="right" valign="top"><a id="ab855ae2fbf525f3b6b7d31718da06761" name="ab855ae2fbf525f3b6b7d31718da06761"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_float</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:ab855ae2fbf525f3b6b7d31718da06761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to float. <br /></td></tr>
<tr class="separator:ab855ae2fbf525f3b6b7d31718da06761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8697aaaf51ff438a267e5fbfc89b905c"><td class="memItemLeft" align="right" valign="top"><a id="a8697aaaf51ff438a267e5fbfc89b905c" name="a8697aaaf51ff438a267e5fbfc89b905c"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_double</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:a8697aaaf51ff438a267e5fbfc89b905c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to double. <br /></td></tr>
<tr class="separator:a8697aaaf51ff438a267e5fbfc89b905c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5827ab00c569071f712b760f16c2b9b"><td class="memItemLeft" align="right" valign="top"><a id="ac5827ab00c569071f712b760f16c2b9b" name="ac5827ab00c569071f712b760f16c2b9b"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_packed_real</b> (ea_t ea, asize_t length, bool force=false)</td></tr>
<tr class="memdesc:ac5827ab00c569071f712b760f16c2b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to packed decimal real. <br /></td></tr>
<tr class="separator:ac5827ab00c569071f712b760f16c2b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bed069332f48e667b1ca4c7787e99c9"><td class="memItemLeft" align="right" valign="top"><a id="a1bed069332f48e667b1ca4c7787e99c9" name="a1bed069332f48e667b1ca4c7787e99c9"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_struct</b> (ea_t ea, asize_t length, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> tid, bool force=false)</td></tr>
<tr class="memdesc:a1bed069332f48e667b1ca4c7787e99c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to struct. <br /></td></tr>
<tr class="separator:a1bed069332f48e667b1ca4c7787e99c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13bd1caff6f56080ba07fa9e6c7bbb3"><td class="memItemLeft" align="right" valign="top"><a id="ad13bd1caff6f56080ba07fa9e6c7bbb3" name="ad13bd1caff6f56080ba07fa9e6c7bbb3"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>create_custdata</b> (ea_t ea, asize_t length, int dtid, int fid, bool force=false)</td></tr>
<tr class="memdesc:ad13bd1caff6f56080ba07fa9e6c7bbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to custom data type. <br /></td></tr>
<tr class="separator:ad13bd1caff6f56080ba07fa9e6c7bbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558590c540b5f825b138f31d357f0f6a"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a558590c540b5f825b138f31d357f0f6a">create_align</a> (ea_t ea, asize_t length, int alignment)</td></tr>
<tr class="memdesc:a558590c540b5f825b138f31d357f0f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an alignment item.  <a href="bytes_8hpp.html#a558590c540b5f825b138f31d357f0f6a">More...</a><br /></td></tr>
<tr class="separator:a558590c540b5f825b138f31d357f0f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbe5e1ed0c0f7c5141880523c14a46a"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a4bbe5e1ed0c0f7c5141880523c14a46a">calc_min_align</a> (asize_t length)</td></tr>
<tr class="memdesc:a4bbe5e1ed0c0f7c5141880523c14a46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the minimal possible alignment exponent.  <a href="bytes_8hpp.html#a4bbe5e1ed0c0f7c5141880523c14a46a">More...</a><br /></td></tr>
<tr class="separator:a4bbe5e1ed0c0f7c5141880523c14a46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf03a6d16a635ed68c28d57d0c66f2d9"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#abf03a6d16a635ed68c28d57d0c66f2d9">calc_max_align</a> (ea_t endea)</td></tr>
<tr class="memdesc:abf03a6d16a635ed68c28d57d0c66f2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the maximal possible alignment exponent.  <a href="bytes_8hpp.html#abf03a6d16a635ed68c28d57d0c66f2d9">More...</a><br /></td></tr>
<tr class="separator:abf03a6d16a635ed68c28d57d0c66f2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d40bbff5669625ef0b2d033f1257e0c"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a3d40bbff5669625ef0b2d033f1257e0c">calc_def_align</a> (ea_t ea, int mina, int maxa)</td></tr>
<tr class="memdesc:a3d40bbff5669625ef0b2d033f1257e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the default alignment exponent.  <a href="bytes_8hpp.html#a3d40bbff5669625ef0b2d033f1257e0c">More...</a><br /></td></tr>
<tr class="separator:a3d40bbff5669625ef0b2d033f1257e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fded8a83079e589ff8406e1f20148a"><td class="memItemLeft" align="right" valign="top"><a id="af2fded8a83079e589ff8406e1f20148a" name="af2fded8a83079e589ff8406e1f20148a"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>create_16bit_data</b> (ea_t ea, asize_t length)</td></tr>
<tr class="memdesc:af2fded8a83079e589ff8406e1f20148a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to 16-bit quantity (take the byte size into account) <br /></td></tr>
<tr class="separator:af2fded8a83079e589ff8406e1f20148a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b0e11ca8002f2e699a2e1244cafe6d"><td class="memItemLeft" align="right" valign="top"><a id="af2b0e11ca8002f2e699a2e1244cafe6d" name="af2b0e11ca8002f2e699a2e1244cafe6d"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>create_32bit_data</b> (ea_t ea, asize_t length)</td></tr>
<tr class="memdesc:af2b0e11ca8002f2e699a2e1244cafe6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to 32-bit quantity (take the byte size into account) <br /></td></tr>
<tr class="separator:af2b0e11ca8002f2e699a2e1244cafe6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6031bb8d2bad52aa580d438e5f83ed"><td class="memItemLeft" align="right" valign="top">idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a0f6031bb8d2bad52aa580d438e5f83ed">get_max_strlit_length</a> (ea_t ea, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> strtype, int options=0)</td></tr>
<tr class="memdesc:a0f6031bb8d2bad52aa580d438e5f83ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine maximum length of string literal.  <a href="bytes_8hpp.html#a0f6031bb8d2bad52aa580d438e5f83ed">More...</a><br /></td></tr>
<tr class="separator:a0f6031bb8d2bad52aa580d438e5f83ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a576730697d57563c3f83b248bdde7d"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a5a576730697d57563c3f83b248bdde7d">get_strlit_contents</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *utf8, ea_t ea, size_t len, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> type, size_t *maxcps=nullptr, int flags=0)</td></tr>
<tr class="memdesc:a5a576730697d57563c3f83b248bdde7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents of string literal, as UTF-8-encoded codepoints.  <a href="bytes_8hpp.html#a5a576730697d57563c3f83b248bdde7d">More...</a><br /></td></tr>
<tr class="separator:a5a576730697d57563c3f83b248bdde7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7ed03165ef9d8bdc5be53c19bcc634"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#abe7ed03165ef9d8bdc5be53c19bcc634">create_strlit</a> (ea_t start, size_t len, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> strtype)</td></tr>
<tr class="memdesc:abe7ed03165ef9d8bdc5be53c19bcc634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to string literal and give a meaningful name.  <a href="bytes_8hpp.html#abe7ed03165ef9d8bdc5be53c19bcc634">More...</a><br /></td></tr>
<tr class="separator:abe7ed03165ef9d8bdc5be53c19bcc634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940e6115dcc2d8d63a714fbe4301104c"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a940e6115dcc2d8d63a714fbe4301104c">print_strlit_type</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> strtype, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out_tooltip=nullptr, int flags=0)</td></tr>
<tr class="memdesc:a940e6115dcc2d8d63a714fbe4301104c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get string type information: the string type name (possibly decorated with hotkey markers), and the tooltip.  <a href="bytes_8hpp.html#a940e6115dcc2d8d63a714fbe4301104c">More...</a><br /></td></tr>
<tr class="separator:a940e6115dcc2d8d63a714fbe4301104c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c122e3b13ad3e2e99e72d185b44bf78"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="unionopinfo__t.html">opinfo_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a3c122e3b13ad3e2e99e72d185b44bf78">get_opinfo</a> (<a class="el" href="unionopinfo__t.html">opinfo_t</a> *buf, ea_t ea, int n, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> flags)</td></tr>
<tr class="memdesc:a3c122e3b13ad3e2e99e72d185b44bf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get additional information about an operand representation.  <a href="bytes_8hpp.html#a3c122e3b13ad3e2e99e72d185b44bf78">More...</a><br /></td></tr>
<tr class="separator:a3c122e3b13ad3e2e99e72d185b44bf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad090293804afa887dd672aca39d0e68f"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad090293804afa887dd672aca39d0e68f">set_opinfo</a> (ea_t ea, int n, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> flag, const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *ti, bool suppress_events=false)</td></tr>
<tr class="memdesc:ad090293804afa887dd672aca39d0e68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set additional information about an operand representation.  <a href="bytes_8hpp.html#ad090293804afa887dd672aca39d0e68f">More...</a><br /></td></tr>
<tr class="separator:ad090293804afa887dd672aca39d0e68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c89919285ab6251cacbd6809304e81"><td class="memItemLeft" align="right" valign="top">idaman asize_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a04c89919285ab6251cacbd6809304e81">get_data_elsize</a> (ea_t ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *ti=nullptr)</td></tr>
<tr class="memdesc:a04c89919285ab6251cacbd6809304e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of data type specified in flags 'F'.  <a href="bytes_8hpp.html#a04c89919285ab6251cacbd6809304e81">More...</a><br /></td></tr>
<tr class="separator:a04c89919285ab6251cacbd6809304e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33b2f500dc94da7bd34c49291b36b2a"><td class="memItemLeft" align="right" valign="top">asize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#af33b2f500dc94da7bd34c49291b36b2a">get_full_data_elsize</a> (ea_t ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *ti=nullptr)</td></tr>
<tr class="memdesc:af33b2f500dc94da7bd34c49291b36b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full size of data type specified in flags 'F'.  <a href="bytes_8hpp.html#af33b2f500dc94da7bd34c49291b36b2a">More...</a><br /></td></tr>
<tr class="separator:af33b2f500dc94da7bd34c49291b36b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d4739a1733ad860684372bdcef27dd"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a75d4739a1733ad860684372bdcef27dd">is_varsize_item</a> (ea_t ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F, const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *ti=nullptr, asize_t *itemsize=nullptr)</td></tr>
<tr class="memdesc:a75d4739a1733ad860684372bdcef27dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the item at 'ea' variable size?.  <a href="bytes_8hpp.html#a75d4739a1733ad860684372bdcef27dd">More...</a><br /></td></tr>
<tr class="separator:a75d4739a1733ad860684372bdcef27dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be43d5dfbdb42e6a8a9d9012683ac9d"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a5be43d5dfbdb42e6a8a9d9012683ac9d">can_define_item</a> (ea_t ea, asize_t length, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> flags)</td></tr>
<tr class="memdesc:a5be43d5dfbdb42e6a8a9d9012683ac9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can define item (instruction/data) of the specified 'length', starting at 'ea'?  <a href="bytes_8hpp.html#a5be43d5dfbdb42e6a8a9d9012683ac9d">More...</a><br /></td></tr>
<tr class="separator:a5be43d5dfbdb42e6a8a9d9012683ac9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f716423c4bc3265f1ebde10e2c2ac8"><td class="memItemLeft" align="right" valign="top"><a id="a47f716423c4bc3265f1ebde10e2c2ac8" name="a47f716423c4bc3265f1ebde10e2c2ac8"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>has_immd</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a47f716423c4bc3265f1ebde10e2c2ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has immediate value? <br /></td></tr>
<tr class="separator:a47f716423c4bc3265f1ebde10e2c2ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fe29997b3f79ceb9ab2a59c7c236ea"><td class="memItemLeft" align="right" valign="top"><a id="a18fe29997b3f79ceb9ab2a59c7c236ea" name="a18fe29997b3f79ceb9ab2a59c7c236ea"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_func</b> (<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> F)</td></tr>
<tr class="memdesc:a18fe29997b3f79ceb9ab2a59c7c236ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is function start? <br /></td></tr>
<tr class="separator:a18fe29997b3f79ceb9ab2a59c7c236ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560484246ad27da7047675a330cd6ead"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a560484246ad27da7047675a330cd6ead">set_immd</a> (ea_t ea)</td></tr>
<tr class="memdesc:a560484246ad27da7047675a330cd6ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 'has immediate operand' flag.  <a href="bytes_8hpp.html#a560484246ad27da7047675a330cd6ead">More...</a><br /></td></tr>
<tr class="separator:a560484246ad27da7047675a330cd6ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46024f0f75ce338912ff399e45568a7"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ab46024f0f75ce338912ff399e45568a7">register_custom_data_type</a> (const <a class="el" href="structdata__type__t.html">data_type_t</a> *dtinfo)</td></tr>
<tr class="memdesc:ab46024f0f75ce338912ff399e45568a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new data type.  <a href="bytes_8hpp.html#ab46024f0f75ce338912ff399e45568a7">More...</a><br /></td></tr>
<tr class="separator:ab46024f0f75ce338912ff399e45568a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bb8cf4f407f6723a621b2560111f0d"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a39bb8cf4f407f6723a621b2560111f0d">unregister_custom_data_type</a> (int dtid)</td></tr>
<tr class="memdesc:a39bb8cf4f407f6723a621b2560111f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a data type.  <a href="bytes_8hpp.html#a39bb8cf4f407f6723a621b2560111f0d">More...</a><br /></td></tr>
<tr class="separator:a39bb8cf4f407f6723a621b2560111f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910a2755f876fef4d415e7ec88c3a413"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a910a2755f876fef4d415e7ec88c3a413">register_custom_data_format</a> (const <a class="el" href="structdata__format__t.html">data_format_t</a> *dtform)</td></tr>
<tr class="memdesc:a910a2755f876fef4d415e7ec88c3a413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new data format.  <a href="bytes_8hpp.html#a910a2755f876fef4d415e7ec88c3a413">More...</a><br /></td></tr>
<tr class="separator:a910a2755f876fef4d415e7ec88c3a413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad010f7bd1f08140e2e0adc77400fc351"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ad010f7bd1f08140e2e0adc77400fc351">unregister_custom_data_format</a> (int dfid)</td></tr>
<tr class="memdesc:ad010f7bd1f08140e2e0adc77400fc351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a data format.  <a href="bytes_8hpp.html#ad010f7bd1f08140e2e0adc77400fc351">More...</a><br /></td></tr>
<tr class="separator:ad010f7bd1f08140e2e0adc77400fc351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee2e0bd7741d4865153a470887b3076"><td class="memItemLeft" align="right" valign="top">idaman const <a class="el" href="structdata__type__t.html">data_type_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aaee2e0bd7741d4865153a470887b3076">get_custom_data_type</a> (int dtid)</td></tr>
<tr class="memdesc:aaee2e0bd7741d4865153a470887b3076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get definition of a registered custom data type.  <a href="bytes_8hpp.html#aaee2e0bd7741d4865153a470887b3076">More...</a><br /></td></tr>
<tr class="separator:aaee2e0bd7741d4865153a470887b3076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba3b7e3719fd1bd3cb3eb72ada29b17"><td class="memItemLeft" align="right" valign="top">idaman const <a class="el" href="structdata__format__t.html">data_format_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a8ba3b7e3719fd1bd3cb3eb72ada29b17">get_custom_data_format</a> (int dfid)</td></tr>
<tr class="memdesc:a8ba3b7e3719fd1bd3cb3eb72ada29b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get definition of a registered custom data format.  <a href="bytes_8hpp.html#a8ba3b7e3719fd1bd3cb3eb72ada29b17">More...</a><br /></td></tr>
<tr class="separator:a8ba3b7e3719fd1bd3cb3eb72ada29b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5f4c242bc11c2f1441401592fa648e"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a2e5f4c242bc11c2f1441401592fa648e">attach_custom_data_format</a> (int dtid, int dfid)</td></tr>
<tr class="memdesc:a2e5f4c242bc11c2f1441401592fa648e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the data format to the data type.  <a href="bytes_8hpp.html#a2e5f4c242bc11c2f1441401592fa648e">More...</a><br /></td></tr>
<tr class="separator:a2e5f4c242bc11c2f1441401592fa648e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b262984a0e6314cb289f8f3b9957b68"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a2b262984a0e6314cb289f8f3b9957b68">detach_custom_data_format</a> (int dtid, int dfid)</td></tr>
<tr class="memdesc:a2b262984a0e6314cb289f8f3b9957b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the data format from the data type.  <a href="bytes_8hpp.html#a2b262984a0e6314cb289f8f3b9957b68">More...</a><br /></td></tr>
<tr class="separator:a2b262984a0e6314cb289f8f3b9957b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0315f596c2f7dcd5c1730989c42dd5d7"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a0315f596c2f7dcd5c1730989c42dd5d7">is_attached_custom_data_format</a> (int dtid, int dfid)</td></tr>
<tr class="memdesc:a0315f596c2f7dcd5c1730989c42dd5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the custom data format attached to the custom data type?  <a href="bytes_8hpp.html#a0315f596c2f7dcd5c1730989c42dd5d7">More...</a><br /></td></tr>
<tr class="separator:a0315f596c2f7dcd5c1730989c42dd5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8666f9333df700da97c98af645fc714"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ac8666f9333df700da97c98af645fc714">get_custom_data_types</a> (<a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *out, asize_t min_size=0, asize_t max_size=<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a>)</td></tr>
<tr class="memdesc:ac8666f9333df700da97c98af645fc714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of registered custom data type ids.  <a href="bytes_8hpp.html#ac8666f9333df700da97c98af645fc714">More...</a><br /></td></tr>
<tr class="separator:ac8666f9333df700da97c98af645fc714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5791f45da0c6235ad3c8d70dcebcab7b"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a5791f45da0c6235ad3c8d70dcebcab7b">get_custom_data_formats</a> (<a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *out, int dtid)</td></tr>
<tr class="memdesc:a5791f45da0c6235ad3c8d70dcebcab7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of attached custom data formats for the specified data type.  <a href="bytes_8hpp.html#a5791f45da0c6235ad3c8d70dcebcab7b">More...</a><br /></td></tr>
<tr class="separator:a5791f45da0c6235ad3c8d70dcebcab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbe93e51482c28e7425d903f1b951c3"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a2cbe93e51482c28e7425d903f1b951c3">find_custom_data_type</a> (const char *name)</td></tr>
<tr class="memdesc:a2cbe93e51482c28e7425d903f1b951c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get id of a custom data type.  <a href="bytes_8hpp.html#a2cbe93e51482c28e7425d903f1b951c3">More...</a><br /></td></tr>
<tr class="separator:a2cbe93e51482c28e7425d903f1b951c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdcd0ae26d0f832db18f539df334426"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#adfdcd0ae26d0f832db18f539df334426">find_custom_data_format</a> (const char *name)</td></tr>
<tr class="memdesc:adfdcd0ae26d0f832db18f539df334426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get id of a custom data format.  <a href="bytes_8hpp.html#adfdcd0ae26d0f832db18f539df334426">More...</a><br /></td></tr>
<tr class="separator:adfdcd0ae26d0f832db18f539df334426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa59b8ec4df56ac22d47d6bb7624e3b"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#abaa59b8ec4df56ac22d47d6bb7624e3b">set_cmt</a> (ea_t ea, const char *comm, bool rptble)</td></tr>
<tr class="memdesc:abaa59b8ec4df56ac22d47d6bb7624e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an indented comment.  <a href="bytes_8hpp.html#abaa59b8ec4df56ac22d47d6bb7624e3b">More...</a><br /></td></tr>
<tr class="separator:abaa59b8ec4df56ac22d47d6bb7624e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15e5cc5c923b7932b79bb67b3fe54ad"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aa15e5cc5c923b7932b79bb67b3fe54ad">get_cmt</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, ea_t ea, bool rptble)</td></tr>
<tr class="memdesc:aa15e5cc5c923b7932b79bb67b3fe54ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an indented comment.  <a href="bytes_8hpp.html#aa15e5cc5c923b7932b79bb67b3fe54ad">More...</a><br /></td></tr>
<tr class="separator:aa15e5cc5c923b7932b79bb67b3fe54ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8f737249505e8479ccbd92ceb56c30"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#abf8f737249505e8479ccbd92ceb56c30">append_cmt</a> (ea_t ea, const char *str, bool rptble)</td></tr>
<tr class="memdesc:abf8f737249505e8479ccbd92ceb56c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to an indented comment.  <a href="bytes_8hpp.html#abf8f737249505e8479ccbd92ceb56c30">More...</a><br /></td></tr>
<tr class="separator:abf8f737249505e8479ccbd92ceb56c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1663690ac8f4a860526e13d6c3549d"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aea1663690ac8f4a860526e13d6c3549d">get_predef_insn_cmt</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;ins)</td></tr>
<tr class="memdesc:aea1663690ac8f4a860526e13d6c3549d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get predefined comment.  <a href="bytes_8hpp.html#aea1663690ac8f4a860526e13d6c3549d">More...</a><br /></td></tr>
<tr class="separator:aea1663690ac8f4a860526e13d6c3549d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3cbe7931862f0d0c04baa5ecbeef8f"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a5c3cbe7931862f0d0c04baa5ecbeef8f">find_byte</a> (ea_t sEA, asize_t size, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> value, int bin_search_flags)</td></tr>
<tr class="memdesc:a5c3cbe7931862f0d0c04baa5ecbeef8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find forward a byte with the specified value (only 8-bit value from the database).  <a href="bytes_8hpp.html#a5c3cbe7931862f0d0c04baa5ecbeef8f">More...</a><br /></td></tr>
<tr class="separator:a5c3cbe7931862f0d0c04baa5ecbeef8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a70437813c4ca4500a6ba33a74eaeb"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#ae1a70437813c4ca4500a6ba33a74eaeb">find_byter</a> (ea_t sEA, asize_t size, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> value, int bin_search_flags)</td></tr>
<tr class="memdesc:ae1a70437813c4ca4500a6ba33a74eaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find reverse a byte with the specified value (only 8-bit value from the database).  <a href="bytes_8hpp.html#ae1a70437813c4ca4500a6ba33a74eaeb">More...</a><br /></td></tr>
<tr class="separator:ae1a70437813c4ca4500a6ba33a74eaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ccb0986294a9d3bb060ab3699a02fe"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a08ccb0986294a9d3bb060ab3699a02fe">parse_binpat_str</a> (<a class="el" href="classqvector.html">compiled_binpat_vec_t</a> *out, ea_t ea, const char *in, int radix, int strlits_encoding=PBSENC_DEF1BPU, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf=nullptr)</td></tr>
<tr class="memdesc:a08ccb0986294a9d3bb060ab3699a02fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert user-specified binary string to internal representation.  <a href="bytes_8hpp.html#a08ccb0986294a9d3bb060ab3699a02fe">More...</a><br /></td></tr>
<tr class="separator:a08ccb0986294a9d3bb060ab3699a02fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f6ea57cdc1672b7e303aee3485d3e5"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#af2f6ea57cdc1672b7e303aee3485d3e5">bin_search2</a> (ea_t start_ea, ea_t end_ea, const <a class="el" href="classqvector.html">compiled_binpat_vec_t</a> &amp;data, int flags)</td></tr>
<tr class="memdesc:af2f6ea57cdc1672b7e303aee3485d3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a string in the program.  <a href="bytes_8hpp.html#af2f6ea57cdc1672b7e303aee3485d3e5">More...</a><br /></td></tr>
<tr class="separator:af2f6ea57cdc1672b7e303aee3485d3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77031ceba6e59534135734258abaa0b2"><td class="memItemLeft" align="right" valign="top"><a id="a77031ceba6e59534135734258abaa0b2" name="a77031ceba6e59534135734258abaa0b2"></a>
ea_t&#160;</td><td class="memItemRight" valign="bottom"><b>bin_search2</b> (ea_t start_ea, ea_t end_ea, const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *image, const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *mask, size_t len, int flags)</td></tr>
<tr class="separator:a77031ceba6e59534135734258abaa0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c92d3f09ffce89698d6bbea408f9e57"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a5c92d3f09ffce89698d6bbea408f9e57">bin_search3</a> (size_t *out_matched_idx, ea_t start_ea, ea_t end_ea, const <a class="el" href="classqvector.html">compiled_binpat_vec_t</a> &amp;data, int flags)</td></tr>
<tr class="memdesc:a5c92d3f09ffce89698d6bbea408f9e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a patter in the program.  <a href="bytes_8hpp.html#a5c92d3f09ffce89698d6bbea408f9e57">More...</a><br /></td></tr>
<tr class="separator:a5c92d3f09ffce89698d6bbea408f9e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e186d2aabd72c2c20f7be3d56d4299"><td class="memItemLeft" align="right" valign="top"><a id="ac8e186d2aabd72c2c20f7be3d56d4299" name="ac8e186d2aabd72c2c20f7be3d56d4299"></a>
ea_t idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>next_inited</b> (ea_t ea, ea_t maxea)</td></tr>
<tr class="memdesc:ac8e186d2aabd72c2c20f7be3d56d4299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the next initialized address. <br /></td></tr>
<tr class="separator:ac8e186d2aabd72c2c20f7be3d56d4299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7843b7c337d1fe2bb5221f84fbc2a9"><td class="memItemLeft" align="right" valign="top"><a id="a6a7843b7c337d1fe2bb5221f84fbc2a9" name="a6a7843b7c337d1fe2bb5221f84fbc2a9"></a>
ea_t idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>prev_inited</b> (ea_t ea, ea_t minea)</td></tr>
<tr class="memdesc:a6a7843b7c337d1fe2bb5221f84fbc2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the previous initialized address. <br /></td></tr>
<tr class="separator:a6a7843b7c337d1fe2bb5221f84fbc2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abd041353225e8daedd30f5d3df5fa1"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a7abd041353225e8daedd30f5d3df5fa1">equal_bytes</a> (ea_t ea, const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *image, const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *mask, size_t len, int bin_search_flags)</td></tr>
<tr class="memdesc:a7abd041353225e8daedd30f5d3df5fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare 'len' bytes of the program starting from 'ea' with 'image'.  <a href="bytes_8hpp.html#a7abd041353225e8daedd30f5d3df5fa1">More...</a><br /></td></tr>
<tr class="separator:a7abd041353225e8daedd30f5d3df5fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aae4e495c26a8edcf6851556dccb50"><td class="memItemLeft" align="right" valign="top"><a id="a15aae4e495c26a8edcf6851556dccb50" name="a15aae4e495c26a8edcf6851556dccb50"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_match_for_bin_search</b> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> c1, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> c2, const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *mask, int i, int bin_search_flags)</td></tr>
<tr class="separator:a15aae4e495c26a8edcf6851556dccb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2b026ae2fc396277270cf6886ea8e9"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#aab2b026ae2fc396277270cf6886ea8e9">update_hidden_range</a> (const <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ha)</td></tr>
<tr class="memdesc:aab2b026ae2fc396277270cf6886ea8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update hidden range information in the database.  <a href="bytes_8hpp.html#aab2b026ae2fc396277270cf6886ea8e9">More...</a><br /></td></tr>
<tr class="separator:aab2b026ae2fc396277270cf6886ea8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdacd258010c86b3cec5bf75d8c10325"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#abdacd258010c86b3cec5bf75d8c10325">add_hidden_range</a> (ea_t ea1, ea_t ea2, const char *description, const char *header, const char *footer, <a class="el" href="pro_8h.html#a3df5040891132e50157aee66affdf1de">bgcolor_t</a> color=<a class="el" href="pro_8h.html#ae5314b4ed32e86fb438e011ac3046456">DEFCOLOR</a>)</td></tr>
<tr class="memdesc:abdacd258010c86b3cec5bf75d8c10325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a range of addresses as hidden.  <a href="bytes_8hpp.html#abdacd258010c86b3cec5bf75d8c10325">More...</a><br /></td></tr>
<tr class="separator:abdacd258010c86b3cec5bf75d8c10325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a8e71d01b4b30e9f7d9597d4f93a42"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a59a8e71d01b4b30e9f7d9597d4f93a42">get_hidden_range</a> (ea_t ea)</td></tr>
<tr class="memdesc:a59a8e71d01b4b30e9f7d9597d4f93a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to hidden range structure, in: linear address.  <a href="bytes_8hpp.html#a59a8e71d01b4b30e9f7d9597d4f93a42">More...</a><br /></td></tr>
<tr class="separator:a59a8e71d01b4b30e9f7d9597d4f93a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef60757079f9eb363c45c358c1c6a6a"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#acef60757079f9eb363c45c358c1c6a6a">getn_hidden_range</a> (int n)</td></tr>
<tr class="memdesc:acef60757079f9eb363c45c358c1c6a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to hidden range structure, in: number of hidden range.  <a href="bytes_8hpp.html#acef60757079f9eb363c45c358c1c6a6a">More...</a><br /></td></tr>
<tr class="separator:acef60757079f9eb363c45c358c1c6a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c3b9d45c445392f73390e90ab7a626"><td class="memItemLeft" align="right" valign="top"><a id="a76c3b9d45c445392f73390e90ab7a626" name="a76c3b9d45c445392f73390e90ab7a626"></a>
idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_hidden_range_qty</b> (void)</td></tr>
<tr class="memdesc:a76c3b9d45c445392f73390e90ab7a626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of hidden ranges. <br /></td></tr>
<tr class="separator:a76c3b9d45c445392f73390e90ab7a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850f8f6a36d4011137a485d37057043f"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a850f8f6a36d4011137a485d37057043f">get_hidden_range_num</a> (ea_t ea)</td></tr>
<tr class="memdesc:a850f8f6a36d4011137a485d37057043f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of a hidden range.  <a href="bytes_8hpp.html#a850f8f6a36d4011137a485d37057043f">More...</a><br /></td></tr>
<tr class="separator:a850f8f6a36d4011137a485d37057043f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea70d119ab45b415f1a348e4464e154"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a6ea70d119ab45b415f1a348e4464e154">get_prev_hidden_range</a> (ea_t ea)</td></tr>
<tr class="memdesc:a6ea70d119ab45b415f1a348e4464e154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to previous hidden range.  <a href="bytes_8hpp.html#a6ea70d119ab45b415f1a348e4464e154">More...</a><br /></td></tr>
<tr class="separator:a6ea70d119ab45b415f1a348e4464e154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8808375270809d346e439263556f18"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a1f8808375270809d346e439263556f18">get_next_hidden_range</a> (ea_t ea)</td></tr>
<tr class="memdesc:a1f8808375270809d346e439263556f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to next hidden range.  <a href="bytes_8hpp.html#a1f8808375270809d346e439263556f18">More...</a><br /></td></tr>
<tr class="separator:a1f8808375270809d346e439263556f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1707d96152599b58af01663b532cf8c4"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a1707d96152599b58af01663b532cf8c4">get_first_hidden_range</a> (void)</td></tr>
<tr class="memdesc:a1707d96152599b58af01663b532cf8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the first hidden range.  <a href="bytes_8hpp.html#a1707d96152599b58af01663b532cf8c4">More...</a><br /></td></tr>
<tr class="separator:a1707d96152599b58af01663b532cf8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10378de520789a96f670f0754947933b"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a10378de520789a96f670f0754947933b">get_last_hidden_range</a> (void)</td></tr>
<tr class="memdesc:a10378de520789a96f670f0754947933b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the last hidden range.  <a href="bytes_8hpp.html#a10378de520789a96f670f0754947933b">More...</a><br /></td></tr>
<tr class="separator:a10378de520789a96f670f0754947933b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dba106583971df2820c92c3a15d0ba1"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a0dba106583971df2820c92c3a15d0ba1">del_hidden_range</a> (ea_t ea)</td></tr>
<tr class="memdesc:a0dba106583971df2820c92c3a15d0ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete hidden range.  <a href="bytes_8hpp.html#a0dba106583971df2820c92c3a15d0ba1">More...</a><br /></td></tr>
<tr class="separator:a0dba106583971df2820c92c3a15d0ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7487b1a4c03cdb4c120b9da41d63f501"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a7487b1a4c03cdb4c120b9da41d63f501">add_mapping</a> (ea_t from, ea_t to, asize_t size)</td></tr>
<tr class="memdesc:a7487b1a4c03cdb4c120b9da41d63f501"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDA supports memory mapping.  <a href="bytes_8hpp.html#a7487b1a4c03cdb4c120b9da41d63f501">More...</a><br /></td></tr>
<tr class="separator:a7487b1a4c03cdb4c120b9da41d63f501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a61ab7c936a56bce543eecb5ae4dcf"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#af7a61ab7c936a56bce543eecb5ae4dcf">del_mapping</a> (ea_t ea)</td></tr>
<tr class="memdesc:af7a61ab7c936a56bce543eecb5ae4dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete memory mapping range.  <a href="bytes_8hpp.html#af7a61ab7c936a56bce543eecb5ae4dcf">More...</a><br /></td></tr>
<tr class="separator:af7a61ab7c936a56bce543eecb5ae4dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122b5b37703401df0a05c0538ef2c6e"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a2122b5b37703401df0a05c0538ef2c6e">use_mapping</a> (ea_t ea)</td></tr>
<tr class="memdesc:a2122b5b37703401df0a05c0538ef2c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate address according to current mappings.  <a href="bytes_8hpp.html#a2122b5b37703401df0a05c0538ef2c6e">More...</a><br /></td></tr>
<tr class="separator:a2122b5b37703401df0a05c0538ef2c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33007784af2c955b57ebda8caa8d51b5"><td class="memItemLeft" align="right" valign="top"><a id="a33007784af2c955b57ebda8caa8d51b5" name="a33007784af2c955b57ebda8caa8d51b5"></a>
idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_mappings_qty</b> (void)</td></tr>
<tr class="memdesc:a33007784af2c955b57ebda8caa8d51b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of mappings. <br /></td></tr>
<tr class="separator:a33007784af2c955b57ebda8caa8d51b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33af98c88580e234b2f8bf7b6b878578"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bytes_8hpp.html#a33af98c88580e234b2f8bf7b6b878578">get_mapping</a> (ea_t *from, ea_t *to, asize_t *size, size_t n)</td></tr>
<tr class="memdesc:a33af98c88580e234b2f8bf7b6b878578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory mapping range by its number.  <a href="bytes_8hpp.html#a33af98c88580e234b2f8bf7b6b878578">More...</a><br /></td></tr>
<tr class="separator:a33af98c88580e234b2f8bf7b6b878578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f951ff1e64ef2ce0eaf8bb659611a2"><td class="memItemLeft" align="right" valign="top"><a id="a63f951ff1e64ef2ce0eaf8bb659611a2" name="a63f951ff1e64ef2ce0eaf8bb659611a2"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_hex_string</b> (char *buf, size_t bufsize, const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *bytes, size_t len)</td></tr>
<tr class="separator:a63f951ff1e64ef2ce0eaf8bb659611a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Contains functions that deal with individual byte characteristics. </p>
<p >Each byte of the disassembled program is represented by a 32-bit value. We will call this value 'flags'. The structure of the flags is here.</p>
<p >You are not allowed to inspect individual bits of flags and modify them directly. Use special functions to inspect and/or modify flags.</p>
<p >Flags are kept in a virtual array file (*.id1). Addresses (ea) are all 32-bit (or 64-bit) quantities. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="acd4b59c6b40268ce8458dd8ac3943744" name="acd4b59c6b40268ce8458dd8ac3943744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4b59c6b40268ce8458dd8ac3943744">&#9670;&nbsp;</a></span>ITEM_END_INITED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITEM_END_INITED&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stop when initialization changes i.e. </p>
<ul>
<li>if is_loaded(ea): stop if uninitialized byte is encountered</li>
<li>if !is_loaded(ea): stop if initialized byte is encountered </li>
</ul>

</div>
</div>
<a id="a3d17030d2a562f8b77e1d346d1d70c5f" name="a3d17030d2a562f8b77e1d346d1d70c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d17030d2a562f8b77e1d346d1d70c5f">&#9670;&nbsp;</a></span>GFE_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GFE_VALUE&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get flags with <a class="el" href="bytes_8hpp.html#aee726806a07a06c9a7dcba795485e11c" title="Byte has value ?">FF_IVL</a> &amp; <a class="el" href="bytes_8hpp.html#ad190bb3962a654369210c8e14e23aa09" title="Mask for byte value.">MS_VAL</a>. </p>
<p >It is much slower under remote debugging because the kernel needs to read the process memory. </p>

</div>
</div>
<a id="af079bca6c1e74b1cba97a6b8a6d3b648" name="af079bca6c1e74b1cba97a6b8a6d3b648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af079bca6c1e74b1cba97a6b8a6d3b648">&#9670;&nbsp;</a></span>GFE_IDB_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GFE_IDB_VALUE&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get flags with <a class="el" href="bytes_8hpp.html#aee726806a07a06c9a7dcba795485e11c" title="Byte has value ?">FF_IVL</a> &amp; <a class="el" href="bytes_8hpp.html#ad190bb3962a654369210c8e14e23aa09" title="Mask for byte value.">MS_VAL</a>. </p>
<p >but never use the debugger memory. </p>

</div>
</div>
<a id="a22b692b10e0343910ae487c7b16be500" name="a22b692b10e0343910ae487c7b16be500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b692b10e0343910ae487c7b16be500">&#9670;&nbsp;</a></span>DELIT_EXPAND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DELIT_EXPAND&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>propagate undefined items; for example if removing an instruction removes all references to the next instruction, then plan to convert to unexplored the next instruction too. </p>

</div>
</div>
<a id="aa25f19f8244498e366ee6d4e67c1f87f" name="aa25f19f8244498e366ee6d4e67c1f87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25f19f8244498e366ee6d4e67c1f87f">&#9670;&nbsp;</a></span>DELIT_DELNAMES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DELIT_DELNAMES&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delete any names at the specified address range (except for the starting address). </p>
<p >this bit is valid if nbytes &gt; 1 </p>

</div>
</div>
<a id="a961a68bf588417b7af6b18f1e06a3188" name="a961a68bf588417b7af6b18f1e06a3188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961a68bf588417b7af6b18f1e06a3188">&#9670;&nbsp;</a></span>DELIT_NOUNAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DELIT_NOUNAME&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reject to delete if a user name is in address range (except for the starting address). </p>
<p >this bit is valid if nbytes &gt; 1 </p>

</div>
</div>
<a id="a9449948e27d8358dfc5675a91af223c2" name="a9449948e27d8358dfc5675a91af223c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9449948e27d8358dfc5675a91af223c2">&#9670;&nbsp;</a></span>DELIT_NOCMT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DELIT_NOCMT&#160;&#160;&#160;0x0010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reject to delete if a comment is in address range (except for the starting address). </p>
<p >this bit is valid if nbytes &gt; 1 </p>

</div>
</div>
<a id="a88cccdca4c55b3979526fa54491accf0" name="a88cccdca4c55b3979526fa54491accf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cccdca4c55b3979526fa54491accf0">&#9670;&nbsp;</a></span>DELIT_KEEPFUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DELIT_KEEPFUNC&#160;&#160;&#160;0x0020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>do not undefine the function start. </p>
<p >Just delete xrefs, ops e.t.c. </p>

</div>
</div>
<a id="ae3ff56ce8ed4030acdca9d9314038dfb" name="ae3ff56ce8ed4030acdca9d9314038dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ff56ce8ed4030acdca9d9314038dfb">&#9670;&nbsp;</a></span>OPND_OUTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPND_OUTER&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>outer offset base (combined with operand number). </p>
<p >used only in set, get, del_offset() functions </p>

</div>
</div>
<a id="ab515dd7718288c757c1cba570a710896" name="ab515dd7718288c757c1cba570a710896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515dd7718288c757c1cba570a710896">&#9670;&nbsp;</a></span>ALOPT_IGNHEADS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALOPT_IGNHEADS&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>don't stop if another data item is encountered. </p>
<p >only the byte values will be used to determine the string length. if not set, a defined data item or instruction will truncate the string </p>

</div>
</div>
<a id="a2d5c3c90be522fb41e6fdac5b5f31116" name="a2d5c3c90be522fb41e6fdac5b5f31116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5c3c90be522fb41e6fdac5b5f31116">&#9670;&nbsp;</a></span>ALOPT_ONLYTERM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALOPT_ONLYTERM&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>only the termination characters can be at the string end. </p>
<p >Without this option illegal characters also terminate the string. </p>

</div>
</div>
<a id="a71b144490a5e9652704222ac2b636d4c" name="a71b144490a5e9652704222ac2b636d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b144490a5e9652704222ac2b636d4c">&#9670;&nbsp;</a></span>GET_ITEM_HEAD_BODY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_ITEM_HEAD_BODY</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">if</span> ( <a class="code hl_function" href="bytes_8hpp.html#a3b50d7414beff1932b552865b365722e">is_tail</a>(<a class="code hl_function" href="bytes_8hpp.html#abdd753c28e511662d2dfc0c067aca6a5">get_flags</a>(ea)) ) \</div>
<div class="line">    ea = <a class="code hl_function" href="bytes_8hpp.html#a5e7388e6b8b1ed7dc4bc377bb74dcf72">prev_not_tail</a>(ea);     \</div>
<div class="line">  return ea;</div>
<div class="ttc" id="abytes_8hpp_html_a3b50d7414beff1932b552865b365722e"><div class="ttname"><a href="bytes_8hpp.html#a3b50d7414beff1932b552865b365722e">is_tail</a></div><div class="ttdeci">THREAD_SAFE bool idaapi is_tail(flags64_t F)</div><div class="ttdoc">Does flag denote tail byte?</div><div class="ttdef"><b>Definition:</b> bytes.hpp:778</div></div>
<div class="ttc" id="abytes_8hpp_html_a5e7388e6b8b1ed7dc4bc377bb74dcf72"><div class="ttname"><a href="bytes_8hpp.html#a5e7388e6b8b1ed7dc4bc377bb74dcf72">prev_not_tail</a></div><div class="ttdeci">idaman ea_t ida_export prev_not_tail(ea_t ea)</div><div class="ttdoc">Get address of previous non-tail byte.</div></div>
<div class="ttc" id="abytes_8hpp_html_abdd753c28e511662d2dfc0c067aca6a5"><div class="ttname"><a href="bytes_8hpp.html#abdd753c28e511662d2dfc0c067aca6a5">get_flags</a></div><div class="ttdeci">flags64_t idaapi get_flags(ea_t ea)</div><div class="ttdoc">get flags with FF_IVL &amp; MS_VAL.</div><div class="ttdef"><b>Definition:</b> bytes.hpp:286</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a65aceba8ff4d52c9ebc9e6ee39a57515" name="a65aceba8ff4d52c9ebc9e6ee39a57515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65aceba8ff4d52c9ebc9e6ee39a57515">&#9670;&nbsp;</a></span>enable_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export enable_flags </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>end_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ida_8hpp.html#ac437eddfbf695e39512a625d8bcf94c9">storage_type_t</a>&#160;</td>
          <td class="paramname"><em>stt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate flags for address range. </p>
<p >This function does not change the storage type of existing ranges. Exit with an error message if not enough disk space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>should be lower than end_ea. </td></tr>
    <tr><td class="paramname">end_ea</td><td>does not belong to the range. </td></tr>
    <tr><td class="paramname">stt</td><td><a class="el" href="ida_8hpp.html#ac437eddfbf695e39512a625d8bcf94c9" title="Storage types for flag bits.">storage_type_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if ok, otherwise an error code </dd></dl>

</div>
</div>
<a id="a8bc5e1d82712ed05774378545c468757" name="a8bc5e1d82712ed05774378545c468757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc5e1d82712ed05774378545c468757">&#9670;&nbsp;</a></span>disable_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export disable_flags </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>end_ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate flags for address range. </p>
<p >Exit with an error message if not enough disk space (this may occur too). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>should be lower than end_ea. </td></tr>
    <tr><td class="paramname">end_ea</td><td>does not belong to the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if ok, otherwise return error code </dd></dl>

</div>
</div>
<a id="af68e23a2cf2a6befa42bb48693b89aa2" name="af68e23a2cf2a6befa42bb48693b89aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68e23a2cf2a6befa42bb48693b89aa2">&#9670;&nbsp;</a></span>change_storage_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export change_storage_type </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>end_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ida_8hpp.html#ac437eddfbf695e39512a625d8bcf94c9">storage_type_t</a>&#160;</td>
          <td class="paramname"><em>stt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change flag storage type for address range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>should be lower than end_ea. </td></tr>
    <tr><td class="paramname">end_ea</td><td>does not belong to the range. </td></tr>
    <tr><td class="paramname">stt</td><td><a class="el" href="ida_8hpp.html#ac437eddfbf695e39512a625d8bcf94c9" title="Storage types for flag bits.">storage_type_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a id="a17500720aed6570f7ae22f683bfa2be5" name="a17500720aed6570f7ae22f683bfa2be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17500720aed6570f7ae22f683bfa2be5">&#9670;&nbsp;</a></span>next_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export next_addr </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next address in the program (i.e. </p>
<p >next address which has flags). </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if no such address exist. </dd></dl>

</div>
</div>
<a id="a5d97557521f544efbaef7054a92b341f" name="a5d97557521f544efbaef7054a92b341f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d97557521f544efbaef7054a92b341f">&#9670;&nbsp;</a></span>prev_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export prev_addr </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get previous address in the program. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if no such address exist. </dd></dl>

</div>
</div>
<a id="ac9d3eeadd3381eec7751e5692153c0b0" name="ac9d3eeadd3381eec7751e5692153c0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d3eeadd3381eec7751e5692153c0b0">&#9670;&nbsp;</a></span>next_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export next_chunk </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first address of next contiguous chunk in the program. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if next chunk doesn't exist. </dd></dl>

</div>
</div>
<a id="afa31a0226a82fce1a1a916ee297862d8" name="afa31a0226a82fce1a1a916ee297862d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa31a0226a82fce1a1a916ee297862d8">&#9670;&nbsp;</a></span>prev_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export prev_chunk </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last address of previous contiguous chunk in the program. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if previous chunk doesn't exist. </dd></dl>

</div>
</div>
<a id="abbd0f2cd0f755bc4926b9c8eb7bfcbc3" name="abbd0f2cd0f755bc4926b9c8eb7bfcbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd0f2cd0f755bc4926b9c8eb7bfcbc3">&#9670;&nbsp;</a></span>chunk_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export chunk_start </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get start of the contiguous address block containing 'ea'. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if 'ea' doesn't belong to the program. </dd></dl>

</div>
</div>
<a id="a70d130a713d9931620af352d45d85a1d" name="a70d130a713d9931620af352d45d85a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d130a713d9931620af352d45d85a1d">&#9670;&nbsp;</a></span>chunk_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman asize_t ida_export chunk_size </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of the contiguous address block containing 'ea'. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if 'ea' doesn't belong to the program. </dd></dl>

</div>
</div>
<a id="ad6e96596f4ff633104dc88e05559526b" name="ad6e96596f4ff633104dc88e05559526b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e96596f4ff633104dc88e05559526b">&#9670;&nbsp;</a></span>find_free_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export find_free_chunk </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a hole in the addressing space of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Address to start searching from </td></tr>
    <tr><td class="paramname">size</td><td>Size of the desired empty range </td></tr>
    <tr><td class="paramname">alignment</td><td>Alignment bitmask, must be a pow2-1. (for example, 0xF would align the returned range to 16 bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Start of the found empty range or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> </dd></dl>

</div>
</div>
<a id="acbed8e273e00e37da0acaa1a39bebe4a" name="acbed8e273e00e37da0acaa1a39bebe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbed8e273e00e37da0acaa1a39bebe4a">&#9670;&nbsp;</a></span>next_that()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export next_that </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>maxea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bytes_8hpp.html#ad5185f9d189b9af5cbf47bdbaa3888eb">testf_t</a> *&#160;</td>
          <td class="paramname"><em>testf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find next address with a flag satisfying the function 'testf'. </p>
<dl class="section note"><dt>Note</dt><dd>do not pass <a class="el" href="bytes_8hpp.html#aa1574e15547e558eb739088e5f3f3ce6" title="Does flag denote unexplored byte?">is_unknown()</a> to this function to find unexplored bytes. It will fail under the debugger. To find unexplored bytes, use <a class="el" href="bytes_8hpp.html#a579bb032b20e7777b40975763c4dfd8e" title="Similar to next_that(), but will find the next address that is unexplored.">next_unknown()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>start searching at this address + 1 </td></tr>
    <tr><td class="paramname">maxea</td><td>not included in the search range. </td></tr>
    <tr><td class="paramname">testf</td><td>test function to find next address </td></tr>
    <tr><td class="paramname">ud</td><td>user data - may point to anything. it will be passed to testf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found address or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>. </dd></dl>

</div>
</div>
<a id="a4ed0dfef3c1ad728e3aa06ea077ba982" name="a4ed0dfef3c1ad728e3aa06ea077ba982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed0dfef3c1ad728e3aa06ea077ba982">&#9670;&nbsp;</a></span>prev_that()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export prev_that </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>minea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bytes_8hpp.html#ad5185f9d189b9af5cbf47bdbaa3888eb">testf_t</a> *&#160;</td>
          <td class="paramname"><em>testf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find previous address with a flag satisfying the function 'testf'. </p>
<dl class="section note"><dt>Note</dt><dd>do not pass <a class="el" href="bytes_8hpp.html#aa1574e15547e558eb739088e5f3f3ce6" title="Does flag denote unexplored byte?">is_unknown()</a> to this function to find unexplored bytes It will fail under the debugger. To find unexplored bytes, use <a class="el" href="bytes_8hpp.html#a22bf55c03c21d1950b755e500576f3aa" title="Similar to prev_that(), but will find the previous address that is unexplored.">prev_unknown()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>start searching from this address - 1. </td></tr>
    <tr><td class="paramname">minea</td><td>included in the search range. </td></tr>
    <tr><td class="paramname">testf</td><td>test function to find previous address </td></tr>
    <tr><td class="paramname">ud</td><td>user data - may point to anything. it will be passed to testf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the found address or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>. </dd></dl>

</div>
</div>
<a id="a043acfcdbffac18739612799b53d0171" name="a043acfcdbffac18739612799b53d0171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043acfcdbffac18739612799b53d0171">&#9670;&nbsp;</a></span>prev_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export prev_head </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>minea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get start of previous defined item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>begin search at this address </td></tr>
    <tr><td class="paramname">minea</td><td>included in the search range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if none exists. </dd></dl>

</div>
</div>
<a id="ad518592ca7940ed8b019ed4d35661287" name="ad518592ca7940ed8b019ed4d35661287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad518592ca7940ed8b019ed4d35661287">&#9670;&nbsp;</a></span>next_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export next_head </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>maxea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get start of next defined item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>begin search at this address </td></tr>
    <tr><td class="paramname">maxea</td><td>not included in the search range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if none exists. </dd></dl>

</div>
</div>
<a id="a5e7388e6b8b1ed7dc4bc377bb74dcf72" name="a5e7388e6b8b1ed7dc4bc377bb74dcf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7388e6b8b1ed7dc4bc377bb74dcf72">&#9670;&nbsp;</a></span>prev_not_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export prev_not_tail </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address of previous non-tail byte. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if none exists. </dd></dl>

</div>
</div>
<a id="ae3da655e70ee8cf9f4d4bdfd5fda1af7" name="ae3da655e70ee8cf9f4d4bdfd5fda1af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3da655e70ee8cf9f4d4bdfd5fda1af7">&#9670;&nbsp;</a></span>next_not_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export next_not_tail </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address of next non-tail byte. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if none exists. </dd></dl>

</div>
</div>
<a id="a346f18163e4b8852a60b42dc399c6c11" name="a346f18163e4b8852a60b42dc399c6c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346f18163e4b8852a60b42dc399c6c11">&#9670;&nbsp;</a></span>adjust_visea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ea_t adjust_visea </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the address and get the nearest visible address. </p>
<p >(i.e. an address which will appear in the disassembly) </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> only if no addresses are valid </dd></dl>

</div>
</div>
<a id="a58d617220c6ce6bd182ec26a11d952a6" name="a58d617220c6ce6bd182ec26a11d952a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d617220c6ce6bd182ec26a11d952a6">&#9670;&nbsp;</a></span>prev_visea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export prev_visea </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get previous visible address. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if none exists. </dd></dl>

</div>
</div>
<a id="aa9cbe4f435300c277e90fb04208debe0" name="aa9cbe4f435300c277e90fb04208debe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cbe4f435300c277e90fb04208debe0">&#9670;&nbsp;</a></span>next_visea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export next_visea </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next visible address. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if none exists. </dd></dl>

</div>
</div>
<a id="a044e286f44e046227a1f3d9706dfd271" name="a044e286f44e046227a1f3d9706dfd271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044e286f44e046227a1f3d9706dfd271">&#9670;&nbsp;</a></span>get_item_head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ea_t idaapi get_item_head </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the start address of the item at 'ea'. </p>
<p >If there is no current item, then 'ea' will be returned (see definition at the end of <a class="el" href="bytes_8hpp.html" title="Contains functions that deal with individual byte characteristics.">bytes.hpp</a> source) </p>

</div>
</div>
<a id="ac187ddfe69e383fd2398ad9a0545cd40" name="ac187ddfe69e383fd2398ad9a0545cd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac187ddfe69e383fd2398ad9a0545cd40">&#9670;&nbsp;</a></span>get_item_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_item_end </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the end address of the item at 'ea'. </p>
<p >The returned address doesn't belong to the current item. Unexplored bytes are counted as 1 byte entities. </p>

</div>
</div>
<a id="ab8309ae0c7eaca34bdd287da8efdabef" name="ab8309ae0c7eaca34bdd287da8efdabef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8309ae0c7eaca34bdd287da8efdabef">&#9670;&nbsp;</a></span>calc_max_item_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export calc_max_item_end </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>how</em> = <code>15</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate maximal reasonable end address of a new item. </p>
<p >This function will limit the item with the current segment bounds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">how</td><td>when to stop the search. A combination of <a class="el" href="group___i_t_e_m___e_n_d__.html">Item end search flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end of new item. If it is not possible to create an item, it will return 'ea'. </dd></dl>

</div>
</div>
<a id="a34792242834806a65b5f3be1036bf516" name="a34792242834806a65b5f3be1036bf516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34792242834806a65b5f3be1036bf516">&#9670;&nbsp;</a></span>get_item_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asize_t get_item_size </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of item (instruction/data) in bytes. </p>
<p >Unexplored bytes have length of 1 byte. This function returns 0 only for BADADDR. </p>

</div>
</div>
<a id="abdd753c28e511662d2dfc0c067aca6a5" name="abdd753c28e511662d2dfc0c067aca6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd753c28e511662d2dfc0c067aca6a5">&#9670;&nbsp;</a></span>get_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi get_flags </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get flags with <a class="el" href="bytes_8hpp.html#aee726806a07a06c9a7dcba795485e11c" title="Byte has value ?">FF_IVL</a> &amp; <a class="el" href="bytes_8hpp.html#ad190bb3962a654369210c8e14e23aa09" title="Mask for byte value.">MS_VAL</a>. </p>
<p >It is much slower under remote debugging because the kernel needs to read the process memory. </p>

</div>
</div>
<a id="a4bf1a84e4214394dd94de375c532b576" name="a4bf1a84e4214394dd94de375c532b576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf1a84e4214394dd94de375c532b576">&#9670;&nbsp;</a></span>get_full_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi get_full_flags </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get flags value for address 'ea'. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if address is not present in the program </dd></dl>

</div>
</div>
<a id="a521642616ea4f0238d7602780d7c58ec" name="a521642616ea4f0238d7602780d7c58ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521642616ea4f0238d7602780d7c58ec">&#9670;&nbsp;</a></span>get_item_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export get_item_flag </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appzero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flag of the item at 'ea' even if it is a tail byte of some array or structure. </p>
<p >This function is used to get flags of structure members or array elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>linear address of the instruction which refers to 'ea' </td></tr>
    <tr><td class="paramname">n</td><td>operand number which refers to 'ea' or OPND_ALL for one of the operands </td></tr>
    <tr><td class="paramname">ea</td><td>the referenced address </td></tr>
    <tr><td class="paramname">appzero</td><td>append a struct field name if the field offset is zero? meaningful only if the name refers to a structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>flags or 0 (if failed) </dd></dl>

</div>
</div>
<a id="a412b10a79f596eb2e18c6c42e9ed5fed" name="a412b10a79f596eb2e18c6c42e9ed5fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412b10a79f596eb2e18c6c42e9ed5fed">&#9670;&nbsp;</a></span>get_item_refinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export get_item_refinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrefinfo__t.html">refinfo_t</a> *&#160;</td>
          <td class="paramname"><em>ri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get refinfo of the item at 'ea'. </p>
<p >This function works for a regular offset operand as well as for a tail byte of a structure variable (in this case refinfo to corresponding structure member will be returned) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ri</td><td>refinfo holder </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ea</td><td>the item address </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>operand number which refers to 'ea' or OPND_ALL for one of the operands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ad8d9631e3d05e66cdcf761c56127bbb0" name="ad8d9631e3d05e66cdcf761c56127bbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d9631e3d05e66cdcf761c56127bbb0">&#9670;&nbsp;</a></span>del_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export del_value </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete byte value from flags. </p>
<p >The corresponding byte becomes uninitialized. </p>

</div>
</div>
<a id="acc205e32314437fc526186f33867bdf2" name="acc205e32314437fc526186f33867bdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc205e32314437fc526186f33867bdf2">&#9670;&nbsp;</a></span>nbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export nbits </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of bits in a byte at the given address. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structprocessor__t.html#a94c90b8e3ee733f9f843fc6297bd1977" title="Number of bits in a byte for non-code segments (usually 8).">processor_t::dnbits()</a> if the address doesn't belong to a segment, otherwise the result depends on the segment type </dd></dl>

</div>
</div>
<a id="a06299d4eec6753242edc18605abc33e4" name="a06299d4eec6753242edc18605abc33e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06299d4eec6753242edc18605abc33e4">&#9670;&nbsp;</a></span>get_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> ida_export get_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one byte (8-bit) of the program at 'ea'. </p>
<p >This function works only for 8bit byte processors. </p>

</div>
</div>
<a id="a3087f886cfc0dfb455ee306a56134fd9" name="a3087f886cfc0dfb455ee306a56134fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3087f886cfc0dfb455ee306a56134fd9">&#9670;&nbsp;</a></span>get_db_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> ida_export get_db_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one byte (8-bit) of the program at 'ea' from the database. </p>
<p >Works even if the debugger is active. See also <a class="el" href="dbg_8hpp.html#a958b01996985f334aff761e73a918150" title="Get one byte of the debugged process memory.">get_dbg_byte()</a> to read the process memory directly. This function works only for 8bit byte processors. </p>

</div>
</div>
<a id="a1fd70a4257a8fea2c4efc4d9d54e1684" name="a1fd70a4257a8fea2c4efc4d9d54e1684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd70a4257a8fea2c4efc4d9d54e1684">&#9670;&nbsp;</a></span>get_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> ida_export get_word </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one word (16-bit) of the program at 'ea'. </p>
<p >This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. </p>

</div>
</div>
<a id="acf321ff9471e7096e0664f5eb2691ddb" name="acf321ff9471e7096e0664f5eb2691ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf321ff9471e7096e0664f5eb2691ddb">&#9670;&nbsp;</a></span>get_dword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export get_dword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one dword (32-bit) of the program at 'ea'. </p>
<p >This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. </p>

</div>
</div>
<a id="a96f04d044e6ad886568d17ef2d0cac11" name="a96f04d044e6ad886568d17ef2d0cac11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f04d044e6ad886568d17ef2d0cac11">&#9670;&nbsp;</a></span>get_qword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_qword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one qword (64-bit) of the program at 'ea'. </p>
<p >This function takes into account order of bytes specified in idainfo::is_be() This function works only for 8bit byte processors. </p>

</div>
</div>
<a id="ad40de3d071cd123794b60f9cb9bb6c1f" name="ad40de3d071cd123794b60f9cb9bb6c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40de3d071cd123794b60f9cb9bb6c1f">&#9670;&nbsp;</a></span>get_wide_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_wide_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one wide byte of the program at 'ea'. </p>
<p >Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. </p>

</div>
</div>
<a id="afdf36b6506cc50142a0f3501223e5e1b" name="afdf36b6506cc50142a0f3501223e5e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf36b6506cc50142a0f3501223e5e1b">&#9670;&nbsp;</a></span>get_wide_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_wide_word </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get one wide word (2 'byte') of the program at 'ea'. </p>
<p >Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. This function takes into account order of bytes specified in idainfo::is_be() </p>

</div>
</div>
<a id="a8ef2fe75eeacd4443379e4569bc7ec09" name="a8ef2fe75eeacd4443379e4569bc7ec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef2fe75eeacd4443379e4569bc7ec09">&#9670;&nbsp;</a></span>get_wide_dword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_wide_dword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get two wide words (4 'bytes') of the program at 'ea'. </p>
<p >Some processors may access more than 8bit quantity at an address. These processors have 32-bit byte organization from the IDA's point of view. This function takes into account order of bytes specified in idainfo::is_be() </p><dl class="section note"><dt>Note</dt><dd>this function works incorrectly if processor_t::nbits &gt; 16 </dd></dl>

</div>
</div>
<a id="a04a52c1d3f9a1e4c08f8deabe40e4a1b" name="a04a52c1d3f9a1e4c08f8deabe40e4a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a52c1d3f9a1e4c08f8deabe40e4a1b">&#9670;&nbsp;</a></span>get_16bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export get_16bit </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get 16bits of the program at 'ea'. </p>
<dl class="section return"><dt>Returns</dt><dd>1 byte (getFullByte()) if the current processor has 16-bit byte, otherwise return <a class="el" href="bytes_8hpp.html#a1fd70a4257a8fea2c4efc4d9d54e1684" title="Get one word (16-bit) of the program at &#39;ea&#39;.">get_word()</a> </dd></dl>

</div>
</div>
<a id="a07f8cb0a2a422519ffd6f0e3f74c9fcf" name="a07f8cb0a2a422519ffd6f0e3f74c9fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f8cb0a2a422519ffd6f0e3f74c9fcf">&#9670;&nbsp;</a></span>get_32bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export get_32bit </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get not more than 32bits of the program at 'ea'. </p>
<dl class="section return"><dt>Returns</dt><dd>32 bit value, depending on processor_t::nbits:<ul>
<li>if ( nbits &lt;= 8 ) return get_dword(ea);</li>
<li>if ( nbits &lt;= 16) return get_wide_word(ea);</li>
<li>return get_wide_byte(ea); </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1213a5c7408571d91eb6f21d51dc8363" name="a1213a5c7408571d91eb6f21d51dc8363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1213a5c7408571d91eb6f21d51dc8363">&#9670;&nbsp;</a></span>get_64bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_64bit </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get not more than 64bits of the program at 'ea'. </p>
<dl class="section return"><dt>Returns</dt><dd>64 bit value, depending on processor_t::nbits:<ul>
<li>if ( nbits &lt;= 8 ) return get_qword(ea);</li>
<li>if ( nbits &lt;= 16) return get_wide_dword(ea);</li>
<li>return get_wide_byte(ea); </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a9386fa3dd9ca94b46897a3617e244ce0" name="a9386fa3dd9ca94b46897a3617e244ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9386fa3dd9ca94b46897a3617e244ce0">&#9670;&nbsp;</a></span>get_data_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export get_data_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value at of the item at 'ea'. </p>
<p >This function works with entities up to sizeof(ea_t) (bytes, word, etc) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>pointer to the result. may be nullptr </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">size</td><td>size of data to read. If 0, then the item type at 'ea' will be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ae83781763f1aab3612e16fa65a02e15e" name="ae83781763f1aab3612e16fa65a02e15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83781763f1aab3612e16fa65a02e15e">&#9670;&nbsp;</a></span>visit_patched_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export visit_patched_bytes </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(idaapi *)(ea_t ea, <a class="el" href="pro_8h.html#a42ae75d34f73b9e691bd16aaddb897e5">qoff64_t</a> fpos, uint64 o, uint64 v, void *ud)&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit all the patched bytes one byte at a time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea1</td><td>start linear address </td></tr>
    <tr><td class="paramname">ea2</td><td>end linear address </td></tr>
    <tr><td class="paramname">cb</td><td>callback called for each found byte. if the callback returns non-zero then that value will be returned to the caller and the enumeration will be interrupted. </td></tr>
    <tr><td class="paramname">ud</td><td>user data passed to the callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value returned by the callback (if any) or zero if the enumeration was completed. </dd></dl>

</div>
</div>
<a id="a8775c2f57cb46b8b4db51ea1c711f5c1" name="a8775c2f57cb46b8b4db51ea1c711f5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8775c2f57cb46b8b4db51ea1c711f5c1">&#9670;&nbsp;</a></span>get_original_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_original_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get original byte value (that was before patching). </p>
<p >This function works for wide byte processors too. </p>

</div>
</div>
<a id="aff867ae9455f3513557f9478e25ebe0d" name="aff867ae9455f3513557f9478e25ebe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff867ae9455f3513557f9478e25ebe0d">&#9670;&nbsp;</a></span>get_original_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_original_word </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get original word value (that was before patching). </p>
<p >This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() </p>

</div>
</div>
<a id="adf127c9ef3a53ae35227fa4f6ef9614e" name="adf127c9ef3a53ae35227fa4f6ef9614e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf127c9ef3a53ae35227fa4f6ef9614e">&#9670;&nbsp;</a></span>get_original_dword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_original_dword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get original dword (that was before patching) This function works for wide byte processors too. </p>
<p >This function takes into account order of bytes specified in idainfo::is_be() </p>

</div>
</div>
<a id="a6c744b5bb83b9c33b081c8526194a33f" name="a6c744b5bb83b9c33b081c8526194a33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c744b5bb83b9c33b081c8526194a33f">&#9670;&nbsp;</a></span>get_original_qword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman uint64 ida_export get_original_qword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get original qword value (that was before patching) This function DOESN'T work for wide byte processors too. </p>
<p >This function takes into account order of bytes specified in idainfo::is_be() </p>

</div>
</div>
<a id="aa58bf511be9b66ff3cb6210bd46b728e" name="aa58bf511be9b66ff3cb6210bd46b728e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58bf511be9b66ff3cb6210bd46b728e">&#9670;&nbsp;</a></span>put_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export put_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set value of one byte of the program. </p>
<p >This function modifies the database. If the debugger is active then the debugged process memory is patched too. </p><dl class="section note"><dt>Note</dt><dd>The original value of the byte is completely lost and can't be recovered by the <a class="el" href="bytes_8hpp.html#a8775c2f57cb46b8b4db51ea1c711f5c1" title="Get original byte value (that was before patching).">get_original_byte()</a> function. See also <a class="el" href="dbg_8hpp.html#a5b67e95a556cf3d746676a676e04f15a" title="Change one byte of the debugged process memory.">put_dbg_byte()</a> to write to the process memory directly when the debugger is active. This function can handle wide byte processors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">x</td><td>byte value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the database has been modified </dd></dl>

</div>
</div>
<a id="a305f6bc74464314cd5c71ecc6e313d7e" name="a305f6bc74464314cd5c71ecc6e313d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305f6bc74464314cd5c71ecc6e313d7e">&#9670;&nbsp;</a></span>put_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export put_word </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set value of one word of the program. </p>
<p >This function takes into account order of bytes specified in idainfo::is_be() This function works for wide byte processors too. </p><dl class="section note"><dt>Note</dt><dd>The original value of the word is completely lost and can't be recovered by the <a class="el" href="bytes_8hpp.html#aff867ae9455f3513557f9478e25ebe0d" title="Get original word value (that was before patching).">get_original_word()</a> function. ea - linear address x - word value </dd></dl>

</div>
</div>
<a id="aa3e943eefd745ed67ed1bd496b069b3c" name="aa3e943eefd745ed67ed1bd496b069b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e943eefd745ed67ed1bd496b069b3c">&#9670;&nbsp;</a></span>put_dword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export put_dword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set value of one dword of the program. </p>
<p >This function takes into account order of bytes specified in idainfo::is_be() This function works for wide byte processors too. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">x</td><td>dword value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the original value of the dword is completely lost and can't be recovered by the <a class="el" href="bytes_8hpp.html#adf127c9ef3a53ae35227fa4f6ef9614e" title="Get original dword (that was before patching) This function works for wide byte processors too.">get_original_dword()</a> function. </dd></dl>

</div>
</div>
<a id="a189e23a271fbef7e207f2925c4d36d4f" name="a189e23a271fbef7e207f2925c4d36d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189e23a271fbef7e207f2925c4d36d4f">&#9670;&nbsp;</a></span>put_qword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export put_qword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set value of one qword (8 bytes) of the program. </p>
<p >This function takes into account order of bytes specified in idainfo::is_be() This function DOESN'T works for wide byte processors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">x</td><td>qword value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50b7cfe135b9d484a7461e90b8fd2f90" name="a50b7cfe135b9d484a7461e90b8fd2f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b7cfe135b9d484a7461e90b8fd2f90">&#9670;&nbsp;</a></span>patch_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export patch_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch a byte of the program. </p>
<p >The original value of the byte is saved and can be obtained by <a class="el" href="bytes_8hpp.html#a8775c2f57cb46b8b4db51ea1c711f5c1" title="Get original byte value (that was before patching).">get_original_byte()</a>. This function works for wide byte processors too. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the database has been modified, </td></tr>
    <tr><td class="paramname">false</td><td>the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c639943ff3928ba71152b842db7c28f" name="a6c639943ff3928ba71152b842db7c28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c639943ff3928ba71152b842db7c28f">&#9670;&nbsp;</a></span>patch_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export patch_word </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch a word of the program. </p>
<p >The original value of the word is saved and can be obtained by <a class="el" href="bytes_8hpp.html#aff867ae9455f3513557f9478e25ebe0d" title="Get original word value (that was before patching).">get_original_word()</a>. This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the database has been modified, </td></tr>
    <tr><td class="paramname">false</td><td>the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4957f5a2ba97db1cb73d8d234c67f624" name="a4957f5a2ba97db1cb73d8d234c67f624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4957f5a2ba97db1cb73d8d234c67f624">&#9670;&nbsp;</a></span>patch_dword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export patch_dword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch a dword of the program. </p>
<p >The original value of the dword is saved and can be obtained by <a class="el" href="bytes_8hpp.html#adf127c9ef3a53ae35227fa4f6ef9614e" title="Get original dword (that was before patching) This function works for wide byte processors too.">get_original_dword()</a>. This function DOESN'T work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the database has been modified, </td></tr>
    <tr><td class="paramname">false</td><td>the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a152740498421568caab14010f25623ee" name="a152740498421568caab14010f25623ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152740498421568caab14010f25623ee">&#9670;&nbsp;</a></span>patch_qword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export patch_qword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch a qword of the program. </p>
<p >The original value of the qword is saved and can be obtained by <a class="el" href="bytes_8hpp.html#a6c744b5bb83b9c33b081c8526194a33f" title="Get original qword value (that was before patching) This function DOESN&#39;T work for wide byte processo...">get_original_qword()</a>. This function DOESN'T work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the database has been modified, </td></tr>
    <tr><td class="paramname">false</td><td>the debugger is running and the process' memory has value 'x' at address 'ea', or the debugger is not running, and the IDB has value 'x' at address 'ea already. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb4ba1861324425115b5b589f0daac96" name="aeb4ba1861324425115b5b589f0daac96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4ba1861324425115b5b589f0daac96">&#9670;&nbsp;</a></span>revert_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export revert_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Revert patched byte. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>byte was patched before and reverted now </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac758a752fcfa6c60bb29a979fa883ed3" name="ac758a752fcfa6c60bb29a979fa883ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac758a752fcfa6c60bb29a979fa883ed3">&#9670;&nbsp;</a></span>add_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export add_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a value to one byte of the program. </p>
<p >This function works for wide byte processors too. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">value</td><td>byte value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fd8330410af1e2d7ef9d583ce90360b" name="a9fd8330410af1e2d7ef9d583ce90360b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd8330410af1e2d7ef9d583ce90360b">&#9670;&nbsp;</a></span>add_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export add_word </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a value to one word of the program. </p>
<p >This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">value</td><td>byte value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1458b218c7aa19ba9c8bf19e7c03b4bb" name="a1458b218c7aa19ba9c8bf19e7c03b4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1458b218c7aa19ba9c8bf19e7c03b4bb">&#9670;&nbsp;</a></span>add_dword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export add_dword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a value to one dword of the program. </p>
<p >This function works for wide byte processors too. This function takes into account order of bytes specified in idainfo::is_be() </p><dl class="section note"><dt>Note</dt><dd>this function works incorrectly if processor_t::nbits &gt; 16 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">value</td><td>byte value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b93a89622f2303c2fdd2f3e80213c34" name="a9b93a89622f2303c2fdd2f3e80213c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b93a89622f2303c2fdd2f3e80213c34">&#9670;&nbsp;</a></span>add_qword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export add_qword </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a value to one qword of the program. </p>
<p >This function does not work for wide byte processors. This function takes into account order of bytes specified in idainfo::is_be() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">value</td><td>byte value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac283b1622ebfcbdda1f02da7451d1fac" name="ac283b1622ebfcbdda1f02da7451d1fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac283b1622ebfcbdda1f02da7451d1fac">&#9670;&nbsp;</a></span>get_zero_ranges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export get_zero_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrangeset__t.html">rangeset_t</a> *&#160;</td>
          <td class="paramname"><em>zranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrange__t.html">range_t</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return set of ranges with zero initialized bytes. </p>
<p >The returned set includes only big zero initialized ranges (at least &gt;1KB). Some zero initialized byte ranges may be not included. Only zero bytes that use the sparse storage method (STT_MM) are reported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zranges</td><td>pointer to the return value. cannot be nullptr </td></tr>
    <tr><td class="paramname">range</td><td>the range of addresses to verify. can be nullptr - means all ranges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the result is a non-empty set </dd></dl>

</div>
</div>
<a id="a287b095087ec2a98a90c66472b779a0d" name="a287b095087ec2a98a90c66472b779a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287b095087ec2a98a90c66472b779a0d">&#9670;&nbsp;</a></span>get_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_bytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gmb_flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mask</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified number of bytes of the program into the buffer. </p>
<p >If mask was specified it will contain a bitmap of initialized / uninitialized database bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to hold bytes </td></tr>
    <tr><td class="paramname">size</td><td>size of buffer in normal 8-bit bytes (sizeof(buf)) </td></tr>
    <tr><td class="paramname">gmb_flags</td><td>combination of <a class="el" href="group___g_m_b__.html">flags for get_bytes()</a> bits </td></tr>
    <tr><td class="paramname">mask</td><td>bitmap of initialize/uninitialized bytes (may be nullptr; must be at least (size+7)/8) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the user cancelled, return -1; otherwise number of read bytes. </dd></dl>

</div>
</div>
<a id="aa1ca5e83ff1f167ef3c0aa6737a03c18" name="aa1ca5e83ff1f167ef3c0aa6737a03c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ca5e83ff1f167ef3c0aa6737a03c18">&#9670;&nbsp;</a></span>put_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export put_bytes </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the specified number of bytes of the program. </p>
<p >This function does not save the original values of bytes. See also <a class="el" href="bytes_8hpp.html#a351950abd6c5309a1464bbbfc793f8e0" title="Patch the specified number of bytes of the program.">patch_bytes()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">buf</td><td>buffer with new values of bytes </td></tr>
    <tr><td class="paramname">size</td><td>size of buffer in normal 8-bit bytes (sizeof(buf)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a351950abd6c5309a1464bbbfc793f8e0" name="a351950abd6c5309a1464bbbfc793f8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351950abd6c5309a1464bbbfc793f8e0">&#9670;&nbsp;</a></span>patch_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export patch_bytes </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Patch the specified number of bytes of the program. </p>
<p >Original values of bytes are saved and are available with get_original...() functions. See also <a class="el" href="bytes_8hpp.html#aa1ca5e83ff1f167ef3c0aa6737a03c18" title="Modify the specified number of bytes of the program.">put_bytes()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">buf</td><td>buffer with new values of bytes </td></tr>
    <tr><td class="paramname">size</td><td>size of buffer in normal 8-bit bytes (sizeof(buf)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74466afc67d006638ae9191fa284329a" name="a74466afc67d006638ae9191fa284329a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74466afc67d006638ae9191fa284329a">&#9670;&nbsp;</a></span>f_is_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_is_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does flag denote start of an instruction? </p>

</div>
</div>
<a id="a2b84edd77d2e71c447de32b8fb0023be" name="a2b84edd77d2e71c447de32b8fb0023be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b84edd77d2e71c447de32b8fb0023be">&#9670;&nbsp;</a></span>f_is_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_is_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does flag denote start of data? </p>

</div>
</div>
<a id="a877e4fa95d7b97d06017f715a97e4285" name="a877e4fa95d7b97d06017f715a97e4285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877e4fa95d7b97d06017f715a97e4285">&#9670;&nbsp;</a></span>f_is_tail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_is_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does flag denote tail byte? </p>

</div>
</div>
<a id="a9897a28b84c9ca1f17e98c24b54395a2" name="a9897a28b84c9ca1f17e98c24b54395a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9897a28b84c9ca1f17e98c24b54395a2">&#9670;&nbsp;</a></span>is_not_tail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi is_not_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does flag denote tail byte? </p>

</div>
</div>
<a id="aa6f474c83aceb757371c8dbee8ff80f9" name="aa6f474c83aceb757371c8dbee8ff80f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f474c83aceb757371c8dbee8ff80f9">&#9670;&nbsp;</a></span>f_is_not_tail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_is_not_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does flag denote tail byte? </p>

</div>
</div>
<a id="a440c2c80ffda8a46c58005de4f15163f" name="a440c2c80ffda8a46c58005de4f15163f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440c2c80ffda8a46c58005de4f15163f">&#9670;&nbsp;</a></span>f_is_head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_is_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does flag denote start of instruction OR data? </p>

</div>
</div>
<a id="a8678caab70bfedb5e1bd46436fec0aec" name="a8678caab70bfedb5e1bd46436fec0aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8678caab70bfedb5e1bd46436fec0aec">&#9670;&nbsp;</a></span>del_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export del_items </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>nbytes</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bytes_8hpp.html#ad2808f4f5c5def4fb4738e218ae4af52">may_destroy_cb_t</a> *&#160;</td>
          <td class="paramname"><em>may_destroy</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert item (instruction/data) to unexplored bytes. </p>
<p >The whole item (including the head and tail bytes) will be destroyed. It is allowed to pass any address in the item to this function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address within the first item to delete </td></tr>
    <tr><td class="paramname">flags</td><td>combination of <a class="el" href="group___d_e_l_i_t__.html">Unexplored byte conversion flags</a> </td></tr>
    <tr><td class="paramname">nbytes</td><td>number of bytes in the range to be undefined </td></tr>
    <tr><td class="paramname">may_destroy</td><td>optional routine invoked before deleting a head item. If callback returns false then item is not to be deleted and operation fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on sucessful operation, otherwise false </dd></dl>

</div>
</div>
<a id="a94adb77aabb78f9944ff29a1eb38e544" name="a94adb77aabb78f9944ff29a1eb38e544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94adb77aabb78f9944ff29a1eb38e544">&#9670;&nbsp;</a></span>is_manual_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_manual_insn </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the instruction overridden? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address of the instruction or data item </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cbcd2b16bf5b747fe15eacc08049070" name="a2cbcd2b16bf5b747fe15eacc08049070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbcd2b16bf5b747fe15eacc08049070">&#9670;&nbsp;</a></span>get_manual_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_manual_insn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the user-specified string for the manual instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer </td></tr>
    <tr><td class="paramname">ea</td><td>linear address of the instruction or data item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of manual instruction or -1 </dd></dl>

</div>
</div>
<a id="ad7477b2cc88c2cb6628681e2df057993" name="ad7477b2cc88c2cb6628681e2df057993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7477b2cc88c2cb6628681e2df057993">&#9670;&nbsp;</a></span>set_manual_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export set_manual_insn </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>manual_insn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set manual instruction string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address of the instruction or data item </td></tr>
    <tr><td class="paramname">manual_insn</td><td>"" - delete manual string. nullptr - do nothing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e97254e6ecab6513ac1c023cf6cdca9" name="a4e97254e6ecab6513ac1c023cf6cdca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e97254e6ecab6513ac1c023cf6cdca9">&#9670;&nbsp;</a></span>f_has_xref()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_has_xref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the current byte have cross-references to it? </p>

</div>
</div>
<a id="ad6d1672102a9aa8ba9e050e5bb2af8cc" name="ad6d1672102a9aa8ba9e050e5bb2af8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d1672102a9aa8ba9e050e5bb2af8cc">&#9670;&nbsp;</a></span>f_has_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_has_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the current byte have non-trivial (non-dummy) name? </p>

</div>
</div>
<a id="a574315600e9d76f8fe8865cfe4794529" name="a574315600e9d76f8fe8865cfe4794529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574315600e9d76f8fe8865cfe4794529">&#9670;&nbsp;</a></span>f_has_dummy_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_has_dummy_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the current byte have dummy (auto-generated, with special prefix) name? </p>

</div>
</div>
<a id="acc970a54e3cfdd9fbe9c8912e80b2d94" name="acc970a54e3cfdd9fbe9c8912e80b2d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc970a54e3cfdd9fbe9c8912e80b2d94">&#9670;&nbsp;</a></span>f_has_user_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool idaapi f_has_user_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the current byte have user-specified name? </p>

</div>
</div>
<a id="aadeda3aee7159d2b18d452427d6d7983" name="aadeda3aee7159d2b18d452427d6d7983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadeda3aee7159d2b18d452427d6d7983">&#9670;&nbsp;</a></span>is_invsign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_invsign </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should sign of n-th operand inverted during output?. </p>
<p >allowed values of n: 0-first operand, 1-other operands </p>

</div>
</div>
<a id="ad5a502d23bb9f0b468fd029eb3198f4f" name="ad5a502d23bb9f0b468fd029eb3198f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a502d23bb9f0b468fd029eb3198f4f">&#9670;&nbsp;</a></span>toggle_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export toggle_sign </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle sign of n-th operand. </p>
<p >allowed values of n: 0-first operand, 1-other operands </p>

</div>
</div>
<a id="a031a58c79b794a26cb7c2c3927bde634" name="a031a58c79b794a26cb7c2c3927bde634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031a58c79b794a26cb7c2c3927bde634">&#9670;&nbsp;</a></span>is_bnot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_bnot </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should we negate the operand?. </p>
<p ><a class="el" href="structasm__t.html#ae81e274837415d05b80bbd09a41e3499" title="~ bit not assembler time operation">asm_t::a_bnot</a> should be defined in the idp module in order to work with this function </p>

</div>
</div>
<a id="a139412c7891bce63f6a60a9005c28384" name="a139412c7891bce63f6a60a9005c28384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139412c7891bce63f6a60a9005c28384">&#9670;&nbsp;</a></span>is_lzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_lzero </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display leading zeroes? Display leading zeroes in operands. </p>
<p >The global switch for the leading zeroes is in <a class="el" href="structidainfo.html#a7e87c180440ba1682326e6b9f791dd70" title="General idainfo flags">idainfo::s_genflags</a> Note: the leading zeroes doesn't work if for the target assembler octal numbers start with 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>the item (insn/data) address </td></tr>
    <tr><td class="paramname">n</td><td>the operand number (0-first operand, 1-other operands) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a96993e94d7866bef258bdb6c0ae91e06" name="a96993e94d7866bef258bdb6c0ae91e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96993e94d7866bef258bdb6c0ae91e06">&#9670;&nbsp;</a></span>set_lzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_lzero </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set toggle lzero bit. </p>
<p >This function changes the display of leading zeroes for the specified operand. If the default is not to display leading zeroes, this function will display them and vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>the item (insn/data) address </td></tr>
    <tr><td class="paramname">n</td><td>the operand number (0-first operand, 1-other operands) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ae09986a5cdd1cb36da5b9fca5a1f838d" name="ae09986a5cdd1cb36da5b9fca5a1f838d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09986a5cdd1cb36da5b9fca5a1f838d">&#9670;&nbsp;</a></span>clr_lzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export clr_lzero </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear toggle lzero bit. </p>
<p >This function reset the display of leading zeroes for the specified operand to the default. If the default is not to display leading zeroes, leading zeroes will not be displayed, as vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>the item (insn/data) address </td></tr>
    <tr><td class="paramname">n</td><td>the operand number (0-first operand, 1-other operands) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a3c9ea0c1d37ac65ee89b5a982b6fa780" name="a3c9ea0c1d37ac65ee89b5a982b6fa780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9ea0c1d37ac65ee89b5a982b6fa780">&#9670;&nbsp;</a></span>toggle_lzero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool idaapi toggle_lzero </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle lzero bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>the item (insn/data) address </td></tr>
    <tr><td class="paramname">n</td><td>the operand number (0-first operand, 1-other operands) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="aed13fecca2a1a5dc459d43c4ed5a6a96" name="aed13fecca2a1a5dc459d43c4ed5a6a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed13fecca2a1a5dc459d43c4ed5a6a96">&#9670;&nbsp;</a></span>get_operand_type_shift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int get_operand_type_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the shift in `flags64_t` for the nibble representing operand `n`'s type. </p>
<p >Note: n must be &lt; UA_MAXOP, and is not checked</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the operand number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shift to the nibble </dd></dl>

</div>
</div>
<a id="a36f2ca8cbc1c576af86ef2159a360050" name="a36f2ca8cbc1c576af86ef2159a360050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f2ca8cbc1c576af86ef2159a360050">&#9670;&nbsp;</a></span>get_operand_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> get_operand_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a>&#160;</td>
          <td class="paramname"><em>typebits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Place operand `n`'s type flag in the right nibble of a 64-bit flags set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typebits</td><td>the type bits (one of `FF_N_`) </td></tr>
    <tr><td class="paramname">n</td><td>the operand number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shift to the nibble </dd></dl>

</div>
</div>
<a id="a745316ecd14383d243ec2c202897eba6" name="a745316ecd14383d243ec2c202897eba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745316ecd14383d243ec2c202897eba6">&#9670;&nbsp;</a></span>is_flag_for_operand()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool is_flag_for_operand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#adde6aaee8457bee49c2a92621fe22b79">uint8</a>&#160;</td>
          <td class="paramname"><em>typebits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that the 64-bit flags set has the expected type for operand `n`. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>the flags </td></tr>
    <tr><td class="paramname">typebits</td><td>the type bits (one of `FF_N_`) </td></tr>
    <tr><td class="paramname">n</td><td>the operand number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a71ed0642d8f3498976b7a8c01c72f99f" name="a71ed0642d8f3498976b7a8c01c72f99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ed0642d8f3498976b7a8c01c72f99f">&#9670;&nbsp;</a></span>op_adds_xrefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export op_adds_xrefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should processor module create xrefs from the operand?. </p>
<p >Currently 'offset' and 'structure offset' operands create xrefs </p>

</div>
</div>
<a id="a6766a54bd62934647966171b02f9a21c" name="a6766a54bd62934647966171b02f9a21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6766a54bd62934647966171b02f9a21c">&#9670;&nbsp;</a></span>set_op_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_op_type </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(internal function) change representation of operand(s). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">type</td><td>new flag value (should be obtained from <a class="el" href="bytes_8hpp.html#af85d89d054af7549f1f09e669bb587f0" title="see FF_opbits">char_flag()</a>, <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a> and similar functions) </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number, OPND_ALL all operands </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed (applied to a tail byte) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8b0a61cca8477694fe22002746db49b" name="ab8b0a61cca8477694fe22002746db49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b0a61cca8477694fe22002746db49b">&#9670;&nbsp;</a></span>op_seg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export op_seg </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set operand representation to be 'segment'. </p>
<p >If applied to unexplored bytes, converts them to 16/32bit word data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number, OPND_ALL all operands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a86d475b8d1d98eb38c5652370d46f25b" name="a86d475b8d1d98eb38c5652370d46f25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d475b8d1d98eb38c5652370d46f25b">&#9670;&nbsp;</a></span>op_enum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export op_enum </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernwin_8hpp.html#a320dc6698b7075a653144bbdf202b30e">enum_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>serial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set operand representation to be 'enum_t'. </p>
<p >If applied to unexplored bytes, converts them to 16/32bit word data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number, OPND_ALL all operands </td></tr>
    <tr><td class="paramname">id</td><td>id of enum </td></tr>
    <tr><td class="paramname">serial</td><td>the serial number of the constant in the enumeration, usually 0. the serial numbers are used if the enumeration contains several constants with the same value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a0306c235939b0bfc270772909020e853" name="a0306c235939b0bfc270772909020e853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0306c235939b0bfc270772909020e853">&#9670;&nbsp;</a></span>get_enum_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="kernwin_8hpp.html#a320dc6698b7075a653144bbdf202b30e">enum_t</a> ida_export get_enum_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get enum id of 'enum' operand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number, OPND_ALL one of the operands </td></tr>
    <tr><td class="paramname">serial</td><td>pointer to variable to hold the serial number of the constant in the enumeration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of enum or <a class="el" href="netnode_8hpp.html#ab745219216aec4e8abf2c1dcc5d5eac0" title="A number to represent a bad netnode reference.">BADNODE</a> </dd></dl>

</div>
</div>
<a id="a045f11dbaa25bef9d56e63c0a3bbdb08" name="a045f11dbaa25bef9d56e63c0a3bbdb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045f11dbaa25bef9d56e63c0a3bbdb08">&#9670;&nbsp;</a></span>op_stroff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export op_stroff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinsn__t.html">insn_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adiff_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set operand representation to be 'struct offset'. </p>
<p >If applied to unexplored bytes, converts them to 16/32bit word data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>the instruction </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number, OPND_ALL all operands </td></tr>
    <tr><td class="paramname">path</td><td>structure path (strpath). see <a class="el" href="nalt_8hpp.html" title="Definitions of various information kept in netnodes.">nalt.hpp</a> for more info. </td></tr>
    <tr><td class="paramname">path_len</td><td>length of the structure path </td></tr>
    <tr><td class="paramname">delta</td><td>struct offset delta. usually 0. denotes the difference between the structure base and the pointer into the structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a05b9a68c2c5d67ce0155d56fe9070d92" name="a05b9a68c2c5d67ce0155d56fe9070d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b9a68c2c5d67ce0155d56fe9070d92">&#9670;&nbsp;</a></span>get_stroff_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_stroff_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adiff_t *&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get struct path of operand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>buffer for structure path (strpath). see <a class="el" href="nalt_8hpp.html" title="Definitions of various information kept in netnodes.">nalt.hpp</a> for more info. </td></tr>
    <tr><td class="paramname">delta</td><td>struct offset delta </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number, OPND_ALL one of the operands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of strpath </dd></dl>

</div>
</div>
<a id="aa01aa1c70776d2b8b2c62d5e676cd80b" name="aa01aa1c70776d2b8b2c62d5e676cd80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01aa1c70776d2b8b2c62d5e676cd80b">&#9670;&nbsp;</a></span>op_stkvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export op_stkvar </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set operand representation to be 'stack variable'. </p>
<p >Should be applied to an instruction within a function. Should be applied after creating a stack var using <a class="el" href="classinsn__t.html#abaeb6683f9b328932887c458550edd50" title="Create or modify a stack variable in the function frame.">insn_t::create_stkvar()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number, OPND_ALL all operands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a30692393915a1ac0c0129f778e4f81fe" name="a30692393915a1ac0c0129f778e4f81fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30692393915a1ac0c0129f778e4f81fe">&#9670;&nbsp;</a></span>set_forced_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_forced_operand </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set forced operand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number </td></tr>
    <tr><td class="paramname">op</td><td>text of operand<ul>
<li>nullptr: do nothing (return 0)</li>
<li>"" : delete forced operand </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a0c5020260196a9d4b57633a762c0c3f2" name="a0c5020260196a9d4b57633a762c0c3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5020260196a9d4b57633a762c0c3f2">&#9670;&nbsp;</a></span>get_forced_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_forced_operand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get forced operand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer, may be nullptr </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of forced operand or -1 </dd></dl>

</div>
</div>
<a id="a34b34b8cb7a47c749063f436b4848a2d" name="a34b34b8cb7a47c749063f436b4848a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b34b8cb7a47c749063f436b4848a2d">&#9670;&nbsp;</a></span>is_forced_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_forced_operand </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is operand manually defined?. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0caa5301feb96d4c8fa6caf9eb65d0f" name="af0caa5301feb96d4c8fa6caf9eb65d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0caa5301feb96d4c8fa6caf9eb65d0f">&#9670;&nbsp;</a></span>dec_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi dec_flag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number flag of the base, regardless of current processor - better to use <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a> </p>

</div>
</div>
<a id="acf779f23aa13d2af88398101f42ea115" name="acf779f23aa13d2af88398101f42ea115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf779f23aa13d2af88398101f42ea115">&#9670;&nbsp;</a></span>oct_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi oct_flag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number flag of the base, regardless of current processor - better to use <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a> </p>

</div>
</div>
<a id="ab11d9660b1084b938b265b699a47a4eb" name="ab11d9660b1084b938b265b699a47a4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11d9660b1084b938b265b699a47a4eb">&#9670;&nbsp;</a></span>bin_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> idaapi bin_flag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number flag of the base, regardless of current processor - better to use <a class="el" href="bytes_8hpp.html#acc2c2c18f6359471b6ab5908f175469e" title="Get number of default base (bin, oct, dec, hex)">num_flag()</a> </p>

</div>
</div>
<a id="aa2af9a3b5eaf1be072e8052ac0322b90" name="aa2af9a3b5eaf1be072e8052ac0322b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2af9a3b5eaf1be072e8052ac0322b90">&#9670;&nbsp;</a></span>clr_op_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export clr_op_type </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove operand representation information. </p>
<p >(set operand representation to be 'undefined') </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number, OPND_ALL all operands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="aa6154881265dd78649e6f4c526e70528" name="aa6154881265dd78649e6f4c526e70528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6154881265dd78649e6f4c526e70528">&#9670;&nbsp;</a></span>get_default_radix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_default_radix </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default base of number for the current processor. </p>
<dl class="section return"><dt>Returns</dt><dd>2, 8, 10, 16 </dd></dl>

</div>
</div>
<a id="a09a59b1f28010bc41cb41369dbba81a8" name="a09a59b1f28010bc41cb41369dbba81a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a59b1f28010bc41cb41369dbba81a8">&#9670;&nbsp;</a></span>get_radix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_radix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get radix of the operand, in: flags. </p>
<p >If the operand is not a number, returns <a class="el" href="bytes_8hpp.html#aa6154881265dd78649e6f4c526e70528" title="Get default base of number for the current processor.">get_default_radix()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>flags </td></tr>
    <tr><td class="paramname">n</td><td>number of operand (0, 1, -1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2, 8, 10, 16 </dd></dl>

</div>
</div>
<a id="a04173497ce9aa37187db3732328422d2" name="a04173497ce9aa37187db3732328422d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04173497ce9aa37187db3732328422d2">&#9670;&nbsp;</a></span>get_flags_by_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export get_flags_by_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get flags from size (in bytes). </p>
<p >Supported sizes: 1, 2, 4, 8, 16, 32. For other sizes returns 0 </p>

</div>
</div>
<a id="a10fa02b325a0d0eb6c19ca518a5da99d" name="a10fa02b325a0d0eb6c19ca518a5da99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fa02b325a0d0eb6c19ca518a5da99d">&#9670;&nbsp;</a></span>create_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export create_data </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>dataflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a>&#160;</td>
          <td class="paramname"><em>tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to data (byte, word, dword, etc). </p>
<p >This function may be used to create arrays. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">dataflag</td><td>type of data. Value of function <a class="el" href="bytes_8hpp.html#a6376a30aecda71f92475c02eeeee99ae" title="Get a flags64_t representing a byte.">byte_flag()</a>, <a class="el" href="bytes_8hpp.html#a0f96b780b188c1268b8de2ee66b84c61" title="Get a flags64_t representing a word.">word_flag()</a>, etc. </td></tr>
    <tr><td class="paramname">size</td><td>size of array in bytes. should be divisible by the size of one item of the specified type. for variable sized items it can be specified as 0, and the kernel will try to calculate the size. </td></tr>
    <tr><td class="paramname">tid</td><td>type id. If the specified type is a structure, then tid is structure id. Otherwise should be <a class="el" href="netnode_8hpp.html#ab745219216aec4e8abf2c1dcc5d5eac0" title="A number to represent a bad netnode reference.">BADNODE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a558590c540b5f825b138f31d357f0f6a" name="a558590c540b5f825b138f31d357f0f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558590c540b5f825b138f31d357f0f6a">&#9670;&nbsp;</a></span>create_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export create_align </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an alignment item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">length</td><td>size of the item in bytes. 0 means to infer from ALIGNMENT </td></tr>
    <tr><td class="paramname">alignment</td><td>alignment exponent. Example: 3 means align to 8 bytes. 0 means to infer from LENGTH It is forbidden to specify both LENGTH and ALIGNMENT as 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a4bbe5e1ed0c0f7c5141880523c14a46a" name="a4bbe5e1ed0c0f7c5141880523c14a46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbe5e1ed0c0f7c5141880523c14a46a">&#9670;&nbsp;</a></span>calc_min_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export calc_min_align </td>
          <td>(</td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the minimal possible alignment exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>size of the item in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value in the 1..32 range </dd></dl>

</div>
</div>
<a id="abf03a6d16a635ed68c28d57d0c66f2d9" name="abf03a6d16a635ed68c28d57d0c66f2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf03a6d16a635ed68c28d57d0c66f2d9">&#9670;&nbsp;</a></span>calc_max_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export calc_max_align </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>endea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the maximal possible alignment exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endea</td><td>end address of the alignment item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value in the 0..32 range </dd></dl>

</div>
</div>
<a id="a3d40bbff5669625ef0b2d033f1257e0c" name="a3d40bbff5669625ef0b2d033f1257e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d40bbff5669625ef0b2d033f1257e0c">&#9670;&nbsp;</a></span>calc_def_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export calc_def_align </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mina</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the default alignment exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">mina</td><td>minimal possible alignment exponent. </td></tr>
    <tr><td class="paramname">maxa</td><td>minimal possible alignment exponent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f6031bb8d2bad52aa580d438e5f83ed" name="a0f6031bb8d2bad52aa580d438e5f83ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6031bb8d2bad52aa580d438e5f83ed">&#9670;&nbsp;</a></span>get_max_strlit_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman size_t ida_export get_max_strlit_length </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td>
          <td class="paramname"><em>strtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine maximum length of string literal. </p>
<p >If the string literal has a length prefix (e.g., STRTYPE_LEN2 has a two-byte length prefix), the length of that prefix (i.e., 2) will be part of the returned value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>starting address </td></tr>
    <tr><td class="paramname">strtype</td><td>string type. one of <a class="el" href="group___s_t_r_t_y_p_e__.html">String type codes</a> </td></tr>
    <tr><td class="paramname">options</td><td>combination of <a class="el" href="group___a_l_o_p_t__.html">string literal length options</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the string in octets (octet==8bit) </dd></dl>

</div>
</div>
<a id="a5a576730697d57563c3f83b248bdde7d" name="a5a576730697d57563c3f83b248bdde7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a576730697d57563c3f83b248bdde7d">&#9670;&nbsp;</a></span>get_strlit_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_strlit_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>utf8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>maxcps</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents of string literal, as UTF-8-encoded codepoints. </p>
<p >This function returns the displayed part of the string It works even if the string has not been created in the database yet.</p>
<p >If 'len' is size_t(-1), it will be computed like so:</p><ul>
<li>if a string literal is present at 'ea', <a class="el" href="bytes_8hpp.html#a34792242834806a65b5f3be1036bf516" title="Get size of item (instruction/data) in bytes.">get_item_size()</a> * bytesize(ea) will be used</li>
<li>otherwise, get_max_strlit_length(..., ALOPT_IGNHEADS) will be used</li>
</ul>
<p >About 'maxcps': this specifies a limit to the number of codepoints, not bytes in the UTF-8 output buffer. So for example although U+4e12 will use 3 bytes in the output buffer, it still counts as only 1 character &ndash; unless STRCONV_ESCAPE is used. If 'STRCONV_ESCAPE' is used, U+4e12 will be converted to the string "\u4E12", and will use 6 bytes in the output buffer and also count as 6 codepoints.</p>
<p >If 'STRCONV_REPLCHAR', any undecodable byte will re represented as U+FFFD, occupy 3 bytes in the output buffer, and count for 1 codepoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">utf8</td><td>output buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ea</td><td>linear address of the string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the string, in octets (octet=8bit) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of the string. one of <a class="el" href="group___s_t_r_t_y_p_e__.html">String type codes</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">maxcps</td><td>maximum length of codepoints, after possible escaping, in output buffer (not counting terminating zero) on exit, will be set to 0 if string got truncated can be nullptr if not needed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>combination of <a class="el" href="group___s_t_r_c_o_n_v__.html">string conversion flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of generated text (in bytes) or -1 </dd></dl>

</div>
</div>
<a id="abe7ed03165ef9d8bdc5be53c19bcc634" name="abe7ed03165ef9d8bdc5be53c19bcc634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7ed03165ef9d8bdc5be53c19bcc634">&#9670;&nbsp;</a></span>create_strlit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export create_strlit </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td>
          <td class="paramname"><em>strtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to string literal and give a meaningful name. </p>
<p >'start' may be higher than 'end', the kernel will swap them in this case </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>starting address </td></tr>
    <tr><td class="paramname">len</td><td>length of the string in bytes. if 0, then <a class="el" href="bytes_8hpp.html#a0f6031bb8d2bad52aa580d438e5f83ed" title="Determine maximum length of string literal.">get_max_strlit_length()</a> will be used to determine the length </td></tr>
    <tr><td class="paramname">strtype</td><td>string type. one of <a class="el" href="group___s_t_r_t_y_p_e__.html">String type codes</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a940e6115dcc2d8d63a714fbe4301104c" name="a940e6115dcc2d8d63a714fbe4301104c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940e6115dcc2d8d63a714fbe4301104c">&#9670;&nbsp;</a></span>print_strlit_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export print_strlit_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td>
          <td class="paramname"><em>strtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out_tooltip</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get string type information: the string type name (possibly decorated with hotkey markers), and the tooltip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output buffer </td></tr>
    <tr><td class="paramname">strtype</td><td>the string type </td></tr>
    <tr><td class="paramname">out_tooltip</td><td>an optional output buffer for the tooltip </td></tr>
    <tr><td class="paramname">flags</td><td>or'ed PSTF_* constants </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of generated text </dd></dl>

</div>
</div>
<a id="a3c122e3b13ad3e2e99e72d185b44bf78" name="a3c122e3b13ad3e2e99e72d185b44bf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c122e3b13ad3e2e99e72d185b44bf78">&#9670;&nbsp;</a></span>get_opinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="unionopinfo__t.html">opinfo_t</a> *ida_export get_opinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get additional information about an operand representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer to receive the result. may not be nullptr </td></tr>
    <tr><td class="paramname">ea</td><td>linear address of item </td></tr>
    <tr><td class="paramname">n</td><td>number of operand, 0 or 1 </td></tr>
    <tr><td class="paramname">flags</td><td>flags of the item </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr if no additional representation information </dd></dl>

</div>
</div>
<a id="ad090293804afa887dd672aca39d0e68f" name="ad090293804afa887dd672aca39d0e68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad090293804afa887dd672aca39d0e68f">&#9670;&nbsp;</a></span>set_opinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_opinfo </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suppress_events</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set additional information about an operand representation. </p>
<p >This function is a low level one. Only the kernel should use it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address of the item </td></tr>
    <tr><td class="paramname">n</td><td>number of operand, 0 or 1 (see the note below) </td></tr>
    <tr><td class="paramname">flag</td><td>flags of the item </td></tr>
    <tr><td class="paramname">ti</td><td>additional representation information </td></tr>
    <tr><td class="paramname">suppress_events</td><td>do not generate changing_op_type and op_type_changed events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>
<dl class="section note"><dt>Note</dt><dd>for custom formats (if is_custfmt(flag, n) is true) or for offsets (if is_off(flag, n) is true) N can be in range 0..UA_MAXOP-1 or equal to OPND_ALL. In the case of OPND_ALL the additional information about all operands will be set. </dd></dl>

</div>
</div>
<a id="a04c89919285ab6251cacbd6809304e81" name="a04c89919285ab6251cacbd6809304e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c89919285ab6251cacbd6809304e81">&#9670;&nbsp;</a></span>get_data_elsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman asize_t ida_export get_data_elsize </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of data type specified in flags 'F'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address of the item </td></tr>
    <tr><td class="paramname">F</td><td>flags </td></tr>
    <tr><td class="paramname">ti</td><td>additional information about the data type. For example, if the current item is a structure instance, then ti-&gt;tid is structure id. Otherwise is ignored (may be nullptr). If specified as nullptr, will be automatically retrieved from the database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>byte : 1</li>
<li>word : 2</li>
<li>etc...</li>
</ul>
</dd></dl>
<p>If flags doesn't specify a data, then return 1 </p>

</div>
</div>
<a id="af33b2f500dc94da7bd34c49291b36b2a" name="af33b2f500dc94da7bd34c49291b36b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33b2f500dc94da7bd34c49291b36b2a">&#9670;&nbsp;</a></span>get_full_data_elsize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asize_t get_full_data_elsize </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get full size of data type specified in flags 'F'. </p>
<p >takes into account processors with wide bytes e.g. returns 2 for a byte element with 16-bit bytes </p>

</div>
</div>
<a id="a75d4739a1733ad860684372bdcef27dd" name="a75d4739a1733ad860684372bdcef27dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d4739a1733ad860684372bdcef27dd">&#9670;&nbsp;</a></span>is_varsize_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export is_varsize_item </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t *&#160;</td>
          <td class="paramname"><em>itemsize</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the item at 'ea' variable size?. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address of the item </td></tr>
    <tr><td class="paramname">F</td><td>flags </td></tr>
    <tr><td class="paramname">ti</td><td>additional information about the data type. For example, if the current item is a structure instance, then ti-&gt;tid is structure id. Otherwise is ignored (may be nullptr). If specified as nullptr, will be automatically retrieved from the database </td></tr>
    <tr><td class="paramname">itemsize</td><td>if not nullptr and the item is varsize, itemsize will contain the calculated item size (for struct types, the minimal size is returned) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>varsize item </td></tr>
    <tr><td class="paramname">0</td><td>fixed item </td></tr>
    <tr><td class="paramname">-1</td><td>error (bad data definition) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5be43d5dfbdb42e6a8a9d9012683ac9d" name="a5be43d5dfbdb42e6a8a9d9012683ac9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be43d5dfbdb42e6a8a9d9012683ac9d">&#9670;&nbsp;</a></span>can_define_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export can_define_item </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can define item (instruction/data) of the specified 'length', starting at 'ea'? </p>
<dl class="section note"><dt>Note</dt><dd>if there is an item starting at 'ea', this function ignores it </dd>
<dd>
this function converts to unexplored all encountered data items with fixup information. Should be fixed in the future. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>start of the range for the new item </td></tr>
    <tr><td class="paramname">length</td><td>length of the new item in bytes </td></tr>
    <tr><td class="paramname">flags</td><td>if not 0, then the kernel will ignore the data types specified by the flags and destroy them. For example: <pre>
                 1000 dw 5
                 1002 db 5 ; undef
                 1003 db 5 ; undef
                 1004 dw 5
                 1006 dd 5
                 </pre> can_define_item(1000, 6, 0) - false because of dw at 1004 <br  />
 can_define_item(1000, 6, word_flag()) - true, word at 1004 is destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1-yes, 0-no</dd></dl>
<p>This function may return 0 if:</p><ul>
<li>a new item would cross segment boundaries</li>
<li>a new item would overlap with existing items (except items specified by 'flags') </li>
</ul>

</div>
</div>
<a id="a560484246ad27da7047675a330cd6ead" name="a560484246ad27da7047675a330cd6ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560484246ad27da7047675a330cd6ead">&#9670;&nbsp;</a></span>set_immd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_immd </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set 'has immediate operand' flag. </p>
<p >Returns true if the <a class="el" href="bytes_8hpp.html#acea2ec7d412b8d21330145f9bd8d7543" title="Has Immediate value ?">FF_IMMD</a> bit was not set and now is set </p>

</div>
</div>
<a id="ab46024f0f75ce338912ff399e45568a7" name="ab46024f0f75ce338912ff399e45568a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46024f0f75ce338912ff399e45568a7">&#9670;&nbsp;</a></span>register_custom_data_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export register_custom_data_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdata__type__t.html">data_type_t</a> *&#160;</td>
          <td class="paramname"><em>dtinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a new data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtinfo</td><td>description of the new data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt; 0 : id of the new custom data type, &lt; 0 : error when the custom data type with the same name has already been registered </dd></dl>
<dl class="section note"><dt>Note</dt><dd>dtid 0 is reserved for built-in data types. </dd></dl>

</div>
</div>
<a id="a39bb8cf4f407f6723a621b2560111f0d" name="a39bb8cf4f407f6723a621b2560111f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bb8cf4f407f6723a621b2560111f0d">&#9670;&nbsp;</a></span>unregister_custom_data_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export unregister_custom_data_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a data type. </p>
<p >When the idb is closed, all custom data types are automatically unregistered, but since it happens too late (plugin modules could already be unloaded) one has to unregister custom data types explicitly. The ids of unregistered custom data types remain allocated and when the same name is reused to register a custom data type, it will get assigned the same id. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtid</td><td>data type to unregister </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>ok </td></tr>
    <tr><td class="paramname">false</td><td>no such dtid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a910a2755f876fef4d415e7ec88c3a413" name="a910a2755f876fef4d415e7ec88c3a413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910a2755f876fef4d415e7ec88c3a413">&#9670;&nbsp;</a></span>register_custom_data_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export register_custom_data_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdata__format__t.html">data_format_t</a> *&#160;</td>
          <td class="paramname"><em>dtform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a new data format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtform</td><td>description of the new data format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt; 0 : id of the new custom data format, &lt; 0 : error when the custom data format with the same name has already been registered to the data type </dd></dl>
<dl class="section note"><dt>Note</dt><dd>dfid 0 is unused. </dd></dl>

</div>
</div>
<a id="ad010f7bd1f08140e2e0adc77400fc351" name="ad010f7bd1f08140e2e0adc77400fc351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad010f7bd1f08140e2e0adc77400fc351">&#9670;&nbsp;</a></span>unregister_custom_data_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export unregister_custom_data_format </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a data format. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bytes_8hpp.html#a39bb8cf4f407f6723a621b2560111f0d" title="Unregister a data type.">unregister_custom_data_type()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfid</td><td>data format to unregister </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>ok </td></tr>
    <tr><td class="paramname">false</td><td>no such dfid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaee2e0bd7741d4865153a470887b3076" name="aaee2e0bd7741d4865153a470887b3076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee2e0bd7741d4865153a470887b3076">&#9670;&nbsp;</a></span>get_custom_data_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const <a class="el" href="structdata__type__t.html">data_type_t</a> *ida_export get_custom_data_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get definition of a registered custom data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtid</td><td>data type id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data type definition or nullptr </dd></dl>

</div>
</div>
<a id="a8ba3b7e3719fd1bd3cb3eb72ada29b17" name="a8ba3b7e3719fd1bd3cb3eb72ada29b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba3b7e3719fd1bd3cb3eb72ada29b17">&#9670;&nbsp;</a></span>get_custom_data_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const <a class="el" href="structdata__format__t.html">data_format_t</a> *ida_export get_custom_data_format </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get definition of a registered custom data format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfid</td><td>data format id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data format definition or nullptr </dd></dl>

</div>
</div>
<a id="a2e5f4c242bc11c2f1441401592fa648e" name="a2e5f4c242bc11c2f1441401592fa648e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5f4c242bc11c2f1441401592fa648e">&#9670;&nbsp;</a></span>attach_custom_data_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export attach_custom_data_format </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach the data format to the data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtid</td><td>data type id that can use the data format. 0 means all standard data types. Such data formats can be applied to any data item or instruction operands. For instruction operands, the <a class="el" href="structdata__format__t.html#a484363fae7730c346c2f9488ac0d16f6" title="size of the value in bytes 0 means any size is ok data formats that are registered for standard types...">data_format_t::value_size</a> check is not performed by the kernel. </td></tr>
    <tr><td class="paramname">dfid</td><td>data format id </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>ok </td></tr>
    <tr><td class="paramname">false</td><td>no such `dtid', or no such `dfid', or the data format has already been attached to the data type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b262984a0e6314cb289f8f3b9957b68" name="a2b262984a0e6314cb289f8f3b9957b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b262984a0e6314cb289f8f3b9957b68">&#9670;&nbsp;</a></span>detach_custom_data_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export detach_custom_data_format </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach the data format from the data type. </p>
<p >Unregistering a custom data type detaches all attached data formats, no need to detach them explicitly. You still need unregister them. Unregistering a custom data format detaches it from all attached data types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtid</td><td>data type id to detach data format from </td></tr>
    <tr><td class="paramname">dfid</td><td>data format id to detach </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>ok </td></tr>
    <tr><td class="paramname">false</td><td>no such `dtid', or no such `dfid', or the data format was not attached to the data type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0315f596c2f7dcd5c1730989c42dd5d7" name="a0315f596c2f7dcd5c1730989c42dd5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0315f596c2f7dcd5c1730989c42dd5d7">&#9670;&nbsp;</a></span>is_attached_custom_data_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_attached_custom_data_format </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dfid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the custom data format attached to the custom data type? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtid</td><td>data type id </td></tr>
    <tr><td class="paramname">dfid</td><td>data format id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a id="ac8666f9333df700da97c98af645fc714" name="ac8666f9333df700da97c98af645fc714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8666f9333df700da97c98af645fc714">&#9670;&nbsp;</a></span>get_custom_data_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_custom_data_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>max_size</em> = <code><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of registered custom data type ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer for the output. may be nullptr </td></tr>
    <tr><td class="paramname">min_size</td><td>minimum value size </td></tr>
    <tr><td class="paramname">max_size</td><td>maximum value size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of custom data types with the specified size limits </dd></dl>

</div>
</div>
<a id="a5791f45da0c6235ad3c8d70dcebcab7b" name="a5791f45da0c6235ad3c8d70dcebcab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5791f45da0c6235ad3c8d70dcebcab7b">&#9670;&nbsp;</a></span>get_custom_data_formats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_custom_data_formats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of attached custom data formats for the specified data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>buffer for the output. may be nullptr </td></tr>
    <tr><td class="paramname">dtid</td><td>data type id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of returned custom data formats. if error, returns -1 </dd></dl>

</div>
</div>
<a id="a2cbe93e51482c28e7425d903f1b951c3" name="a2cbe93e51482c28e7425d903f1b951c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbe93e51482c28e7425d903f1b951c3">&#9670;&nbsp;</a></span>find_custom_data_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export find_custom_data_type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get id of a custom data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the custom data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id or -1 </dd></dl>

</div>
</div>
<a id="adfdcd0ae26d0f832db18f539df334426" name="adfdcd0ae26d0f832db18f539df334426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdcd0ae26d0f832db18f539df334426">&#9670;&nbsp;</a></span>find_custom_data_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export find_custom_data_format </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get id of a custom data format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the custom data format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id or -1 </dd></dl>

</div>
</div>
<a id="abaa59b8ec4df56ac22d47d6bb7624e3b" name="abaa59b8ec4df56ac22d47d6bb7624e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa59b8ec4df56ac22d47d6bb7624e3b">&#9670;&nbsp;</a></span>set_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_cmt </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rptble</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an indented comment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">comm</td><td>comment string<ul>
<li>nullptr: do nothing (return 0)</li>
<li>"" : delete comment </li>
</ul>
</td></tr>
    <tr><td class="paramname">rptble</td><td>is repeatable? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="aa15e5cc5c923b7932b79bb67b3fe54ad" name="aa15e5cc5c923b7932b79bb67b3fe54ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15e5cc5c923b7932b79bb67b3fe54ad">&#9670;&nbsp;</a></span>get_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_cmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rptble</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an indented comment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer, may be nullptr </td></tr>
    <tr><td class="paramname">ea</td><td>linear address. may point to tail byte, the function will find start of the item </td></tr>
    <tr><td class="paramname">rptble</td><td>get repeatable comment? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of comment or -1 </dd></dl>

</div>
</div>
<a id="abf8f737249505e8479ccbd92ceb56c30" name="abf8f737249505e8479ccbd92ceb56c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8f737249505e8479ccbd92ceb56c30">&#9670;&nbsp;</a></span>append_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export append_cmt </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rptble</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append to an indented comment. </p>
<p >Creates a new comment if none exists. Appends a newline character and the specified string otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">str</td><td>comment string to append </td></tr>
    <tr><td class="paramname">rptble</td><td>append to repeatable comment? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="aea1663690ac8f4a860526e13d6c3549d" name="aea1663690ac8f4a860526e13d6c3549d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1663690ac8f4a860526e13d6c3549d">&#9670;&nbsp;</a></span>get_predef_insn_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_predef_insn_cmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinsn__t.html">insn_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get predefined comment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer for the comment </td></tr>
    <tr><td class="paramname">ins</td><td>current instruction information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of comment or -1 </dd></dl>

</div>
</div>
<a id="a5c3cbe7931862f0d0c04baa5ecbeef8f" name="a5c3cbe7931862f0d0c04baa5ecbeef8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3cbe7931862f0d0c04baa5ecbeef8f">&#9670;&nbsp;</a></span>find_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export find_byte </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>sEA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_search_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find forward a byte with the specified value (only 8-bit value from the database). </p>
<p >example: ea=4 size=3 will inspect addresses 4, 5, and 6 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sEA</td><td>linear address </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to inspect </td></tr>
    <tr><td class="paramname">value</td><td>value to find </td></tr>
    <tr><td class="paramname">bin_search_flags</td><td>combination of <a class="el" href="group___b_i_n___s_e_a_r_c_h__.html">Search flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of byte or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> </dd></dl>

</div>
</div>
<a id="ae1a70437813c4ca4500a6ba33a74eaeb" name="ae1a70437813c4ca4500a6ba33a74eaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a70437813c4ca4500a6ba33a74eaeb">&#9670;&nbsp;</a></span>find_byter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export find_byter </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>sEA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_search_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find reverse a byte with the specified value (only 8-bit value from the database). </p>
<p >example: ea=4 size=3 will inspect addresses 6, 5, and 4 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sEA</td><td>the lower address of the search range </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to inspect </td></tr>
    <tr><td class="paramname">value</td><td>value to find </td></tr>
    <tr><td class="paramname">bin_search_flags</td><td>combination of <a class="el" href="group___b_i_n___s_e_a_r_c_h__.html">Search flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of byte or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> </dd></dl>

</div>
</div>
<a id="a08ccb0986294a9d3bb060ab3699a02fe" name="a08ccb0986294a9d3bb060ab3699a02fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ccb0986294a9d3bb060ab3699a02fe">&#9670;&nbsp;</a></span>parse_binpat_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export parse_binpat_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classqvector.html">compiled_binpat_vec_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strlits_encoding</em> = <code>PBSENC_DEF1BPU</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>errbuf</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert user-specified binary string to internal representation. </p>
<p >The 'in' parameter contains space-separated tokens: </p><div class="fragment"><div class="line">- numbers (numeric base is determined by <span class="stringliteral">&#39;radix&#39;</span>)</div>
<div class="line">    - <span class="keywordflow">if</span> value of number fits a byte, it is considered as a <span class="keywordtype">byte</span></div>
<div class="line">    - <span class="keywordflow">if</span> value of number fits a word, it is considered as 2 bytes</div>
<div class="line">    - <span class="keywordflow">if</span> value of number fits a dword,it is considered as 4 bytes</div>
<div class="line">- <span class="stringliteral">&quot;...&quot;</span> <span class="keywordtype">string</span> constants</div>
<div class="line">- <span class="charliteral">&#39;x&#39;</span>  single-character constants</div>
<div class="line">- ?    variable bytes</div>
</div><!-- fragment --><p >Note that string constants are surrounded with double quotes.</p>
<p >Here are a few examples (assuming base 16): </p><div class="fragment"><div class="line">CD 21          - bytes 0xCD, 0x21</div>
<div class="line">21CD           - bytes 0xCD, 0x21 (little endian ) or 0x21, 0xCD (big-endian)</div>
<div class="line"><span class="stringliteral">&quot;Hello&quot;</span>, 0     - the null terminated <span class="keywordtype">string</span> <span class="stringliteral">&quot;Hello&quot;</span></div>
<div class="line">L<span class="stringliteral">&quot;Hello&quot;</span>       - <span class="charliteral">&#39;H&#39;</span>, 0, <span class="charliteral">&#39;e&#39;</span>, 0, <span class="charliteral">&#39;l&#39;</span>, 0, <span class="charliteral">&#39;l&#39;</span>, 0, <span class="charliteral">&#39;o&#39;</span>, 0</div>
<div class="line">B8 ? ? ? ? 90  - <span class="keywordtype">byte</span> 0xB8, 4 bytes with any value, <span class="keywordtype">byte</span> 0x90</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>a vector of compiled binary patterns, for use with <a class="el" href="bytes_8hpp.html#af2f6ea57cdc1672b7e303aee3485d3e5" title="Search for a string in the program.">bin_search2()</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ea</td><td>linear address to convert for (the conversion depends on the address, because the number of bits in a byte depend on the segment type) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>input text string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">radix</td><td>numeric base of numbers (8,10,16) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">strlits_encoding</td><td>the target encoding into which the string literals present in 'in', should be encoded. Can be any from [1, <a class="el" href="nalt_8hpp.html#a540e1c42a493e1c5a15e5932adfaf669" title="Get total number of encodings (counted from 0)">get_encoding_qty()</a>), or the special values PBSENC_* </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">errbuf</td><td>error buffer (can be nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false either in case of parsing error, or if at least one requested target encoding couldn't encode the string literals present in "in". </dd></dl>

</div>
</div>
<a id="af2f6ea57cdc1672b7e303aee3485d3e5" name="af2f6ea57cdc1672b7e303aee3485d3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f6ea57cdc1672b7e303aee3485d3e5">&#9670;&nbsp;</a></span>bin_search2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export bin_search2 </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>end_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqvector.html">compiled_binpat_vec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a string in the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>linear address, start of range to search </td></tr>
    <tr><td class="paramname">end_ea</td><td>linear address, end of range to search (exclusive) </td></tr>
    <tr><td class="paramname">data</td><td>the prepared data to search for (see <a class="el" href="bytes_8hpp.html#a08ccb0986294a9d3bb060ab3699a02fe" title="Convert user-specified binary string to internal representation.">parse_binpat_str()</a>) </td></tr>
    <tr><td class="paramname">flags</td><td>combination of <a class="el" href="group___b_i_n___s_e_a_r_c_h__.html">Search flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> (if pressed Ctrl-Break or not found) or string address. </dd></dl>

</div>
</div>
<a id="a5c92d3f09ffce89698d6bbea408f9e57" name="a5c92d3f09ffce89698d6bbea408f9e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c92d3f09ffce89698d6bbea408f9e57">&#9670;&nbsp;</a></span>bin_search3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export bin_search3 </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_matched_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>end_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqvector.html">compiled_binpat_vec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a patter in the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_matched_idx</td><td>index in data when pattern found </td></tr>
    <tr><td class="paramname">start_ea</td><td>linear address, start of range to search </td></tr>
    <tr><td class="paramname">end_ea</td><td>linear address, end of range to search (exclusive) </td></tr>
    <tr><td class="paramname">data</td><td>the prepared data to search for (see <a class="el" href="bytes_8hpp.html#a08ccb0986294a9d3bb060ab3699a02fe" title="Convert user-specified binary string to internal representation.">parse_binpat_str()</a>) </td></tr>
    <tr><td class="paramname">flags</td><td>combination of <a class="el" href="group___b_i_n___s_e_a_r_c_h__.html">Search flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> (if pressed Ctrl-Break or not found) or pattern address. </dd></dl>

</div>
</div>
<a id="a7abd041353225e8daedd30f5d3df5fa1" name="a7abd041353225e8daedd30f5d3df5fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abd041353225e8daedd30f5d3df5fa1">&#9670;&nbsp;</a></span>equal_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export equal_bytes </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_search_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare 'len' bytes of the program starting from 'ea' with 'image'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">image</td><td>bytes to compare with </td></tr>
    <tr><td class="paramname">mask</td><td>array of mask bytes, it's length is 'len'. if the flag BIN_SEARCH_BITMASK is passsed, 'bitwise AND' is used to compare. if not; 1 means to perform the comparison of the corresponding byte. 0 means not to perform. if mask == nullptr, then all bytes of 'image' will be compared. if mask == <a class="el" href="bytes_8hpp.html#aa80006fc5cd3a216c0f514baad625c4d" title="Used by equal_bytes() to skip 0xFF when searching the program.">SKIP_FF_MASK</a> then 0xFF bytes will be skipped </td></tr>
    <tr><td class="paramname">len</td><td>length of block to compare in bytes. </td></tr>
    <tr><td class="paramname">bin_search_flags</td><td>combination of <a class="el" href="group___b_i_n___s_e_a_r_c_h__.html">Search flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>equal </td></tr>
    <tr><td class="paramname">0</td><td>not equal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab2b026ae2fc396277270cf6886ea8e9" name="aab2b026ae2fc396277270cf6886ea8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2b026ae2fc396277270cf6886ea8e9">&#9670;&nbsp;</a></span>update_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export update_hidden_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *&#160;</td>
          <td class="paramname"><em>ha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update hidden range information in the database. </p>
<p >You cannot use this function to change the range boundaries </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ha</td><td>range to update </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="abdacd258010c86b3cec5bf75d8c10325" name="abdacd258010c86b3cec5bf75d8c10325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdacd258010c86b3cec5bf75d8c10325">&#9670;&nbsp;</a></span>add_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_hidden_range </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>footer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a3df5040891132e50157aee66affdf1de">bgcolor_t</a>&#160;</td>
          <td class="paramname"><em>color</em> = <code><a class="el" href="pro_8h.html#ae5314b4ed32e86fb438e011ac3046456">DEFCOLOR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a range of addresses as hidden. </p>
<p >The range will be created in the invisible state with the default color </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea1</td><td>linear address of start of the address range </td></tr>
    <tr><td class="paramname">ea2</td><td>linear address of end of the address range </td></tr>
    <tr><td class="paramname">description,header,footer</td><td>range parameters </td></tr>
    <tr><td class="paramname">color</td><td>the range color </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a59a8e71d01b4b30e9f7d9597d4f93a42" name="a59a8e71d01b4b30e9f7d9597d4f93a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a8e71d01b4b30e9f7d9597d4f93a42">&#9670;&nbsp;</a></span>get_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export get_hidden_range </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to hidden range structure, in: linear address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the hidden range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acef60757079f9eb363c45c358c1c6a6a" name="acef60757079f9eb363c45c358c1c6a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef60757079f9eb363c45c358c1c6a6a">&#9670;&nbsp;</a></span>getn_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export getn_hidden_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to hidden range structure, in: number of hidden range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of hidden range, is in range 0..<a class="el" href="bytes_8hpp.html#a76c3b9d45c445392f73390e90ab7a626" title="Get number of hidden ranges.">get_hidden_range_qty()</a>-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a850f8f6a36d4011137a485d37057043f" name="a850f8f6a36d4011137a485d37057043f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850f8f6a36d4011137a485d37057043f">&#9670;&nbsp;</a></span>get_hidden_range_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_hidden_range_num </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of a hidden range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the hidden range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of hidden range (0..<a class="el" href="bytes_8hpp.html#a76c3b9d45c445392f73390e90ab7a626" title="Get number of hidden ranges.">get_hidden_range_qty()</a>-1) </dd></dl>

</div>
</div>
<a id="a6ea70d119ab45b415f1a348e4464e154" name="a6ea70d119ab45b415f1a348e4464e154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea70d119ab45b415f1a348e4464e154">&#9670;&nbsp;</a></span>get_prev_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export get_prev_hidden_range </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to previous hidden range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to hidden range or nullptr if previous hidden range doesn't exist </dd></dl>

</div>
</div>
<a id="a1f8808375270809d346e439263556f18" name="a1f8808375270809d346e439263556f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8808375270809d346e439263556f18">&#9670;&nbsp;</a></span>get_next_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export get_next_hidden_range </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to next hidden range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the program </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to hidden range or nullptr if next hidden range doesn't exist </dd></dl>

</div>
</div>
<a id="a1707d96152599b58af01663b532cf8c4" name="a1707d96152599b58af01663b532cf8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1707d96152599b58af01663b532cf8c4">&#9670;&nbsp;</a></span>get_first_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export get_first_hidden_range </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the first hidden range. </p>
<dl class="section return"><dt>Returns</dt><dd>ptr to hidden range or nullptr </dd></dl>

</div>
</div>
<a id="a10378de520789a96f670f0754947933b" name="a10378de520789a96f670f0754947933b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10378de520789a96f670f0754947933b">&#9670;&nbsp;</a></span>get_last_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="structhidden__range__t.html">hidden_range_t</a> *ida_export get_last_hidden_range </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to the last hidden range. </p>
<dl class="section return"><dt>Returns</dt><dd>ptr to hidden range or nullptr </dd></dl>

</div>
</div>
<a id="a0dba106583971df2820c92c3a15d0ba1" name="a0dba106583971df2820c92c3a15d0ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dba106583971df2820c92c3a15d0ba1">&#9670;&nbsp;</a></span>del_hidden_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export del_hidden_range </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete hidden range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the hidden range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a7487b1a4c03cdb4c120b9da41d63f501" name="a7487b1a4c03cdb4c120b9da41d63f501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7487b1a4c03cdb4c120b9da41d63f501">&#9670;&nbsp;</a></span>add_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_mapping </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IDA supports memory mapping. </p>
<p >References to the addresses from the mapped range use data and meta-data from the mapping range. </p><dl class="section note"><dt>Note</dt><dd>You should set flag PR2_MAPPING in ph.flag2 to use memory mapping Add memory mapping range. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>start of the mapped range (nonexistent address) </td></tr>
    <tr><td class="paramname">to</td><td>start of the mapping range (existent address) </td></tr>
    <tr><td class="paramname">size</td><td>size of the range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="af7a61ab7c936a56bce543eecb5ae4dcf" name="af7a61ab7c936a56bce543eecb5ae4dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a61ab7c936a56bce543eecb5ae4dcf">&#9670;&nbsp;</a></span>del_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export del_mapping </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete memory mapping range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the mapped range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2122b5b37703401df0a05c0538ef2c6e" name="a2122b5b37703401df0a05c0538ef2c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2122b5b37703401df0a05c0538ef2c6e">&#9670;&nbsp;</a></span>use_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export use_mapping </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate address according to current mappings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>address to translate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>translated address </dd></dl>

</div>
</div>
<a id="a33af98c88580e234b2f8bf7b6b878578" name="a33af98c88580e234b2f8bf7b6b878578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33af98c88580e234b2f8bf7b6b878578">&#9670;&nbsp;</a></span>get_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export get_mapping </td>
          <td>(</td>
          <td class="paramtype">ea_t *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get memory mapping range by its number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>start of the mapped range </td></tr>
    <tr><td class="paramname">to</td><td>start of the mapping range </td></tr>
    <tr><td class="paramname">size</td><td>size of the range </td></tr>
    <tr><td class="paramname">n</td><td>number of mapping range (0..<a class="el" href="bytes_8hpp.html#a33007784af2c955b57ebda8caa8d51b5" title="Get number of mappings.">get_mappings_qty()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the specified range doesn't exist, otherwise returns `from', `to', `size' </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
