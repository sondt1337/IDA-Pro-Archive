<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: processor_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structprocessor__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">processor_t Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Describes a processor module (IDP).  
 <a href="structprocessor__t.html#details">More...</a></p>

<p><code>#include &lt;idp.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e94679bdf9f1c003df71da06dad16ea"><td class="memItemLeft" align="right" valign="top"><a id="a3e94679bdf9f1c003df71da06dad16ea" name="a3e94679bdf9f1c003df71da06dad16ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_idp_opts</b> (void) const</td></tr>
<tr class="memdesc:a3e94679bdf9f1c003df71da06dad16ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">#PR_IDP_OPTS <br /></td></tr>
<tr class="separator:a3e94679bdf9f1c003df71da06dad16ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afd8f35b1dd6073b629e5721b93df48"><td class="memItemLeft" align="right" valign="top"><a id="a6afd8f35b1dd6073b629e5721b93df48" name="a6afd8f35b1dd6073b629e5721b93df48"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_realcvt</b> (void) const</td></tr>
<tr class="memdesc:a6afd8f35b1dd6073b629e5721b93df48"><td class="mdescLeft">&#160;</td><td class="mdescRight">#PR_REALCVT <br /></td></tr>
<tr class="separator:a6afd8f35b1dd6073b629e5721b93df48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748b4f1feee94973d69548147f2976f1"><td class="memItemLeft" align="right" valign="top"><a id="a748b4f1feee94973d69548147f2976f1" name="a748b4f1feee94973d69548147f2976f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_segregs</b> (void) const</td></tr>
<tr class="memdesc:a748b4f1feee94973d69548147f2976f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#aa5d76a1fe1338a80404a0ca7a7ced6d0" title="has segment registers?">PR_SEGS</a> <br /></td></tr>
<tr class="separator:a748b4f1feee94973d69548147f2976f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480962c2539adf539613d7258f2e6ee"><td class="memItemLeft" align="right" valign="top"><a id="a6480962c2539adf539613d7258f2e6ee" name="a6480962c2539adf539613d7258f2e6ee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use32</b> (void) const</td></tr>
<tr class="memdesc:a6480962c2539adf539613d7258f2e6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#a4641211435ce736ed30c9ff0a558cf01" title="supports 64-bit addressing?">PR_USE64</a> or <a class="el" href="idp_8hpp.html#ab86fc012cafb2de8b39fefc055941d17" title="supports 32-bit addressing?">PR_USE32</a> <br /></td></tr>
<tr class="separator:a6480962c2539adf539613d7258f2e6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091dfba8a9fd2b3f473a7ea84bc2a0f7"><td class="memItemLeft" align="right" valign="top"><a id="a091dfba8a9fd2b3f473a7ea84bc2a0f7" name="a091dfba8a9fd2b3f473a7ea84bc2a0f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use64</b> (void) const</td></tr>
<tr class="memdesc:a091dfba8a9fd2b3f473a7ea84bc2a0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#a4641211435ce736ed30c9ff0a558cf01" title="supports 64-bit addressing?">PR_USE64</a> <br /></td></tr>
<tr class="separator:a091dfba8a9fd2b3f473a7ea84bc2a0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da3eacaa62ac6b4a03d2ba2493be59f"><td class="memItemLeft" align="right" valign="top"><a id="a4da3eacaa62ac6b4a03d2ba2493be59f" name="a4da3eacaa62ac6b4a03d2ba2493be59f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ti</b> (void) const</td></tr>
<tr class="memdesc:a4da3eacaa62ac6b4a03d2ba2493be59f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#a257f9d36eb8bf8c36a28e014f3deedc5" title="the processor module fully supports type information callbacks; without full support,...">PR_TYPEINFO</a> <br /></td></tr>
<tr class="separator:a4da3eacaa62ac6b4a03d2ba2493be59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cadc6b71ebc381378698c9013c0abc4"><td class="memItemLeft" align="right" valign="top"><a id="a7cadc6b71ebc381378698c9013c0abc4" name="a7cadc6b71ebc381378698c9013c0abc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>stkup</b> (void) const</td></tr>
<tr class="memdesc:a7cadc6b71ebc381378698c9013c0abc4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#a6bd7458e91aaf2970f7e6e82b87b0c67" title="the stack grows up">PR_STACK_UP</a> <br /></td></tr>
<tr class="separator:a7cadc6b71ebc381378698c9013c0abc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5ad4df4d0825ffbefceb583ac8a284"><td class="memItemLeft" align="right" valign="top"><a id="a7e5ad4df4d0825ffbefceb583ac8a284" name="a7e5ad4df4d0825ffbefceb583ac8a284"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_tbyte</b> (void) const</td></tr>
<tr class="memdesc:a7e5ad4df4d0825ffbefceb583ac8a284"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#a196de44585ee70b23e01cb9266aff600" title="BTMT_SPECFLT means _TBYTE type">PR_USE_TBYTE</a> <br /></td></tr>
<tr class="separator:a7e5ad4df4d0825ffbefceb583ac8a284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dcc004db7d33f353ad903f4f5bce58"><td class="memItemLeft" align="right" valign="top"><a id="a97dcc004db7d33f353ad903f4f5bce58" name="a97dcc004db7d33f353ad903f4f5bce58"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_mappings</b> (void) const</td></tr>
<tr class="memdesc:a97dcc004db7d33f353ad903f4f5bce58"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#a50901ac40fe5f487dcdb5416068d9455" title="the processor module uses memory mapping">PR2_MAPPINGS</a> <br /></td></tr>
<tr class="separator:a97dcc004db7d33f353ad903f4f5bce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de213f18a3ad68ea616e79d98588102"><td class="memItemLeft" align="right" valign="top"><a id="a5de213f18a3ad68ea616e79d98588102" name="a5de213f18a3ad68ea616e79d98588102"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_code16_bit</b> (void) const</td></tr>
<tr class="memdesc:a5de213f18a3ad68ea616e79d98588102"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#a093a9b13e2971a7b43349b8c4ab036c4" title="low bit of code addresses has special meaning e.g.">PR2_CODE16_BIT</a> <br /></td></tr>
<tr class="separator:a5de213f18a3ad68ea616e79d98588102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6b873b4606c27db1ffc8b513d41f36"><td class="memItemLeft" align="right" valign="top"><a id="a8c6b873b4606c27db1ffc8b513d41f36" name="a8c6b873b4606c27db1ffc8b513d41f36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supports_macros</b> (void) const</td></tr>
<tr class="memdesc:a8c6b873b4606c27db1ffc8b513d41f36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#aa73045643e62df8bc638034e9bda677a" title="processor supports macro instructions">PR2_MACRO</a> <br /></td></tr>
<tr class="separator:a8c6b873b4606c27db1ffc8b513d41f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf401a6b8f22688ed06b5e8a5b867c1e"><td class="memItemLeft" align="right" valign="top"><a id="abf401a6b8f22688ed06b5e8a5b867c1e" name="abf401a6b8f22688ed06b5e8a5b867c1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supports_calcrel</b> (void) const</td></tr>
<tr class="memdesc:abf401a6b8f22688ed06b5e8a5b867c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#a31691bd53e302e0d0ebd167e74e55d82" title="(Lumina) the module supports calcrel info">PR2_USE_CALCREL</a> <br /></td></tr>
<tr class="separator:abf401a6b8f22688ed06b5e8a5b867c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a3a69eb60855833fc384854a6f46c3"><td class="memItemLeft" align="right" valign="top"><a id="a84a3a69eb60855833fc384854a6f46c3" name="a84a3a69eb60855833fc384854a6f46c3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>calcrel_in_bits</b> (void) const</td></tr>
<tr class="memdesc:a84a3a69eb60855833fc384854a6f46c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="idp_8hpp.html#ad4ccb1c3c566224db8b0a288bab11388" title="(Lumina) calcrel info has bits granularity, not bytes - construction flag only">PR2_REL_BITS</a> <br /></td></tr>
<tr class="separator:a84a3a69eb60855833fc384854a6f46c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a0f415add42933cb196bec15d66b11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a94a0f415add42933cb196bec15d66b11">get_default_segm_bitness</a> (bool is_64bit_app) const</td></tr>
<tr class="memdesc:a94a0f415add42933cb196bec15d66b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default segment bitness.  <a href="structprocessor__t.html#a94a0f415add42933cb196bec15d66b11">More...</a><br /></td></tr>
<tr class="separator:a94a0f415add42933cb196bec15d66b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Byte size</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Number of 8bit bytes required to hold one byte of the target processor.</p>
</div></td></tr>
<tr class="memitem:a33f991813d3e0cc28375d5330dd246f3"><td class="memItemLeft" align="right" valign="top"><a id="a33f991813d3e0cc28375d5330dd246f3" name="a33f991813d3e0cc28375d5330dd246f3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cbsize</b> (void)</td></tr>
<tr class="memdesc:a33f991813d3e0cc28375d5330dd246f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">for code segments <br /></td></tr>
<tr class="separator:a33f991813d3e0cc28375d5330dd246f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d79d528bb32036ab8d76d102ee0037f"><td class="memItemLeft" align="right" valign="top"><a id="a3d79d528bb32036ab8d76d102ee0037f" name="a3d79d528bb32036ab8d76d102ee0037f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dbsize</b> (void)</td></tr>
<tr class="memdesc:a3d79d528bb32036ab8d76d102ee0037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">for non-code segments <br /></td></tr>
<tr class="separator:a3d79d528bb32036ab8d76d102ee0037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad15b68b6bdef844bb4481f9535878a2a"><td class="memItemLeft" align="right" valign="top"><a id="ad15b68b6bdef844bb4481f9535878a2a" name="ad15b68b6bdef844bb4481f9535878a2a"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>version</b></td></tr>
<tr class="memdesc:ad15b68b6bdef844bb4481f9535878a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected kernel version, should be <a class="el" href="idp_8hpp.html#af4b4e4966302754b758c8cc16f964a15" title="The interface version number.">IDP_INTERFACE_VERSION</a>. <br /></td></tr>
<tr class="separator:ad15b68b6bdef844bb4481f9535878a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6df0facf50afe9dee4716f69739244f"><td class="memItemLeft" align="right" valign="top"><a id="ad6df0facf50afe9dee4716f69739244f" name="ad6df0facf50afe9dee4716f69739244f"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>id</b></td></tr>
<tr class="memdesc:ad6df0facf50afe9dee4716f69739244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">one of <a class="el" href="group___p_l_f_m__.html">Processor IDs</a> <br /></td></tr>
<tr class="separator:ad6df0facf50afe9dee4716f69739244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6542af67172bea21cda8b81c6671d775"><td class="memItemLeft" align="right" valign="top"><a id="a6542af67172bea21cda8b81c6671d775" name="a6542af67172bea21cda8b81c6671d775"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>flag</b></td></tr>
<tr class="memdesc:a6542af67172bea21cda8b81c6671d775"><td class="mdescLeft">&#160;</td><td class="mdescRight">an ORed combination of <a class="el" href="group___p_r__.html">Processor feature bits</a> <br /></td></tr>
<tr class="separator:a6542af67172bea21cda8b81c6671d775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bbec9142e5695cda6294a9fe85a59c"><td class="memItemLeft" align="right" valign="top"><a id="ab9bbec9142e5695cda6294a9fe85a59c" name="ab9bbec9142e5695cda6294a9fe85a59c"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>flag2</b></td></tr>
<tr class="memdesc:ab9bbec9142e5695cda6294a9fe85a59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">an ORed combination of <a class="el" href="group___p_r2__.html">Processor additional feature bits</a> <br /></td></tr>
<tr class="separator:ab9bbec9142e5695cda6294a9fe85a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86f81b3e716d4bf17f424688cf5aeab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ae86f81b3e716d4bf17f424688cf5aeab">cnbits</a></td></tr>
<tr class="memdesc:ae86f81b3e716d4bf17f424688cf5aeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in a byte for code segments (usually 8).  <a href="structprocessor__t.html#ae86f81b3e716d4bf17f424688cf5aeab">More...</a><br /></td></tr>
<tr class="separator:ae86f81b3e716d4bf17f424688cf5aeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c90b8e3ee733f9f843fc6297bd1977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a94c90b8e3ee733f9f843fc6297bd1977">dnbits</a></td></tr>
<tr class="memdesc:a94c90b8e3ee733f9f843fc6297bd1977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in a byte for non-code segments (usually 8).  <a href="structprocessor__t.html#a94c90b8e3ee733f9f843fc6297bd1977">More...</a><br /></td></tr>
<tr class="separator:a94c90b8e3ee733f9f843fc6297bd1977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment registers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Segment register information (use virtual CS and DS registers if your processor doesn't have segment registers): </p>
</div></td></tr>
<tr class="memitem:a4206e35bf99d211c18d53bd1035eb2e3"><td class="memItemLeft" align="right" valign="top"><a id="a4206e35bf99d211c18d53bd1035eb2e3" name="a4206e35bf99d211c18d53bd1035eb2e3"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reg_first_sreg</b></td></tr>
<tr class="memdesc:a4206e35bf99d211c18d53bd1035eb2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of first segment register <br /></td></tr>
<tr class="separator:a4206e35bf99d211c18d53bd1035eb2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f70771df2d04aefdfe0d9b7e546d4e"><td class="memItemLeft" align="right" valign="top"><a id="aa2f70771df2d04aefdfe0d9b7e546d4e" name="aa2f70771df2d04aefdfe0d9b7e546d4e"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reg_last_sreg</b></td></tr>
<tr class="memdesc:aa2f70771df2d04aefdfe0d9b7e546d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of last segment register <br /></td></tr>
<tr class="separator:aa2f70771df2d04aefdfe0d9b7e546d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811665eba68bd3606023c09af8f85705"><td class="memItemLeft" align="right" valign="top"><a id="a811665eba68bd3606023c09af8f85705" name="a811665eba68bd3606023c09af8f85705"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>segreg_size</b></td></tr>
<tr class="memdesc:a811665eba68bd3606023c09af8f85705"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of a segment register in bytes <br /></td></tr>
<tr class="separator:a811665eba68bd3606023c09af8f85705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual segment registers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >If your processor doesn't have segment registers, you should define 2 virtual segment registers for CS and DS.</p>
<p >Let's call them rVcs and rVds. </p>
</div></td></tr>
<tr class="memitem:a8c1090cef7d02b379600a8049cd4d25f"><td class="memItemLeft" align="right" valign="top"><a id="a8c1090cef7d02b379600a8049cd4d25f" name="a8c1090cef7d02b379600a8049cd4d25f"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reg_code_sreg</b></td></tr>
<tr class="memdesc:a8c1090cef7d02b379600a8049cd4d25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of CS register <br /></td></tr>
<tr class="separator:a8c1090cef7d02b379600a8049cd4d25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bc236f72fe8f6b2b06a8342de8c7ab"><td class="memItemLeft" align="right" valign="top"><a id="af0bc236f72fe8f6b2b06a8342de8c7ab" name="af0bc236f72fe8f6b2b06a8342de8c7ab"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>reg_data_sreg</b></td></tr>
<tr class="memdesc:af0bc236f72fe8f6b2b06a8342de8c7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of DS register <br /></td></tr>
<tr class="separator:af0bc236f72fe8f6b2b06a8342de8c7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Empirics</div></td></tr>
<tr class="memitem:a9414a4e585ab47514144871a585cc120"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbytes__t.html">bytes_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a9414a4e585ab47514144871a585cc120">codestart</a></td></tr>
<tr class="memdesc:a9414a4e585ab47514144871a585cc120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of typical code start sequences.  <a href="structprocessor__t.html#a9414a4e585ab47514144871a585cc120">More...</a><br /></td></tr>
<tr class="separator:a9414a4e585ab47514144871a585cc120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3849caf742c36dc743f0aa88267221a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbytes__t.html">bytes_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab3849caf742c36dc743f0aa88267221a">retcodes</a></td></tr>
<tr class="memdesc:ab3849caf742c36dc743f0aa88267221a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of 'return' instruction opcodes.  <a href="structprocessor__t.html#ab3849caf742c36dc743f0aa88267221a">More...</a><br /></td></tr>
<tr class="separator:ab3849caf742c36dc743f0aa88267221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Names</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpcafd6a9e554bce844b3fb415747a3abe"></a>IDP module may support several compatible processors.</p>
<p >The following arrays define processor names: </p>
</td></tr>
<tr class="memitem:a2d184a313fab28b517e82c1717d562a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0">event_t</a> { <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8902d365f396d75e96a81c73b02ca13c">ev_init</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a93a414d2d7ac3eeee04c19853b53bd27">ev_term</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a190f0300a7e6ad8e090389f7b986e9f8">ev_newprc</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0af0b69a407fcdc6e5627901c6b3e5f4a6">ev_newasm</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0af544684794ac0f908ba551b0085482a9">ev_newfile</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae9430716ca6d6e53548863cce8fd839f">ev_oldfile</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a20b00ee7b8f4f3ce47579430ce3fa1c0">ev_newbinary</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0886df8414100bfdcaacf87a8ae165e7">ev_endbinary</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a77fb9c9858c9519da17acd2a2bc60391">ev_set_idp_options</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a47bcbd0313ef457a9ff2b6330ab80af3">ev_set_proc_options</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a108d52b9133787bd01c5ca8a7550f2e9">ev_ana_insn</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a82b81ce84c2257cb5a9176648e2fd6fc">ev_emu_insn</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac286cd442f5f923d434a9a420d2639e8">ev_out_header</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae78a32919dde7288ed2e816658081c2a">ev_out_footer</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae9a7ac704447bbbd50dface52b617807">ev_out_segstart</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a9153e7bd063780720b8761a8e7371a25">ev_out_segend</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abf9364c0e642488fac29f61f2b6d0e00">ev_out_assumes</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8edf4ec2bd23d42d3db641761b3156de">ev_out_insn</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a25783c63147edce4591595cba57d1fb3">ev_out_mnem</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8312057bdefad72948a26885372af286">ev_out_operand</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a960b08cf65ab07718b9c1eeab0f3288b">ev_out_data</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4fc4ad04d596de2dbea5694286bd461e">ev_out_label</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a15733589357bcc46d558536220edcb81">ev_out_special_item</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1790c885236860f938b0c7e983fac38f">ev_gen_stkvar_def</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a44268c939ffcc2e8c4c54a1c75796bc0">ev_gen_regvar_def</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0b636852302fb6ded9309c69cb984f75">ev_gen_src_file_lnnum</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a50e477c14c432b24b7415aa3d96f4a9d">ev_creating_segm</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa3c9018493b02e6d0e2b5a4ac7b7549b">ev_moving_segm</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a08fe9e01fa7424bd80e734a963c1b16a">ev_coagulate</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a326c50bb55c58af34774e6fbab74214c">ev_undefine</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae96a0913cd051a9a7861ff2d3514a370">ev_treat_hindering_item</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a2a2bb0b58f0b5ab62748063b0e601a0e">ev_rename</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa0a7a527f9e9cba6c406358fad2d4ab1">ev_is_far_jump</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aca1ba6609e0e3814c499511d513eb099">ev_is_sane_insn</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0addaf1f6a31bbefb8033c27edc0950cb8">ev_is_cond_insn</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa62d5d4207c7aee3967ab8abddb8c3c1">ev_is_call_insn</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abec6210c7336a864b70a7e5e94a9ac9d">ev_is_ret_insn</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a2e378dfbfccdef3feaa2da1bab69326e">ev_may_be_func</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a978a9e36b842dfe0e7380c3521fa2e1d">ev_is_basic_block_end</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a11d97a517b214dfde194a1de69e5e5ab">ev_is_indirect_jump</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0adeb44139bfc91c40cb8e3bd93659ca8e">ev_is_insn_table_jump</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a9d42d8c2836dceec7666e4b8eb6f71a1">ev_is_switch</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a98ff2357b62ae2783e781073a9549578">ev_calc_switch_cases</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ab1fe188a32b7e4eeedbbbcbe5066af56">ev_create_switch_xrefs</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4d200c0f82f9d32c4bda426aadc3e9dc">ev_is_align_insn</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ad25720c4c15166242743be03127e0a84">ev_is_alloca_probe</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0af754550ff044ee8ba2bf4b90037eb4b1">ev_delay_slot_insn</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aef2ae5d93a83201e69e626f1308ca21f">ev_is_sp_based</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a9b1b28b1c71c8d77861f528c78eade90">ev_can_have_type</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a2996b08408addef7f16b01180e2efdc3">ev_cmp_operands</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abf55189dd21fab945f35eab8fa9088cf">ev_adjust_refinfo</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae7391e79329dedc4bd100a629e61f569">ev_get_operand_string</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8dcc2b7307fb19045e6acf6d6016d89d">ev_get_reg_name</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aaddd272c33f61d746f850746a5451a9f">ev_str2reg</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0fa6560db645bbc4751b5cee7760cf30">ev_get_autocmt</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0de30b0749ce3401ec930a1904bcb274">ev_get_bg_color</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1f6f7128d8213f4433c5c94e16635aa7">ev_is_jump_func</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a54a6dfcb795c6d8167ebdb5116bcf579">ev_func_bounds</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a726a4a238e3c41a53777e5e04b911029">ev_verify_sp</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae161c5b9fbb789a4ed5a9e88539802f7">ev_verify_noreturn</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4e97147365c7e9487f57ffc2bd82894a">ev_create_func_frame</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a73d90e8e78294379f7efdb58e0fa4ca9">ev_get_frame_retsize</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae3c289592a68b9362e83fab157097cbf">ev_get_stkvar_scale_factor</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ad1283662b4901e2ea7d85af70bc7f817">ev_demangle_name</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a6362bc58103da0a115d1c15c3ce41fe1">ev_add_cref</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a64a7c332726e8a44498b879162e4d24f">ev_add_dref</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a58ace401d909f95b24a1e8fcae9810d4">ev_del_cref</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0affd5e295fef35e6175c3db5150ca5396">ev_del_dref</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a00c056a442c9524d2c7f7e90669c8275">ev_coagulate_dref</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1edb3d05f21feee48cf7d271032dcbc2">ev_may_show_sreg</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a268f12ba7873a0778460826a59e268aa">ev_loader_elf_machine</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0ca73f0b4d8eb1c319f668cb8c520b86">ev_auto_queue_empty</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aac26bb0ae2ef530084cbeb8c3078bd43">ev_validate_flirt_func</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1cf0dcb7a9e11a5220863ddb8722bd09">ev_adjust_libfunc_ea</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5f2ba1e8f4586958cc9cef0f514667e2">ev_assemble</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abe5d814d671bf8564be4212cefb61238">ev_extract_address</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5cccab69e499642d3873649769de31cf">ev_realcvt</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a87a749b6180d2fc6c4b4436df4eddc2f">ev_gen_asm_or_lst</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac4729fbc053f45a29a9370369eda3c21">ev_gen_map_file</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5fa3981e47a82bf57567c9e17fc69344">ev_create_flat_group</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5b7199e3af11fa25303602ba6093f307">ev_getreg</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ada84ccdbecd828227cf5891289d4a442">ev_analyze_prolog</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ad634ef51985fc184b924840188825199">ev_calc_spdelta</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a44113b21d13cb880233a52c38a84bea9">ev_calcrel</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a05a8170fb8a243187c118dbcaa1fd954">ev_find_reg_value</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac0cdca25f97d06dfa6630abfd371cfea">ev_find_op_value</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8455728c58bfbcf62ebed0a867319de0">ev_replaying_undo</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a218975038c561f744c6d6722f3adee1c">ev_ending_undo</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a656a70048be41e4ef0f3d4d68c7f7f68">ev_set_code16_mode</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0adce61dd59d050ab2257ba9430542fd1f">ev_get_code16_mode</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0508c681bd7d803d9a497b9df5071196">ev_get_procmod</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ab680db8c1398d0f42ecd7a8a6302a8ae">ev_asm_installed</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a793e05a7e4e3a941b127ab63b6c86bd0">ev_get_reg_accesses</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a585ff69fe61cd22e286dd82883668d20">ev_is_control_flow_guard</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0acd9fa1f52f1597fa56b0049f5c915f35">ev_broadcast</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a60d20a3db1d45b67e69038b0398ad960">ev_create_merge_handlers</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a48bb851e42954b7a88af840120207c3e">ev_privrange_changed</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a78fdb192b6eb8363352037dfd2e84e4e">ev_cvt64_supval</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1767b137277fc1b09f82992fef05e70e">ev_cvt64_hashval</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5776ce7324886d47497e6b55fa985c2f">ev_last_cb_before_debugger</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a035854be86d6e113db368eba96ec6a44">ev_next_exec_insn</a> = 1000
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa552c713d33cbf8b7088aa1279316279">ev_calc_step_over</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a15f393eb309882f724a87ba8680ed8b2">ev_calc_next_eas</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a2f4da6daaf29d96db466f024a41b6cd6">ev_get_macro_insn_head</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae19b6e2ec1f0f8dff6822e23d26ecf6f">ev_get_dbr_opnum</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a744ce375c380a22ef248cb5c8b2fe91e">ev_insn_reads_tbit</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a731a21b42e23b3a93212acc929590a44">ev_clean_tbit</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4c99f3d0cae242c834db12429824c412">ev_get_idd_opinfo</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac3cc0f61a972f10943ffcb9b512bbfcd">ev_get_reg_info</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ac347970270ca49b49cdf52a994eea7b6">ev_update_call_stack</a>
, <b>ev_last_cb_before_type_callbacks</b>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ab943223f3ca8d738c6a33aa2d1d5d5b2">ev_setup_til</a> = 2000
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa97519e3d4a7c838b5bea894471d1605">ev_get_abi_info</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aa72e8b0fefe1ccb4f97c3ab7d963403e">ev_max_ptr_size</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a445f041d8992406148c70d2265aeeaeb">ev_get_default_enum_size</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4d4579748c4e9235161552951f41243e">ev_get_cc_regs</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a1bf26205e3b0ebac0487c0d398774771">ev_obsolete1</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0abdf38950e08c904c24cf189f2f3be155">ev_obsolete2</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0afa23f72943023fbb22dbc682beca757c">ev_get_simd_types</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae4a7bab1ce8d51fef3323630c8ab5986">ev_calc_cdecl_purged_bytes</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a04dc0f7ffee5e8ce6d9bd2659f5fb48d">ev_calc_purged_bytes</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0d69f230a16256b7c97ec87e16a6f814">ev_calc_retloc</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8db94c9ea9bd7e6039821e897b952f82">ev_calc_arglocs</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a4537faf41cc6bd81946ec4cfd4b2db5a">ev_calc_varglocs</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ae6d879a79e41acf6c15241f8a8616413">ev_adjust_argloc</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0af54f85e43c332ae869c5e9015e1f3203">ev_lower_func_type</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0aacf3158cd80a47e0f87786c60f6f1b6a">ev_equal_reglocs</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a5551d04ee2e1a9f77a06ea2da02e5ffc">ev_use_stkarg_type</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a239afca977e96df72bf4680c8843662a">ev_use_regarg_type</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a97d8ef8f70c0d9e0e53726ab6cea7671">ev_use_arg_types</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a63c06a7cbeccfbc66ba9981ccde80e77">ev_arg_addrs_ready</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a8341bbf9f53b19f61d4d7adcdc51783b">ev_decorate_name</a>
, <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0ad7314c36f63706b4471231a362ff9fcc">ev_arch_changed</a>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a0047baea74fe2c1d040d1c1feeb48e8f">ev_get_stkarg_area_info</a>
, <b>ev_last_cb_before_loader</b>
, <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0a562fb16cff7e5e0c0f5750788c24d99c">ev_loader</a> =3000
<br />
 }</td></tr>
<tr class="memdesc:a2d184a313fab28b517e82c1717d562a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback notification codes.  <a href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0">More...</a><br /></td></tr>
<tr class="separator:a2d184a313fab28b517e82c1717d562a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9d0456ac951f143ebf192c644ab481"><td class="memItemLeft" align="right" valign="top"><a id="a4c9d0456ac951f143ebf192c644ab481" name="a4c9d0456ac951f143ebf192c644ab481"></a>
typedef const <a class="el" href="structregval__t.html">regval_t</a> &amp;idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>regval_getter_t</b>(const char *name, const <a class="el" href="structregval__t.html">regval_t</a> *regvalues)</td></tr>
<tr class="separator:a4c9d0456ac951f143ebf192c644ab481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f36c9be272d994bc341b3fcb78726f6"><td class="memItemLeft" align="right" valign="top">const char *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a7f36c9be272d994bc341b3fcb78726f6">psnames</a></td></tr>
<tr class="memdesc:a7f36c9be272d994bc341b3fcb78726f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">short processor names (nullptr terminated).  <a href="structprocessor__t.html#a7f36c9be272d994bc341b3fcb78726f6">More...</a><br /></td></tr>
<tr class="separator:a7f36c9be272d994bc341b3fcb78726f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="memItemLeft" align="right" valign="top">const char *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#adb54cc1d2faab6891ad190e2e5b7bf08">plnames</a></td></tr>
<tr class="memdesc:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">long processor names (nullptr terminated).  <a href="structprocessor__t.html#adb54cc1d2faab6891ad190e2e5b7bf08">More...</a><br /></td></tr>
<tr class="separator:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13faa23b7174cbdbae5da42c71602d24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structasm__t.html">asm_t</a> *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a13faa23b7174cbdbae5da42c71602d24">assemblers</a></td></tr>
<tr class="memdesc:a13faa23b7174cbdbae5da42c71602d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to array of target  <a href="structprocessor__t.html#a13faa23b7174cbdbae5da42c71602d24">More...</a><br /></td></tr>
<tr class="separator:a13faa23b7174cbdbae5da42c71602d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61e0933fe94a51df832da1cf0eb25fd"><td class="memItemLeft" align="right" valign="top"><a id="af61e0933fe94a51df832da1cf0eb25fd" name="af61e0933fe94a51df832da1cf0eb25fd"></a>
<a class="el" href="ida_8hpp.html#acf012fe005690e1af26e799617fc98b7">hook_cb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_notify</b></td></tr>
<tr class="memdesc:af61e0933fe94a51df832da1cf0eb25fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event notification handler. <br /></td></tr>
<tr class="separator:af61e0933fe94a51df832da1cf0eb25fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b75be7e30d134b1b288ab686c312307"><td class="memItemLeft" align="right" valign="top"><a id="a0b75be7e30d134b1b288ab686c312307" name="a0b75be7e30d134b1b288ab686c312307"></a>
const char *const  *&#160;</td><td class="memItemRight" valign="bottom"><b>reg_names</b></td></tr>
<tr class="memdesc:a0b75be7e30d134b1b288ab686c312307"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of register names <br /></td></tr>
<tr class="separator:a0b75be7e30d134b1b288ab686c312307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3a26dcb0ced65a3db134e0b2f90557"><td class="memItemLeft" align="right" valign="top"><a id="aec3a26dcb0ced65a3db134e0b2f90557" name="aec3a26dcb0ced65a3db134e0b2f90557"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>regs_num</b></td></tr>
<tr class="memdesc:aec3a26dcb0ced65a3db134e0b2f90557"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of registers <br /></td></tr>
<tr class="separator:aec3a26dcb0ced65a3db134e0b2f90557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107c1d598682bbc3fd8edb8d51ae6f4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a107c1d598682bbc3fd8edb8d51ae6f4e">get_proc_index</a> ()</td></tr>
<tr class="separator:a107c1d598682bbc3fd8edb8d51ae6f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0a8d4ae29c1edc4c327c83d725e622"><td class="memItemLeft" align="right" valign="top"><a id="a6c0a8d4ae29c1edc4c327c83d725e622" name="a6c0a8d4ae29c1edc4c327c83d725e622"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>delay_slot_insn</b> (ea_t *ea, bool *bexec, bool *fexec)</td></tr>
<tr class="memdesc:a6c0a8d4ae29c1edc4c327c83d725e622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to get the delay slot instruction. <br /></td></tr>
<tr class="separator:a6c0a8d4ae29c1edc4c327c83d725e622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a5aa65c22367c44ecbb9923e3daac9"><td class="memItemLeft" align="right" valign="top"><a id="a52a5aa65c22367c44ecbb9923e3daac9" name="a52a5aa65c22367c44ecbb9923e3daac9"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>privrange_changed</b> (const <a class="el" href="structrange__t.html">range_t</a> &amp;old_privrange, adiff_t delta, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf=nullptr)</td></tr>
<tr class="separator:a52a5aa65c22367c44ecbb9923e3daac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687487312a1109b331e91f0b0bcba9d9"><td class="memItemLeft" align="right" valign="top"><a id="a687487312a1109b331e91f0b0bcba9d9" name="a687487312a1109b331e91f0b0bcba9d9"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cvt64_supval</b> (nodeidx_t node, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> tag, nodeidx_t idx, const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *data, size_t datlen, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf=nullptr)</td></tr>
<tr class="separator:a687487312a1109b331e91f0b0bcba9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c52072d0ba763a20cfa124ea4890981"><td class="memItemLeft" align="right" valign="top"><a id="a7c52072d0ba763a20cfa124ea4890981" name="a7c52072d0ba763a20cfa124ea4890981"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cvt64_hashval</b> (nodeidx_t node, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> tag, const char *name, const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *data, size_t datlen, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf=nullptr)</td></tr>
<tr class="separator:a7c52072d0ba763a20cfa124ea4890981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#abe691f9f3c80817bd9d1e19e8ee5f926">get_stkvar_scale</a> (void)</td></tr>
<tr class="memdesc:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack variable scaling factor.  <a href="structprocessor__t.html#abe691f9f3c80817bd9d1e19e8ee5f926">More...</a><br /></td></tr>
<tr class="separator:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c27b9b57baad98304b3c6408d28734"><td class="memItemLeft" align="right" valign="top"><a id="a76c27b9b57baad98304b3c6408d28734" name="a76c27b9b57baad98304b3c6408d28734"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify</b> (<a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0">event_t</a> event_code,...)</td></tr>
<tr class="separator:a76c27b9b57baad98304b3c6408d28734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4455b93927159bd4a739b1aceb9983"><td class="memItemLeft" align="right" valign="top"><a id="afe4455b93927159bd4a739b1aceb9983" name="afe4455b93927159bd4a739b1aceb9983"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const char *idp_modname)</td></tr>
<tr class="separator:afe4455b93927159bd4a739b1aceb9983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdb462b00e97eda09f77262c0ee7d05"><td class="memItemLeft" align="right" valign="top"><a id="a6fdb462b00e97eda09f77262c0ee7d05" name="a6fdb462b00e97eda09f77262c0ee7d05"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>term</b> ()</td></tr>
<tr class="separator:a6fdb462b00e97eda09f77262c0ee7d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cdb19403d2ec8d52dadcea9bde398c"><td class="memItemLeft" align="right" valign="top"><a id="a75cdb19403d2ec8d52dadcea9bde398c" name="a75cdb19403d2ec8d52dadcea9bde398c"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newprc</b> (int pnum, bool keep_cfg)</td></tr>
<tr class="separator:a75cdb19403d2ec8d52dadcea9bde398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3f596cfa224ae0ea00941ce9a88668"><td class="memItemLeft" align="right" valign="top"><a id="a3c3f596cfa224ae0ea00941ce9a88668" name="a3c3f596cfa224ae0ea00941ce9a88668"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newasm</b> (int asmnum)</td></tr>
<tr class="separator:a3c3f596cfa224ae0ea00941ce9a88668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08191da603f8821ccf58e58062fbfa2"><td class="memItemLeft" align="right" valign="top"><a id="ac08191da603f8821ccf58e58062fbfa2" name="ac08191da603f8821ccf58e58062fbfa2"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>asm_installed</b> (int asmnum)</td></tr>
<tr class="separator:ac08191da603f8821ccf58e58062fbfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace44af71e6fd51d053ac4359b24b1e44"><td class="memItemLeft" align="right" valign="top"><a id="ace44af71e6fd51d053ac4359b24b1e44" name="ace44af71e6fd51d053ac4359b24b1e44"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newfile</b> (const char *fname)</td></tr>
<tr class="separator:ace44af71e6fd51d053ac4359b24b1e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bc2b0eadec32992263c68130e52a7b"><td class="memItemLeft" align="right" valign="top"><a id="a69bc2b0eadec32992263c68130e52a7b" name="a69bc2b0eadec32992263c68130e52a7b"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>oldfile</b> (const char *fname)</td></tr>
<tr class="separator:a69bc2b0eadec32992263c68130e52a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f8feec9912fc3e904b2ce0e6b22882"><td class="memItemLeft" align="right" valign="top"><a id="a90f8feec9912fc3e904b2ce0e6b22882" name="a90f8feec9912fc3e904b2ce0e6b22882"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>newbinary</b> (const char *filename, <a class="el" href="pro_8h.html#a42ae75d34f73b9e691bd16aaddb897e5">qoff64_t</a> fileoff, ea_t basepara, ea_t binoff, uint64 nbytes)</td></tr>
<tr class="separator:a90f8feec9912fc3e904b2ce0e6b22882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b3ede69991121dde94fc93a3e6310a"><td class="memItemLeft" align="right" valign="top"><a id="a73b3ede69991121dde94fc93a3e6310a" name="a73b3ede69991121dde94fc93a3e6310a"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>endbinary</b> (bool ok)</td></tr>
<tr class="separator:a73b3ede69991121dde94fc93a3e6310a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aa024d7c187aa63445d639d9f6ad08"><td class="memItemLeft" align="right" valign="top"><a id="ac1aa024d7c187aa63445d639d9f6ad08" name="ac1aa024d7c187aa63445d639d9f6ad08"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>creating_segm</b> (<a class="el" href="classsegment__t.html">segment_t</a> *seg)</td></tr>
<tr class="separator:ac1aa024d7c187aa63445d639d9f6ad08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102ecc9c3a1f4cc4be0b09cdbd00682f"><td class="memItemLeft" align="right" valign="top"><a id="a102ecc9c3a1f4cc4be0b09cdbd00682f" name="a102ecc9c3a1f4cc4be0b09cdbd00682f"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>assemble</b> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *_bin, ea_t ea, ea_t cs, ea_t ip, bool _use32, const char *line)</td></tr>
<tr class="separator:a102ecc9c3a1f4cc4be0b09cdbd00682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0ed52c3b18846b77d1336e7b800020"><td class="memItemLeft" align="right" valign="top"><a id="a1e0ed52c3b18846b77d1336e7b800020" name="a1e0ed52c3b18846b77d1336e7b800020"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ana_insn</b> (<a class="el" href="classinsn__t.html">insn_t</a> *out)</td></tr>
<tr class="separator:a1e0ed52c3b18846b77d1336e7b800020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a1eac3d08be7b3c6669dbff4ed674c"><td class="memItemLeft" align="right" valign="top"><a id="a73a1eac3d08be7b3c6669dbff4ed674c" name="a73a1eac3d08be7b3c6669dbff4ed674c"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>emu_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a73a1eac3d08be7b3c6669dbff4ed674c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d4ea97428d53055fc0be13063006d7"><td class="memItemLeft" align="right" valign="top"><a id="a25d4ea97428d53055fc0be13063006d7" name="a25d4ea97428d53055fc0be13063006d7"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_header</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:a25d4ea97428d53055fc0be13063006d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdf757042f18bee56b4de1537361f92"><td class="memItemLeft" align="right" valign="top"><a id="a8cdf757042f18bee56b4de1537361f92" name="a8cdf757042f18bee56b4de1537361f92"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_footer</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:a8cdf757042f18bee56b4de1537361f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd6a4db695b07493493be9bd04b66dd"><td class="memItemLeft" align="right" valign="top"><a id="acbd6a4db695b07493493be9bd04b66dd" name="acbd6a4db695b07493493be9bd04b66dd"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_segstart</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="classsegment__t.html">segment_t</a> *seg)</td></tr>
<tr class="separator:acbd6a4db695b07493493be9bd04b66dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ef517defad729421ace2aaea7e9e3d"><td class="memItemLeft" align="right" valign="top"><a id="aa0ef517defad729421ace2aaea7e9e3d" name="aa0ef517defad729421ace2aaea7e9e3d"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_segend</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="classsegment__t.html">segment_t</a> *seg)</td></tr>
<tr class="separator:aa0ef517defad729421ace2aaea7e9e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af958c9d126dfa1fe321ed5d4c4e0c2da"><td class="memItemLeft" align="right" valign="top"><a id="af958c9d126dfa1fe321ed5d4c4e0c2da" name="af958c9d126dfa1fe321ed5d4c4e0c2da"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_assumes</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:af958c9d126dfa1fe321ed5d4c4e0c2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2456e602cd6efaf827d6435047fe6542"><td class="memItemLeft" align="right" valign="top"><a id="a2456e602cd6efaf827d6435047fe6542" name="a2456e602cd6efaf827d6435047fe6542"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_insn</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:a2456e602cd6efaf827d6435047fe6542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fe55157acf58d4f160e7bf2d67e113"><td class="memItemLeft" align="right" valign="top"><a id="aa9fe55157acf58d4f160e7bf2d67e113" name="aa9fe55157acf58d4f160e7bf2d67e113"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_mnem</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx)</td></tr>
<tr class="separator:aa9fe55157acf58d4f160e7bf2d67e113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bb10446bca9768f91a6387ea643f8d"><td class="memItemLeft" align="right" valign="top"><a id="a28bb10446bca9768f91a6387ea643f8d" name="a28bb10446bca9768f91a6387ea643f8d"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_operand</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, const <a class="el" href="classop__t.html">op_t</a> &amp;op)</td></tr>
<tr class="separator:a28bb10446bca9768f91a6387ea643f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c612748f6fda218e44ea4cb018443c"><td class="memItemLeft" align="right" valign="top"><a id="a60c612748f6fda218e44ea4cb018443c" name="a60c612748f6fda218e44ea4cb018443c"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_data</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, bool analyze_only)</td></tr>
<tr class="separator:a60c612748f6fda218e44ea4cb018443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5d9adb678e9dde281f805a97b5df9c"><td class="memItemLeft" align="right" valign="top"><a id="a9c5d9adb678e9dde281f805a97b5df9c" name="a9c5d9adb678e9dde281f805a97b5df9c"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_label</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, const char *colored_name)</td></tr>
<tr class="separator:a9c5d9adb678e9dde281f805a97b5df9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee2af27607fc7c121c240ed224bef95"><td class="memItemLeft" align="right" valign="top"><a id="a4ee2af27607fc7c121c240ed224bef95" name="a4ee2af27607fc7c121c240ed224bef95"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>out_special_item</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> <a class="el" href="segment_8hpp.html#a67eaaed66c079e1ac389902d19046d20">segtype</a>)</td></tr>
<tr class="separator:a4ee2af27607fc7c121c240ed224bef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab073c3da05fbf7cc4174164d2ce443a5"><td class="memItemLeft" align="right" valign="top"><a id="ab073c3da05fbf7cc4174164d2ce443a5" name="ab073c3da05fbf7cc4174164d2ce443a5"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_stkvar_def</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, const class <a class="el" href="classmember__t.html">member_t</a> *mptr, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> v)</td></tr>
<tr class="separator:ab073c3da05fbf7cc4174164d2ce443a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72ad3c218fd059153065a1a75cec325"><td class="memItemLeft" align="right" valign="top"><a id="af72ad3c218fd059153065a1a75cec325" name="af72ad3c218fd059153065a1a75cec325"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_regvar_def</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="structregvar__t.html">regvar_t</a> *v)</td></tr>
<tr class="separator:af72ad3c218fd059153065a1a75cec325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbf45e468cd1e7b6a22d7ecacd64421"><td class="memItemLeft" align="right" valign="top"><a id="aabbf45e468cd1e7b6a22d7ecacd64421" name="aabbf45e468cd1e7b6a22d7ecacd64421"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_src_file_lnnum</b> (<a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, const char *file, size_t lnnum)</td></tr>
<tr class="separator:aabbf45e468cd1e7b6a22d7ecacd64421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e67df5efc18920e0bad7edf1344de"><td class="memItemLeft" align="right" valign="top"><a id="af02e67df5efc18920e0bad7edf1344de" name="af02e67df5efc18920e0bad7edf1344de"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>rename</b> (ea_t ea, const char *new_name, int flags)</td></tr>
<tr class="separator:af02e67df5efc18920e0bad7edf1344de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5af536c87b32cb6b7bd14fef625388"><td class="memItemLeft" align="right" valign="top"><a id="aba5af536c87b32cb6b7bd14fef625388" name="aba5af536c87b32cb6b7bd14fef625388"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>may_show_sreg</b> (ea_t current_ea)</td></tr>
<tr class="separator:aba5af536c87b32cb6b7bd14fef625388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b27ed6378b8fd45c704bfb3f5c4c37"><td class="memItemLeft" align="right" valign="top"><a id="af9b27ed6378b8fd45c704bfb3f5c4c37" name="af9b27ed6378b8fd45c704bfb3f5c4c37"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>coagulate</b> (ea_t start_ea)</td></tr>
<tr class="separator:af9b27ed6378b8fd45c704bfb3f5c4c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb3616729cfbca0713dd92767a12065"><td class="memItemLeft" align="right" valign="top"><a id="a9bb3616729cfbca0713dd92767a12065" name="a9bb3616729cfbca0713dd92767a12065"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>auto_queue_empty</b> (int type)</td></tr>
<tr class="separator:a9bb3616729cfbca0713dd92767a12065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58099ba9206ccb11760a1985e86f4bd5"><td class="memItemLeft" align="right" valign="top"><a id="a58099ba9206ccb11760a1985e86f4bd5" name="a58099ba9206ccb11760a1985e86f4bd5"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>func_bounds</b> (int *possible_return_code, <a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t max_func_end_ea)</td></tr>
<tr class="separator:a58099ba9206ccb11760a1985e86f4bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af821b38249e800915e8bce8671bd05d4"><td class="memItemLeft" align="right" valign="top"><a id="af821b38249e800915e8bce8671bd05d4" name="af821b38249e800915e8bce8671bd05d4"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>may_be_func</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int state)</td></tr>
<tr class="separator:af821b38249e800915e8bce8671bd05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53599f2c48a87e32cd14661aeeb2449"><td class="memItemLeft" align="right" valign="top"><a id="ad53599f2c48a87e32cd14661aeeb2449" name="ad53599f2c48a87e32cd14661aeeb2449"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_sane_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int no_crefs)</td></tr>
<tr class="separator:ad53599f2c48a87e32cd14661aeeb2449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c3d7186affb2d7906a812f7eda6e8"><td class="memItemLeft" align="right" valign="top"><a id="a794c3d7186affb2d7906a812f7eda6e8" name="a794c3d7186affb2d7906a812f7eda6e8"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_operands</b> (const <a class="el" href="classop__t.html">op_t</a> &amp;op1, const <a class="el" href="classop__t.html">op_t</a> &amp;op2)</td></tr>
<tr class="separator:a794c3d7186affb2d7906a812f7eda6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82efcd2d78094007ba01b896069680d2"><td class="memItemLeft" align="right" valign="top"><a id="a82efcd2d78094007ba01b896069680d2" name="a82efcd2d78094007ba01b896069680d2"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_jump_func</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t *jump_target, ea_t *func_pointer)</td></tr>
<tr class="separator:a82efcd2d78094007ba01b896069680d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac200f8e343964827402c5a7ddc97370b"><td class="memItemLeft" align="right" valign="top"><a id="ac200f8e343964827402c5a7ddc97370b" name="ac200f8e343964827402c5a7ddc97370b"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_basic_block_end</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, bool call_insn_stops_block)</td></tr>
<tr class="separator:ac200f8e343964827402c5a7ddc97370b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878d9447be6d7893c68acc8a7d86af2f"><td class="memItemLeft" align="right" valign="top"><a id="a878d9447be6d7893c68acc8a7d86af2f" name="a878d9447be6d7893c68acc8a7d86af2f"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getreg</b> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *rv, int regnum)</td></tr>
<tr class="separator:a878d9447be6d7893c68acc8a7d86af2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214f82f03f51c39fc7910d3e0f26fc4c"><td class="memItemLeft" align="right" valign="top"><a id="a214f82f03f51c39fc7910d3e0f26fc4c" name="a214f82f03f51c39fc7910d3e0f26fc4c"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>undefine</b> (ea_t ea)</td></tr>
<tr class="separator:a214f82f03f51c39fc7910d3e0f26fc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99650932e10c825fe5f3e099740516a"><td class="memItemLeft" align="right" valign="top"><a id="af99650932e10c825fe5f3e099740516a" name="af99650932e10c825fe5f3e099740516a"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>moving_segm</b> (<a class="el" href="classsegment__t.html">segment_t</a> *seg, ea_t to, int flags)</td></tr>
<tr class="separator:af99650932e10c825fe5f3e099740516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e543f76da81d49296b4826e0bf69e"><td class="memItemLeft" align="right" valign="top"><a id="a4a4e543f76da81d49296b4826e0bf69e" name="a4a4e543f76da81d49296b4826e0bf69e"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_sp_based</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, const <a class="el" href="classop__t.html">op_t</a> &amp;x)</td></tr>
<tr class="separator:a4a4e543f76da81d49296b4826e0bf69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78e1fca46a156b5c7e5e95e8b8778b3"><td class="memItemLeft" align="right" valign="top"><a id="ad78e1fca46a156b5c7e5e95e8b8778b3" name="ad78e1fca46a156b5c7e5e95e8b8778b3"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_far_jump</b> (int icode)</td></tr>
<tr class="separator:ad78e1fca46a156b5c7e5e95e8b8778b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4560c0ae3df7cd39f133601009b74935"><td class="memItemLeft" align="right" valign="top"><a id="a4560c0ae3df7cd39f133601009b74935" name="a4560c0ae3df7cd39f133601009b74935"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_call_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a4560c0ae3df7cd39f133601009b74935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd987acdacd3fe8d6e0146b4117d7af3"><td class="memItemLeft" align="right" valign="top"><a id="afd987acdacd3fe8d6e0146b4117d7af3" name="afd987acdacd3fe8d6e0146b4117d7af3"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_ret_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, bool strict)</td></tr>
<tr class="separator:afd987acdacd3fe8d6e0146b4117d7af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f9f3a712f524e1027345970ec28874"><td class="memItemLeft" align="right" valign="top"><a id="a70f9f3a712f524e1027345970ec28874" name="a70f9f3a712f524e1027345970ec28874"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_align_insn</b> (ea_t ea)</td></tr>
<tr class="separator:a70f9f3a712f524e1027345970ec28874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09baad5c693a6389bdf31131f48aaae2"><td class="memItemLeft" align="right" valign="top"><a id="a09baad5c693a6389bdf31131f48aaae2" name="a09baad5c693a6389bdf31131f48aaae2"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>can_have_type</b> (const <a class="el" href="classop__t.html">op_t</a> &amp;op)</td></tr>
<tr class="separator:a09baad5c693a6389bdf31131f48aaae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de0e633060f5493deddd8fc5e1a627d"><td class="memItemLeft" align="right" valign="top"><a id="a9de0e633060f5493deddd8fc5e1a627d" name="a9de0e633060f5493deddd8fc5e1a627d"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_stkvar_scale_factor</b> ()</td></tr>
<tr class="separator:a9de0e633060f5493deddd8fc5e1a627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73f75be94e1ca0af932acab98607582"><td class="memItemLeft" align="right" valign="top"><a id="ac73f75be94e1ca0af932acab98607582" name="ac73f75be94e1ca0af932acab98607582"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>demangle_name</b> (<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> *res, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const char *name, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> disable_mask, int demreq)</td></tr>
<tr class="separator:ac73f75be94e1ca0af932acab98607582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631343e64c1c8a430a17475a73a6761d"><td class="memItemLeft" align="right" valign="top"><a id="a631343e64c1c8a430a17475a73a6761d" name="a631343e64c1c8a430a17475a73a6761d"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_flat_group</b> (ea_t image_base, int bitness, sel_t dataseg_sel)</td></tr>
<tr class="separator:a631343e64c1c8a430a17475a73a6761d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cc4334a38a4b7fb2285fe38690a89c"><td class="memItemLeft" align="right" valign="top"><a id="ae0cc4334a38a4b7fb2285fe38690a89c" name="ae0cc4334a38a4b7fb2285fe38690a89c"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_alloca_probe</b> (ea_t ea)</td></tr>
<tr class="separator:ae0cc4334a38a4b7fb2285fe38690a89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf89e018a27e8b74dca757320d84c4e"><td class="memItemLeft" align="right" valign="top"><a id="afaf89e018a27e8b74dca757320d84c4e" name="afaf89e018a27e8b74dca757320d84c4e"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_reg_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, int reg, size_t width, int reghi)</td></tr>
<tr class="separator:afaf89e018a27e8b74dca757320d84c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b5134908d2957919ea3fb71e70a71f"><td class="memItemLeft" align="right" valign="top"><a id="a68b5134908d2957919ea3fb71e70a71f" name="a68b5134908d2957919ea3fb71e70a71f"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_asm_or_lst</b> (bool starting, FILE *fp, bool is_asm, int flags, void *outline)</td></tr>
<tr class="separator:a68b5134908d2957919ea3fb71e70a71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d13b140759388e5a7d164a51cb646b"><td class="memItemLeft" align="right" valign="top"><a id="a84d13b140759388e5a7d164a51cb646b" name="a84d13b140759388e5a7d164a51cb646b"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gen_map_file</b> (int *nlines, FILE *fp)</td></tr>
<tr class="separator:a84d13b140759388e5a7d164a51cb646b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3704c4a670f7f1c88952d841b82077b"><td class="memItemLeft" align="right" valign="top"><a id="ad3704c4a670f7f1c88952d841b82077b" name="ad3704c4a670f7f1c88952d841b82077b"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_autocmt</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:ad3704c4a670f7f1c88952d841b82077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038db11a69fa6d41c9ec4448fa9ea1d7"><td class="memItemLeft" align="right" valign="top"><a id="a038db11a69fa6d41c9ec4448fa9ea1d7" name="a038db11a69fa6d41c9ec4448fa9ea1d7"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>loader_elf_machine</b> (linput_t *li, int machine_type, const char **p_procname, proc_def_t **p_pd, elf_loader_t *ldr, reader_t *reader)</td></tr>
<tr class="separator:a038db11a69fa6d41c9ec4448fa9ea1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ab54716e46491bee53031452bb6647"><td class="memItemLeft" align="right" valign="top"><a id="ab8ab54716e46491bee53031452bb6647" name="ab8ab54716e46491bee53031452bb6647"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_indirect_jump</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:ab8ab54716e46491bee53031452bb6647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcae02a4f27ced49a33d8777cd61383d"><td class="memItemLeft" align="right" valign="top"><a id="afcae02a4f27ced49a33d8777cd61383d" name="afcae02a4f27ced49a33d8777cd61383d"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>verify_noreturn</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:afcae02a4f27ced49a33d8777cd61383d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ccf3c1c851aabc99b38e45d8b7c6a"><td class="memItemLeft" align="right" valign="top"><a id="ae67ccf3c1c851aabc99b38e45d8b7c6a" name="ae67ccf3c1c851aabc99b38e45d8b7c6a"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>verify_sp</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:ae67ccf3c1c851aabc99b38e45d8b7c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aaeed2010a17765bfbee51a2badff1"><td class="memItemLeft" align="right" valign="top"><a id="a94aaeed2010a17765bfbee51a2badff1" name="a94aaeed2010a17765bfbee51a2badff1"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_func_frame</b> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:a94aaeed2010a17765bfbee51a2badff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5678a9ccb588ae0f1293f272f1baf4ca"><td class="memItemLeft" align="right" valign="top"><a id="a5678a9ccb588ae0f1293f272f1baf4ca" name="a5678a9ccb588ae0f1293f272f1baf4ca"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_frame_retsize</b> (int *retsize, const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="separator:a5678a9ccb588ae0f1293f272f1baf4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2d29889d63b6339f65850abad123ab"><td class="memItemLeft" align="right" valign="top"><a id="a3f2d29889d63b6339f65850abad123ab" name="a3f2d29889d63b6339f65850abad123ab"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>analyze_prolog</b> (ea_t fct_ea)</td></tr>
<tr class="separator:a3f2d29889d63b6339f65850abad123ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff06716780f3c010dcf7cab0510a97c"><td class="memItemLeft" align="right" valign="top"><a id="a0ff06716780f3c010dcf7cab0510a97c" name="a0ff06716780f3c010dcf7cab0510a97c"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_spdelta</b> (<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> *spdelta, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;ins)</td></tr>
<tr class="separator:a0ff06716780f3c010dcf7cab0510a97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60806173870969caae0078ea8e52a55"><td class="memItemLeft" align="right" valign="top"><a id="af60806173870969caae0078ea8e52a55" name="af60806173870969caae0078ea8e52a55"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calcrel</b> (<a class="el" href="classbytevec__t.html">bytevec_t</a> *out_relbits, size_t *out_consumed, ea_t ea)</td></tr>
<tr class="separator:af60806173870969caae0078ea8e52a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb078391d1e75bdd40f03a18472f3f57"><td class="memItemLeft" align="right" valign="top"><a id="afb078391d1e75bdd40f03a18472f3f57" name="afb078391d1e75bdd40f03a18472f3f57"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_reg_accesses</b> (<a class="el" href="structreg__accesses__t.html">reg_accesses_t</a> *accvec, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int flags)</td></tr>
<tr class="separator:afb078391d1e75bdd40f03a18472f3f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a233b4bc92f3d87329cc40defdc305"><td class="memItemLeft" align="right" valign="top"><a id="aa7a233b4bc92f3d87329cc40defdc305" name="aa7a233b4bc92f3d87329cc40defdc305"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_control_flow_guard</b> (int *p_reg, const <a class="el" href="classinsn__t.html">insn_t</a> *insn)</td></tr>
<tr class="separator:aa7a233b4bc92f3d87329cc40defdc305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b496cc4ca56c43de481378e3fc51d26"><td class="memItemLeft" align="right" valign="top"><a id="a2b496cc4ca56c43de481378e3fc51d26" name="a2b496cc4ca56c43de481378e3fc51d26"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_reg_value</b> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *out, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int reg)</td></tr>
<tr class="separator:a2b496cc4ca56c43de481378e3fc51d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349c65dc5c4204ed874ec04615542933"><td class="memItemLeft" align="right" valign="top"><a id="a349c65dc5c4204ed874ec04615542933" name="a349c65dc5c4204ed874ec04615542933"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_op_value</b> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *out, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int op)</td></tr>
<tr class="separator:a349c65dc5c4204ed874ec04615542933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8246288739eb1f5b7f6f74e56e9361"><td class="memItemLeft" align="right" valign="top"><a id="aed8246288739eb1f5b7f6f74e56e9361" name="aed8246288739eb1f5b7f6f74e56e9361"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>treat_hindering_item</b> (ea_t hindering_item_ea, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> new_item_flags, ea_t new_item_ea, asize_t new_item_length)</td></tr>
<tr class="separator:aed8246288739eb1f5b7f6f74e56e9361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a5009b32f51a909194731b6161eaa5"><td class="memItemLeft" align="right" valign="top"><a id="a77a5009b32f51a909194731b6161eaa5" name="a77a5009b32f51a909194731b6161eaa5"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extract_address</b> (ea_t *out_ea, ea_t screen_ea, const char *string, size_t x)</td></tr>
<tr class="separator:a77a5009b32f51a909194731b6161eaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf543ba00d87622e9faf2929a0b91ff"><td class="memItemLeft" align="right" valign="top"><a id="a3bf543ba00d87622e9faf2929a0b91ff" name="a3bf543ba00d87622e9faf2929a0b91ff"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>str2reg</b> (const char *regname)</td></tr>
<tr class="separator:a3bf543ba00d87622e9faf2929a0b91ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cede3a0bb6b279184b88668378a19bf"><td class="memItemLeft" align="right" valign="top"><a id="a5cede3a0bb6b279184b88668378a19bf" name="a5cede3a0bb6b279184b88668378a19bf"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_switch</b> (<a class="el" href="structswitch__info__t.html">switch_info_t</a> *si, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a5cede3a0bb6b279184b88668378a19bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d641dc226ea211d45d356958b6c62b6"><td class="memItemLeft" align="right" valign="top"><a id="a4d641dc226ea211d45d356958b6c62b6" name="a4d641dc226ea211d45d356958b6c62b6"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_switch_xrefs</b> (ea_t jumpea, const <a class="el" href="structswitch__info__t.html">switch_info_t</a> &amp;si)</td></tr>
<tr class="separator:a4d641dc226ea211d45d356958b6c62b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00786d3a5112c0c701c0812b70cce7b"><td class="memItemLeft" align="right" valign="top"><a id="ad00786d3a5112c0c701c0812b70cce7b" name="ad00786d3a5112c0c701c0812b70cce7b"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_switch_cases</b> (void *casevec, <a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> *targets, ea_t insn_ea, const <a class="el" href="structswitch__info__t.html">switch_info_t</a> &amp;si)</td></tr>
<tr class="separator:ad00786d3a5112c0c701c0812b70cce7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b152f1569df75ff8b07475d0d61400"><td class="memItemLeft" align="right" valign="top"><a id="ad1b152f1569df75ff8b07475d0d61400" name="ad1b152f1569df75ff8b07475d0d61400"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_bg_color</b> (<a class="el" href="pro_8h.html#a3df5040891132e50157aee66affdf1de">bgcolor_t</a> *color, ea_t ea)</td></tr>
<tr class="separator:ad1b152f1569df75ff8b07475d0d61400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228b1e8ae1967aeed13c833505960841"><td class="memItemLeft" align="right" valign="top"><a id="a228b1e8ae1967aeed13c833505960841" name="a228b1e8ae1967aeed13c833505960841"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>validate_flirt_func</b> (ea_t start_ea, const char *funcname)</td></tr>
<tr class="separator:a228b1e8ae1967aeed13c833505960841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe8ce656f1e2b0c182b4cca3fdf4ddb"><td class="memItemLeft" align="right" valign="top"><a id="a1fe8ce656f1e2b0c182b4cca3fdf4ddb" name="a1fe8ce656f1e2b0c182b4cca3fdf4ddb"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_operand_string</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int opnum)</td></tr>
<tr class="separator:a1fe8ce656f1e2b0c182b4cca3fdf4ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23279d562549c187c11e03be7276ede"><td class="memItemLeft" align="right" valign="top"><a id="ab23279d562549c187c11e03be7276ede" name="ab23279d562549c187c11e03be7276ede"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_cref</b> (ea_t from, ea_t to, <a class="el" href="xref_8hpp.html#a44e2b79869a9595bbe6265ff2026aa98">cref_t</a> type)</td></tr>
<tr class="separator:ab23279d562549c187c11e03be7276ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53858ff5ffd6177105af3b586a7b9ac2"><td class="memItemLeft" align="right" valign="top"><a id="a53858ff5ffd6177105af3b586a7b9ac2" name="a53858ff5ffd6177105af3b586a7b9ac2"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>add_dref</b> (ea_t from, ea_t to, <a class="el" href="xref_8hpp.html#a78aab6d0d6bd9cb4904bbdbb5ac4fa71">dref_t</a> type)</td></tr>
<tr class="separator:a53858ff5ffd6177105af3b586a7b9ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801ecdbeea89a3837b4f36cbed3e9731"><td class="memItemLeft" align="right" valign="top"><a id="a801ecdbeea89a3837b4f36cbed3e9731" name="a801ecdbeea89a3837b4f36cbed3e9731"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>del_cref</b> (ea_t from, ea_t to, bool expand)</td></tr>
<tr class="separator:a801ecdbeea89a3837b4f36cbed3e9731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6cac468cc484e58f8b9d3d8ba119c"><td class="memItemLeft" align="right" valign="top"><a id="abfd6cac468cc484e58f8b9d3d8ba119c" name="abfd6cac468cc484e58f8b9d3d8ba119c"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>del_dref</b> (ea_t from, ea_t to)</td></tr>
<tr class="separator:abfd6cac468cc484e58f8b9d3d8ba119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60ba3abf604d807a566d90eb07f7951"><td class="memItemLeft" align="right" valign="top"><a id="ab60ba3abf604d807a566d90eb07f7951" name="ab60ba3abf604d807a566d90eb07f7951"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>coagulate_dref</b> (ea_t from, ea_t to, bool may_define, ea_t *code_ea)</td></tr>
<tr class="separator:ab60ba3abf604d807a566d90eb07f7951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8582e229c6cadff4608608ab395379eb"><td class="memItemLeft" align="right" valign="top"><a id="a8582e229c6cadff4608608ab395379eb" name="a8582e229c6cadff4608608ab395379eb"></a>
static const char *&#160;</td><td class="memItemRight" valign="bottom"><b>set_idp_options</b> (const char *keyword, int vtype, const void *value, bool idb_loaded=true)</td></tr>
<tr class="separator:a8582e229c6cadff4608608ab395379eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d1a97c50ce5628b96cf83ab5e1966e"><td class="memItemLeft" align="right" valign="top"><a id="ab6d1a97c50ce5628b96cf83ab5e1966e" name="ab6d1a97c50ce5628b96cf83ab5e1966e"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set_proc_options</b> (const char *options, int confidence)</td></tr>
<tr class="separator:ab6d1a97c50ce5628b96cf83ab5e1966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e3f0e75719891fd0fc77a04d8f4d1e"><td class="memItemLeft" align="right" valign="top"><a id="a67e3f0e75719891fd0fc77a04d8f4d1e" name="a67e3f0e75719891fd0fc77a04d8f4d1e"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_libfunc_ea</b> (const idasgn_t &amp;sig, const libfunc_t &amp;libfun, ea_t *ea)</td></tr>
<tr class="separator:a67e3f0e75719891fd0fc77a04d8f4d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd934df43d5c489b3df7eb8fe8f592a5"><td class="memItemLeft" align="right" valign="top"><a id="abd934df43d5c489b3df7eb8fe8f592a5" name="abd934df43d5c489b3df7eb8fe8f592a5"></a>
static <a class="el" href="ieee_8h.html#a7abe91eb5ac1a76acc0683ef9ce48387">fpvalue_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>realcvt</b> (void *m, <a class="el" href="structfpvalue__t.html">fpvalue_t</a> *e, <a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> swt)</td></tr>
<tr class="separator:abd934df43d5c489b3df7eb8fe8f592a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3813014133afb596fa535507da8b13"><td class="memItemLeft" align="right" valign="top"><a id="aaf3813014133afb596fa535507da8b13" name="aaf3813014133afb596fa535507da8b13"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_refinfo</b> (<a class="el" href="structrefinfo__t.html">refinfo_t</a> *ri, ea_t ea, int n, const <a class="el" href="structfixup__data__t.html">fixup_data_t</a> &amp;fd)</td></tr>
<tr class="separator:aaf3813014133afb596fa535507da8b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba085249f03d19e71da9a0c682f745"><td class="memItemLeft" align="right" valign="top"><a id="a53ba085249f03d19e71da9a0c682f745" name="a53ba085249f03d19e71da9a0c682f745"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_cond_insn</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:a53ba085249f03d19e71da9a0c682f745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7f8090af3857968bd5b41a779adf2f"><td class="memItemLeft" align="right" valign="top"><a id="a2b7f8090af3857968bd5b41a779adf2f" name="a2b7f8090af3857968bd5b41a779adf2f"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set_code16_mode</b> (ea_t ea, bool code16=true)</td></tr>
<tr class="separator:a2b7f8090af3857968bd5b41a779adf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e04434f829f9087edfc8bd75956f02"><td class="memItemLeft" align="right" valign="top"><a id="a72e04434f829f9087edfc8bd75956f02" name="a72e04434f829f9087edfc8bd75956f02"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_code16_mode</b> (ea_t ea)</td></tr>
<tr class="separator:a72e04434f829f9087edfc8bd75956f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dc1c11df02efdbc887058c43e2a7bd"><td class="memItemLeft" align="right" valign="top"><a id="ae5dc1c11df02efdbc887058c43e2a7bd" name="ae5dc1c11df02efdbc887058c43e2a7bd"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>next_exec_insn</b> (ea_t *target, ea_t ea, int tid, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:ae5dc1c11df02efdbc887058c43e2a7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc297252269d28783d8de07a9ae5edb9"><td class="memItemLeft" align="right" valign="top"><a id="abc297252269d28783d8de07a9ae5edb9" name="abc297252269d28783d8de07a9ae5edb9"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_step_over</b> (ea_t *target, ea_t ip)</td></tr>
<tr class="separator:abc297252269d28783d8de07a9ae5edb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e1bd1a431a9cdd609c3ae7efc4d4f0"><td class="memItemLeft" align="right" valign="top"><a id="ad5e1bd1a431a9cdd609c3ae7efc4d4f0" name="ad5e1bd1a431a9cdd609c3ae7efc4d4f0"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_macro_insn_head</b> (ea_t *head, ea_t ip)</td></tr>
<tr class="separator:ad5e1bd1a431a9cdd609c3ae7efc4d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0511005068143520af107e4b5c3b87"><td class="memItemLeft" align="right" valign="top"><a id="ade0511005068143520af107e4b5c3b87" name="ade0511005068143520af107e4b5c3b87"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_dbr_opnum</b> (int *opnum, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn)</td></tr>
<tr class="separator:ade0511005068143520af107e4b5c3b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438356b412773f944dad961cbe478972"><td class="memItemLeft" align="right" valign="top"><a id="a438356b412773f944dad961cbe478972" name="a438356b412773f944dad961cbe478972"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insn_reads_tbit</b> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:a438356b412773f944dad961cbe478972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0b2efa4b12d83851d0fc8375273ef5"><td class="memItemLeft" align="right" valign="top"><a id="aca0b2efa4b12d83851d0fc8375273ef5" name="aca0b2efa4b12d83851d0fc8375273ef5"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_idd_opinfo</b> (<a class="el" href="structidd__opinfo__t.html">idd_opinfo_t</a> *opinf, ea_t ea, int n, int thread_id, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:aca0b2efa4b12d83851d0fc8375273ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4633e0ee514204edf08003c09cb9f4"><td class="memItemLeft" align="right" valign="top"><a id="a5f4633e0ee514204edf08003c09cb9f4" name="a5f4633e0ee514204edf08003c09cb9f4"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_next_eas</b> (<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> *res, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, bool over)</td></tr>
<tr class="separator:a5f4633e0ee514204edf08003c09cb9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a8c993a7f25cad72a542a2f60a3c44"><td class="memItemLeft" align="right" valign="top"><a id="a23a8c993a7f25cad72a542a2f60a3c44" name="a23a8c993a7f25cad72a542a2f60a3c44"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>clean_tbit</b> (ea_t ea, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:a23a8c993a7f25cad72a542a2f60a3c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d0cfc92bf4cb082e74da3cf18020a5"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a03d0cfc92bf4cb082e74da3cf18020a5">get_reg_info</a> (const char *regname, <a class="el" href="classbitrange__t.html">bitrange_t</a> *bitrange)</td></tr>
<tr class="memdesc:a03d0cfc92bf4cb082e74da3cf18020a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get register information - useful for registers like al, ah, dil, etc.  <a href="structprocessor__t.html#a03d0cfc92bf4cb082e74da3cf18020a5">More...</a><br /></td></tr>
<tr class="separator:a03d0cfc92bf4cb082e74da3cf18020a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7313afe266f6065c815b087e399abd"><td class="memItemLeft" align="right" valign="top"><a id="a7e7313afe266f6065c815b087e399abd" name="a7e7313afe266f6065c815b087e399abd"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>update_call_stack</b> (<a class="el" href="structcall__stack__t.html">call_stack_t</a> *stack, int tid, regval_getter_t *_getreg, const <a class="el" href="structregval__t.html">regval_t</a> &amp;regvalues)</td></tr>
<tr class="separator:a7e7313afe266f6065c815b087e399abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498288d0b0eae31e23cd7a1275e87506"><td class="memItemLeft" align="right" valign="top"><a id="a498288d0b0eae31e23cd7a1275e87506" name="a498288d0b0eae31e23cd7a1275e87506"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setup_til</b> ()</td></tr>
<tr class="separator:a498288d0b0eae31e23cd7a1275e87506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6339fd474606e98afb912ced953f90ae"><td class="memItemLeft" align="right" valign="top"><a id="a6339fd474606e98afb912ced953f90ae" name="a6339fd474606e98afb912ced953f90ae"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max_ptr_size</b> ()</td></tr>
<tr class="separator:a6339fd474606e98afb912ced953f90ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20e7e184653527a2bae6289d617aa59"><td class="memItemLeft" align="right" valign="top"><a id="ac20e7e184653527a2bae6289d617aa59" name="ac20e7e184653527a2bae6289d617aa59"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_cdecl_purged_bytes</b> (ea_t ea)</td></tr>
<tr class="separator:ac20e7e184653527a2bae6289d617aa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54754ec1de88b7a5474a20cad3451d6a"><td class="memItemLeft" align="right" valign="top"><a id="a54754ec1de88b7a5474a20cad3451d6a" name="a54754ec1de88b7a5474a20cad3451d6a"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>equal_reglocs</b> (const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;a1, const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;a2)</td></tr>
<tr class="separator:a54754ec1de88b7a5474a20cad3451d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de2b62b2c8ab178465fcb7a28ba284a"><td class="memItemLeft" align="right" valign="top"><a id="a2de2b62b2c8ab178465fcb7a28ba284a" name="a2de2b62b2c8ab178465fcb7a28ba284a"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>decorate_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *outbuf, const char *name, bool mangle, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;type)</td></tr>
<tr class="separator:a2de2b62b2c8ab178465fcb7a28ba284a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d463eb05b2e3a885cbab2aa6cd8bc3"><td class="memItemLeft" align="right" valign="top"><a id="ab2d463eb05b2e3a885cbab2aa6cd8bc3" name="ab2d463eb05b2e3a885cbab2aa6cd8bc3"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_retloc</b> (<a class="el" href="classargloc__t.html">argloc_t</a> *retloc, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;rettype, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="separator:ab2d463eb05b2e3a885cbab2aa6cd8bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320436b85a408a6dcc5dd23d427448a"><td class="memItemLeft" align="right" valign="top"><a id="ae320436b85a408a6dcc5dd23d427448a" name="ae320436b85a408a6dcc5dd23d427448a"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_varglocs</b> (<a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *ftd, <a class="el" href="structregobjs__t.html">regobjs_t</a> *regs, <a class="el" href="structrelobj__t.html">relobj_t</a> *stkargs, int nfixed)</td></tr>
<tr class="separator:ae320436b85a408a6dcc5dd23d427448a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5182d510ab4bdc120fdf496be32cc258"><td class="memItemLeft" align="right" valign="top"><a id="a5182d510ab4bdc120fdf496be32cc258" name="a5182d510ab4bdc120fdf496be32cc258"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_arglocs</b> (<a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti)</td></tr>
<tr class="separator:a5182d510ab4bdc120fdf496be32cc258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ffbd809485b6b700094e3cd9b7d36f"><td class="memItemLeft" align="right" valign="top"><a id="a09ffbd809485b6b700094e3cd9b7d36f" name="a09ffbd809485b6b700094e3cd9b7d36f"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>use_stkarg_type</b> (ea_t ea, const <a class="el" href="structfuncarg__t.html">funcarg_t</a> &amp;arg)</td></tr>
<tr class="separator:a09ffbd809485b6b700094e3cd9b7d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b7c2da8779fef5d70223cf4b61ed3a"><td class="memItemLeft" align="right" valign="top"><a id="a19b7c2da8779fef5d70223cf4b61ed3a" name="a19b7c2da8779fef5d70223cf4b61ed3a"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>use_regarg_type</b> (int *idx, ea_t ea, void *rargs)</td></tr>
<tr class="separator:a19b7c2da8779fef5d70223cf4b61ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7a5f3f545b57cac7544785c23833c3"><td class="memItemLeft" align="right" valign="top"><a id="adf7a5f3f545b57cac7544785c23833c3" name="adf7a5f3f545b57cac7544785c23833c3"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>use_arg_types</b> (ea_t ea, <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti, void *rargs)</td></tr>
<tr class="separator:adf7a5f3f545b57cac7544785c23833c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb438896cb5f4d324a1ad0b85c998aa7"><td class="memItemLeft" align="right" valign="top"><a id="afb438896cb5f4d324a1ad0b85c998aa7" name="afb438896cb5f4d324a1ad0b85c998aa7"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>calc_purged_bytes</b> (int *p_purged_bytes, const <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> &amp;fti)</td></tr>
<tr class="separator:afb438896cb5f4d324a1ad0b85c998aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30db8dbbd4cc72b550b41de0c6c24ad7"><td class="memItemLeft" align="right" valign="top"><a id="a30db8dbbd4cc72b550b41de0c6c24ad7" name="a30db8dbbd4cc72b550b41de0c6c24ad7"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_stkarg_area_info</b> (<a class="el" href="structstkarg__area__info__t.html">stkarg_area_info_t</a> *out, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="separator:a30db8dbbd4cc72b550b41de0c6c24ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351577f6b72869301c5f4615ed25c0b5"><td class="memItemLeft" align="right" valign="top"><a id="a351577f6b72869301c5f4615ed25c0b5" name="a351577f6b72869301c5f4615ed25c0b5"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_cc_regs</b> (<a class="el" href="classcallregs__t.html">callregs_t</a> *regs, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="separator:a351577f6b72869301c5f4615ed25c0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1baac2e3217b150f98f2357e981badb"><td class="memItemLeft" align="right" valign="top"><a id="aa1baac2e3217b150f98f2357e981badb" name="aa1baac2e3217b150f98f2357e981badb"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_simd_types</b> (void *out, const <a class="el" href="structsimd__info__t.html">simd_info_t</a> *simd_attrs, const <a class="el" href="classargloc__t.html">argloc_t</a> *argloc, bool create_tifs)</td></tr>
<tr class="separator:aa1baac2e3217b150f98f2357e981badb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669da29a2a5a97cc93ea001519ee7c8a"><td class="memItemLeft" align="right" valign="top"><a id="a669da29a2a5a97cc93ea001519ee7c8a" name="a669da29a2a5a97cc93ea001519ee7c8a"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>arg_addrs_ready</b> (ea_t caller, int n, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, ea_t *addrs)</td></tr>
<tr class="separator:a669da29a2a5a97cc93ea001519ee7c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbbc88582a2915e87441569264c4208"><td class="memItemLeft" align="right" valign="top"><a id="a5bbbc88582a2915e87441569264c4208" name="a5bbbc88582a2915e87441569264c4208"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_argloc</b> (<a class="el" href="classargloc__t.html">argloc_t</a> *argloc, const <a class="el" href="classtinfo__t.html">tinfo_t</a> *type, int size)</td></tr>
<tr class="separator:a5bbbc88582a2915e87441569264c4208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbdfae149a1fd6417fdce6b90494461"><td class="memItemLeft" align="right" valign="top"><a id="a6dbdfae149a1fd6417fdce6b90494461" name="a6dbdfae149a1fd6417fdce6b90494461"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lower_func_type</b> (<a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *argnums, <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti)</td></tr>
<tr class="separator:a6dbdfae149a1fd6417fdce6b90494461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8043e53c1cfe729c6039e494098643"><td class="memItemLeft" align="right" valign="top"><a id="adc8043e53c1cfe729c6039e494098643" name="adc8043e53c1cfe729c6039e494098643"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_abi_info</b> (<a class="el" href="pro_8h.html#a823b67c620f6cdca97e1d969ea4a9b02">qstrvec_t</a> *abi_names, <a class="el" href="pro_8h.html#a823b67c620f6cdca97e1d969ea4a9b02">qstrvec_t</a> *abi_opts, <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a> comp)</td></tr>
<tr class="separator:adc8043e53c1cfe729c6039e494098643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f8b263456a94edeb6d3f31610ab6f2"><td class="memItemLeft" align="right" valign="top"><a id="a00f8b263456a94edeb6d3f31610ab6f2" name="a00f8b263456a94edeb6d3f31610ab6f2"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>arch_changed</b> ()</td></tr>
<tr class="separator:a00f8b263456a94edeb6d3f31610ab6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cc907db2abb06881801c25de2b4e80"><td class="memItemLeft" align="right" valign="top"><a id="ad6cc907db2abb06881801c25de2b4e80" name="ad6cc907db2abb06881801c25de2b4e80"></a>
static <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_merge_handlers</b> (merge_data_t *md)</td></tr>
<tr class="separator:ad6cc907db2abb06881801c25de2b4e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Instruction set</h2></td></tr>
<tr class="memitem:a35f080945b61116baab1bfc67f195f62"><td class="memItemLeft" align="right" valign="top"><a id="a35f080945b61116baab1bfc67f195f62" name="a35f080945b61116baab1bfc67f195f62"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instruc_start</b></td></tr>
<tr class="memdesc:a35f080945b61116baab1bfc67f195f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">icode of the first instruction <br /></td></tr>
<tr class="separator:a35f080945b61116baab1bfc67f195f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc594ff4b32014972b205b5c9b07deb"><td class="memItemLeft" align="right" valign="top"><a id="a5bc594ff4b32014972b205b5c9b07deb" name="a5bc594ff4b32014972b205b5c9b07deb"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>instruc_end</b></td></tr>
<tr class="memdesc:a5bc594ff4b32014972b205b5c9b07deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">icode of the last instruction + 1 <br /></td></tr>
<tr class="separator:a5bc594ff4b32014972b205b5c9b07deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb7cfbf39771b646cfc5e5d43259175"><td class="memItemLeft" align="right" valign="top"><a id="a6fb7cfbf39771b646cfc5e5d43259175" name="a6fb7cfbf39771b646cfc5e5d43259175"></a>
const <a class="el" href="structinstruc__t.html">instruc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>instruc</b></td></tr>
<tr class="memdesc:a6fb7cfbf39771b646cfc5e5d43259175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of instructions. <br /></td></tr>
<tr class="separator:a6fb7cfbf39771b646cfc5e5d43259175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="memItemLeft" align="right" valign="top"><a id="a7a1ea672e493ec9b59b6d3d8e09d69e1" name="a7a1ea672e493ec9b59b6d3d8e09d69e1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>tbyte_size</b></td></tr>
<tr class="memdesc:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of long double (tbyte) for this processor (meaningful only if <a class="el" href="structasm__t.html#a8bb6b6dcd51fbc50cc03fa5feeff39aa" title="long double; nullptr if not allowed">asm_t::a_tbyte</a> != nullptr) <br /></td></tr>
<tr class="separator:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ed6541f40864dcf175219db42afa90"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab1ed6541f40864dcf175219db42afa90">real_width</a> [4]</td></tr>
<tr class="memdesc:ab1ed6541f40864dcf175219db42afa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of digits in floating numbers after the decimal point.  <a href="structprocessor__t.html#ab1ed6541f40864dcf175219db42afa90">More...</a><br /></td></tr>
<tr class="separator:ab1ed6541f40864dcf175219db42afa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab497b14d9a38b3b5f04137d554c0e18d"><td class="memItemLeft" align="right" valign="top"><a id="ab497b14d9a38b3b5f04137d554c0e18d" name="ab497b14d9a38b3b5f04137d554c0e18d"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>icode_return</b></td></tr>
<tr class="memdesc:ab497b14d9a38b3b5f04137d554c0e18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Icode of return instruction. It is ok to give any of possible return instructions. <br /></td></tr>
<tr class="separator:ab497b14d9a38b3b5f04137d554c0e18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="memItemLeft" align="right" valign="top"><a id="a62aee2fa2fba2d3a642f730ff0e0c3e8" name="a62aee2fa2fba2d3a642f730ff0e0c3e8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>unused_slot</b></td></tr>
<tr class="memdesc:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved, currently equals to nullptr. <br /></td></tr>
<tr class="separator:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461e26b10900db7a5e6b843fe8ce7434"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a461e26b10900db7a5e6b843fe8ce7434">is_canon_insn</a> (<a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> itype) const</td></tr>
<tr class="memdesc:a461e26b10900db7a5e6b843fe8ce7434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given value specify a valid instruction for this instruction set?.  <a href="structprocessor__t.html#a461e26b10900db7a5e6b843fe8ce7434">More...</a><br /></td></tr>
<tr class="separator:a461e26b10900db7a5e6b843fe8ce7434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da6b0b9313b483280040240976469f5"><td class="memItemLeft" align="right" valign="top"><a id="a3da6b0b9313b483280040240976469f5" name="a3da6b0b9313b483280040240976469f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ensure_processor</b> (void)</td></tr>
<tr class="separator:a3da6b0b9313b483280040240976469f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2449ca9b8a0b387a8cf8ba9142f7dc96"><td class="memItemLeft" align="right" valign="top"><a id="a2449ca9b8a0b387a8cf8ba9142f7dc96" name="a2449ca9b8a0b387a8cf8ba9142f7dc96"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>sizeof_ldbl</b> () const</td></tr>
<tr class="memdesc:a2449ca9b8a0b387a8cf8ba9142f7dc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of long double. <br /></td></tr>
<tr class="separator:a2449ca9b8a0b387a8cf8ba9142f7dc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4ac33a626f87a4e10f32783173a780"><td class="memItemLeft" align="right" valign="top"><a id="add4ac33a626f87a4e10f32783173a780" name="add4ac33a626f87a4e10f32783173a780"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_funcarg_off</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> frameoff) const</td></tr>
<tr class="memdesc:add4ac33a626f87a4e10f32783173a780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given offset lie within the arguments section? <br /></td></tr>
<tr class="separator:add4ac33a626f87a4e10f32783173a780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddde8ecbaa8c1acc999bdec91ac0eef"><td class="memItemLeft" align="right" valign="top"><a id="a6ddde8ecbaa8c1acc999bdec91ac0eef" name="a6ddde8ecbaa8c1acc999bdec91ac0eef"></a>
<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lvar_off</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> frameoff) const</td></tr>
<tr class="memdesc:a6ddde8ecbaa8c1acc999bdec91ac0eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given offset lie within the local variables section? <br /></td></tr>
<tr class="separator:a6ddde8ecbaa8c1acc999bdec91ac0eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13957fc1f5d05a311a67521e4f3540f7"><td class="memItemLeft" align="right" valign="top"><a id="a13957fc1f5d05a311a67521e4f3540f7" name="a13957fc1f5d05a311a67521e4f3540f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_lumina_usable</b> () const</td></tr>
<tr class="separator:a13957fc1f5d05a311a67521e4f3540f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Describes a processor module (IDP). </p>
<p >An IDP file may have only one such structure called LPH. The kernel will copy it to ::ph structure and use ::ph. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a2d184a313fab28b517e82c1717d562a0" name="a2d184a313fab28b517e82c1717d562a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d184a313fab28b517e82c1717d562a0">&#9670;&nbsp;</a></span>event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structprocessor__t.html#a2d184a313fab28b517e82c1717d562a0">processor_t::event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback notification codes. </p>
<p >These are passed to notify() when certain events occur in the kernel, allowing the processor module to take the appropriate action.</p>
<p >If you are not developing a processor module, you do not need to use the codes directly many of them already have a corresponding function to use instead ( <a class="el" href="">is_call_insn</a> vs is_call_insn(ea_t), for example).</p>
<p >If you are developing a processor module, your notify() function must implement the desired behavior when called with a given code. Not all events need to be handled, some of them are optional. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a8902d365f396d75e96a81c73b02ca13c" name="a2d184a313fab28b517e82c1717d562a0a8902d365f396d75e96a81c73b02ca13c"></a>ev_init&#160;</td><td class="fielddoc"><p >The IDP module is just loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idp_modname</td><td>(const char *) processor module name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a93a414d2d7ac3eeee04c19853b53bd27" name="a2d184a313fab28b517e82c1717d562a0a93a414d2d7ac3eeee04c19853b53bd27"></a>ev_term&#160;</td><td class="fielddoc"><p >The IDP module is being unloaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a190f0300a7e6ad8e090389f7b986e9f8" name="a2d184a313fab28b517e82c1717d562a0a190f0300a7e6ad8e090389f7b986e9f8"></a>ev_newprc&#160;</td><td class="fielddoc"><p >Before changing processor type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnum</td><td>(int) processor number in the array of processor names </td></tr>
    <tr><td class="paramname">keep_cfg</td><td>(bool) true: do not modify kernel configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;0</td><td>prohibit </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0af0b69a407fcdc6e5627901c6b3e5f4a6" name="a2d184a313fab28b517e82c1717d562a0af0b69a407fcdc6e5627901c6b3e5f4a6"></a>ev_newasm&#160;</td><td class="fielddoc"><p >Before setting a new assembler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asmnum</td><td>(int) See also ev_asm_installed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0af544684794ac0f908ba551b0085482a9" name="a2d184a313fab28b517e82c1717d562a0af544684794ac0f908ba551b0085482a9"></a>ev_newfile&#160;</td><td class="fielddoc"><p >A new file has been loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>(char *) input file name </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae9430716ca6d6e53548863cce8fd839f" name="a2d184a313fab28b517e82c1717d562a0ae9430716ca6d6e53548863cce8fd839f"></a>ev_oldfile&#160;</td><td class="fielddoc"><p >An old file has been loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>(char *) input file name </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a20b00ee7b8f4f3ce47579430ce3fa1c0" name="a2d184a313fab28b517e82c1717d562a0a20b00ee7b8f4f3ce47579430ce3fa1c0"></a>ev_newbinary&#160;</td><td class="fielddoc"><p >IDA is about to load a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>(char *) binary file name </td></tr>
    <tr><td class="paramname">fileoff</td><td>(<a class="el" href="pro_8h.html#a42ae75d34f73b9e691bd16aaddb897e5" title="file offset">qoff64_t</a>) offset in the file </td></tr>
    <tr><td class="paramname">basepara</td><td>(::ea_t) base loading paragraph </td></tr>
    <tr><td class="paramname">binoff</td><td>(::ea_t) loader offset </td></tr>
    <tr><td class="paramname">nbytes</td><td>(::uint64) number of bytes to load </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a0886df8414100bfdcaacf87a8ae165e7" name="a2d184a313fab28b517e82c1717d562a0a0886df8414100bfdcaacf87a8ae165e7"></a>ev_endbinary&#160;</td><td class="fielddoc"><p >IDA has loaded a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ok</td><td>(bool) file loaded successfully? </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a77fb9c9858c9519da17acd2a2bc60391" name="a2d184a313fab28b517e82c1717d562a0a77fb9c9858c9519da17acd2a2bc60391"></a>ev_set_idp_options&#160;</td><td class="fielddoc"><p >Set IDP-specific configuration option Also see set_options_t in config.hpp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>(const char *) </td></tr>
    <tr><td class="paramname">value_type</td><td>(int) </td></tr>
    <tr><td class="paramname">value</td><td>(const void *) </td></tr>
    <tr><td class="paramname">errbuf</td><td>(const char **) - a error message will be returned here (can be nullptr) </td></tr>
    <tr><td class="paramname">idb_loaded</td><td>(bool) true if the ev_oldfile/ev_newfile events have been generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">-1</td><td>error (and message in errbuf) </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a47bcbd0313ef457a9ff2b6330ab80af3" name="a2d184a313fab28b517e82c1717d562a0a47bcbd0313ef457a9ff2b6330ab80af3"></a>ev_set_proc_options&#160;</td><td class="fielddoc"><p >Called if the user specified an option string in the command line: -p&lt;processor name&gt;:&lt;options&gt;. </p>
<p >Can be used for setting a processor subtype. Also called if option string is passed to <a class="el" href="idp_8hpp.html#a2e01ca60cc6559ab1dbbfbb9562d6870" title="Set target processor type.">set_processor_type()</a> and IDC's SetProcessorType(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>(const char *) </td></tr>
    <tr><td class="paramname">confidence</td><td>(int) 0: loader's suggestion 1: user's decision </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>if bad option string </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a108d52b9133787bd01c5ca8a7550f2e9" name="a2d184a313fab28b517e82c1717d562a0a108d52b9133787bd01c5ca8a7550f2e9"></a>ev_ana_insn&#160;</td><td class="fielddoc"><p >Analyze one instruction and fill 'out' structure. </p>
<p >This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. \insn_t{ea} contains address of instruction to analyze. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(<a class="el" href="classinsn__t.html">insn_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of the instruction in bytes, 0 if instruction can't be decoded. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if instruction can't be decoded. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a82b81ce84c2257cb5a9176648e2fd6fc" name="a2d184a313fab28b517e82c1717d562a0a82b81ce84c2257cb5a9176648e2fd6fc"></a>ev_emu_insn&#160;</td><td class="fielddoc"><p >Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc. </p>
<p >Upon entrance to this function, all information about the instruction is in 'insn' structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>the kernel will delete the instruction </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ac286cd442f5f923d434a9a420d2639e8" name="a2d184a313fab28b517e82c1717d562a0ac286cd442f5f923d434a9a420d2639e8"></a>ev_out_header&#160;</td><td class="fielddoc"><p >Function to produce start of disassembled text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">void</td><td></td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae78a32919dde7288ed2e816658081c2a" name="a2d184a313fab28b517e82c1717d562a0ae78a32919dde7288ed2e816658081c2a"></a>ev_out_footer&#160;</td><td class="fielddoc"><p >Function to produce end of disassembled text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">void</td><td></td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae9a7ac704447bbbd50dface52b617807" name="a2d184a313fab28b517e82c1717d562a0ae9a7ac704447bbbd50dface52b617807"></a>ev_out_segstart&#160;</td><td class="fielddoc"><p >Function to produce start of segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment.">segment_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a9153e7bd063780720b8761a8e7371a25" name="a2d184a313fab28b517e82c1717d562a0a9153e7bd063780720b8761a8e7371a25"></a>ev_out_segend&#160;</td><td class="fielddoc"><p >Function to produce end of segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment.">segment_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0abf9364c0e642488fac29f61f2b6d0e00" name="a2d184a313fab28b517e82c1717d562a0abf9364c0e642488fac29f61f2b6d0e00"></a>ev_out_assumes&#160;</td><td class="fielddoc"><p >Function to produce assume directives when segment register value changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a8edf4ec2bd23d42d3db641761b3156de" name="a2d184a313fab28b517e82c1717d562a0a8edf4ec2bd23d42d3db641761b3156de"></a>ev_out_insn&#160;</td><td class="fielddoc"><p >Generate text representation of an instruction in 'ctx.insn' <a class="el" href="structoutctx__t.html">outctx_t</a> provides functions to output the generated text. </p>
<p >This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">void</td><td></td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a25783c63147edce4591595cba57d1fb3" name="a2d184a313fab28b517e82c1717d562a0a25783c63147edce4591595cba57d1fb3"></a>ev_out_mnem&#160;</td><td class="fielddoc"><p >Generate instruction mnemonics. </p>
<p >This callback should append the colored mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if appended the mnemonics </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a8312057bdefad72948a26885372af286" name="a2d184a313fab28b517e82c1717d562a0a8312057bdefad72948a26885372af286"></a>ev_out_operand&#160;</td><td class="fielddoc"><p >Generate text representation of an instruction operand <a class="el" href="structoutctx__t.html">outctx_t</a> provides functions to output the generated text. </p>
<p >All these actions should be performed only by emu_insn() function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">op</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction.">op_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>operand is hidden </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a960b08cf65ab07718b9c1eeab0f3288b" name="a2d184a313fab28b517e82c1717d562a0a960b08cf65ab07718b9c1eeab0f3288b"></a>ev_out_data&#160;</td><td class="fielddoc"><p >Generate text representation of data items This function may change the database and create cross-references if analyze_only is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">analyze_only</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a4fc4ad04d596de2dbea5694286bd461e" name="a2d184a313fab28b517e82c1717d562a0a4fc4ad04d596de2dbea5694286bd461e"></a>ev_out_label&#160;</td><td class="fielddoc"><p >The kernel is going to generate an instruction label line or a function header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">colored_name</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>if the kernel should not generate the label </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or continue </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a15733589357bcc46d558536220edcb81" name="a2d184a313fab28b517e82c1717d562a0a15733589357bcc46d558536220edcb81"></a>ev_out_special_item&#160;</td><td class="fielddoc"><p >Generate text representation of an item in a special segment i.e. </p>
<p >absolute symbols, externs, communal definitions etc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">segtype</td><td>(uchar) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">-1</td><td>overflow </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a1790c885236860f938b0c7e983fac38f" name="a2d184a313fab28b517e82c1717d562a0a1790c885236860f938b0c7e983fac38f"></a>ev_gen_stkvar_def&#160;</td><td class="fielddoc"><p >Generate stack variable definition line Default line is varname = type ptr value, where 'type' is one of byte,word,dword,qword,tbyte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">mptr</td><td>(const <a class="el" href="classmember__t.html" title="Describes a member of an assembly level structure.">member_t</a> *) </td></tr>
    <tr><td class="paramname">v</td><td>(sval_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a44268c939ffcc2e8c4c54a1c75796bc0" name="a2d184a313fab28b517e82c1717d562a0a44268c939ffcc2e8c4c54a1c75796bc0"></a>ev_gen_regvar_def&#160;</td><td class="fielddoc"><p >Generate register variable definition line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) </td></tr>
    <tr><td class="paramname">v</td><td>(<a class="el" href="structregvar__t.html" title="A register variable allows the user to rename a general processor register to a meaningful name.">regvar_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>ok, generated the definition text </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a0b636852302fb6ded9309c69cb984f75" name="a2d184a313fab28b517e82c1717d562a0a0b636852302fb6ded9309c69cb984f75"></a>ev_gen_src_file_lnnum&#160;</td><td class="fielddoc"><p >Callback: generate analog of: </p>
<div class="fragment"><div class="line">&lt; #line <span class="stringliteral">&quot;file.c&quot;</span> 123</div>
<div class="line">&lt;</div>
</div><!-- fragment --><p> directive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outctx</td><td>(<a class="el" href="structoutctx__t.html">outctx_t</a> *) output context </td></tr>
    <tr><td class="paramname">file</td><td>(const char *) source file (may be nullptr) </td></tr>
    <tr><td class="paramname">lnnum</td><td>(size_t) line number </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>directive has been generated </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a50e477c14c432b24b7415aa3d96f4a9d" name="a2d184a313fab28b517e82c1717d562a0a50e477c14c432b24b7415aa3d96f4a9d"></a>ev_creating_segm&#160;</td><td class="fielddoc"><p >A new segment is about to be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment.">segment_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;0</td><td>segment should not be created </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aa3c9018493b02e6d0e2b5a4ac7b7549b" name="a2d184a313fab28b517e82c1717d562a0aa3c9018493b02e6d0e2b5a4ac7b7549b"></a>ev_moving_segm&#160;</td><td class="fielddoc"><p >May the kernel move the segment? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment.">segment_t</a> *) segment to move </td></tr>
    <tr><td class="paramname">to</td><td>(::ea_t) new segment start address </td></tr>
    <tr><td class="paramname">flags</td><td>(int) combination of <a class="el" href="group___m_s_f__.html">Move segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>yes </td></tr>
    <tr><td class="paramname">&lt;0</td><td>the kernel should stop </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a08fe9e01fa7424bd80e734a963c1b16a" name="a2d184a313fab28b517e82c1717d562a0a08fe9e01fa7424bd80e734a963c1b16a"></a>ev_coagulate&#160;</td><td class="fielddoc"><p >Try to define some unexplored bytes. </p>
<p >This notification will be called if the kernel tried all possibilities and could not find anything more useful than to convert to array of bytes. The module can help the kernel and convert the bytes into something more useful. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>(::ea_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of converted bytes </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a326c50bb55c58af34774e6fbab74214c" name="a2d184a313fab28b517e82c1717d562a0a326c50bb55c58af34774e6fbab74214c"></a>ev_undefine&#160;</td><td class="fielddoc"><p >An item in the database (insn or data) is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(ea_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>do not delete srranges at the item end </td></tr>
    <tr><td class="paramname">0</td><td>srranges can be deleted </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae96a0913cd051a9a7861ff2d3514a370" name="a2d184a313fab28b517e82c1717d562a0ae96a0913cd051a9a7861ff2d3514a370"></a>ev_treat_hindering_item&#160;</td><td class="fielddoc"><p >An item hinders creation of another item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hindering_item_ea</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">new_item_flags</td><td>(<a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533" title="64-bit flags for each address">flags64_t</a>) (0 for code) </td></tr>
    <tr><td class="paramname">new_item_ea</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">new_item_length</td><td>(::asize_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>no reaction </td></tr>
    <tr><td class="paramname">!=0</td><td>the kernel may delete the hindering item </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a2a2bb0b58f0b5ab62748063b0e601a0e" name="a2d184a313fab28b517e82c1717d562a0a2a2bb0b58f0b5ab62748063b0e601a0e"></a>ev_rename&#160;</td><td class="fielddoc"><p >The kernel is going to rename a byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">new_name</td><td>(const char *) </td></tr>
    <tr><td class="paramname">flags</td><td>(int) <a class="el" href="group___s_n__.html">Set name flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>if the kernel should not rename it. </td></tr>
    <tr><td class="paramname">2</td><td>to inhibit the notification. I.e., the kernel should not rename, but '<a class="el" href="name_8hpp.html#aa75fb1ba89bb22f323472e329eb4a486" title="Set or delete name of an item at the specified address.">set_name()</a>' should return 'true'. also see <a class="el" href="">renamed</a> the return value is ignored when kernel is going to delete name </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aa0a7a527f9e9cba6c406358fad2d4ab1" name="a2d184a313fab28b517e82c1717d562a0aa0a7a527f9e9cba6c406358fad2d4ab1"></a>ev_is_far_jump&#160;</td><td class="fielddoc"><p >is indirect far jump or call instruction? meaningful only if the processor has 'near' and 'far' reference types </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">icode</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">-1</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aca1ba6609e0e3814c499511d513eb099" name="a2d184a313fab28b517e82c1717d562a0aca1ba6609e0e3814c499511d513eb099"></a>ev_is_sane_insn&#160;</td><td class="fielddoc"><p >Is the instruction sane for the current file type?. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">no_crefs</td><td>(int) 1: the instruction has no code refs to it. ida just tries to convert unexplored bytes to an instruction (but there is no other reason to convert them into an instruction) 0: the instruction is created because of some coderef, user request or another weighty reason. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;=0</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no, the instruction isn't likely to appear in the program </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0addaf1f6a31bbefb8033c27edc0950cb8" name="a2d184a313fab28b517e82c1717d562a0addaf1f6a31bbefb8033c27edc0950cb8"></a>ev_is_cond_insn&#160;</td><td class="fielddoc"><p >Is conditional instruction? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">-1</td><td>no </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or not instruction </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aa62d5d4207c7aee3967ab8abddb8c3c1" name="a2d184a313fab28b517e82c1717d562a0aa62d5d4207c7aee3967ab8abddb8c3c1"></a>ev_is_call_insn&#160;</td><td class="fielddoc"><p >Is the instruction a "call"? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0abec6210c7336a864b70a7e5e94a9ac9d" name="a2d184a313fab28b517e82c1717d562a0abec6210c7336a864b70a7e5e94a9ac9d"></a>ev_is_ret_insn&#160;</td><td class="fielddoc"><p >Is the instruction a "return"? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction </td></tr>
    <tr><td class="paramname">strict</td><td>(bool) 1: report only ret instructions 0: include instructions like "leave" which begins the function epilog </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a2e378dfbfccdef3feaa2da1bab69326e" name="a2d184a313fab28b517e82c1717d562a0a2e378dfbfccdef3feaa2da1bab69326e"></a>ev_may_be_func&#160;</td><td class="fielddoc"><p >Can a function start here? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">state</td><td>(int) autoanalysis phase 0: creating functions 1: creating chunks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>probability 1..100 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Actually IDA uses 3 intervals of a probability: 0..50 not a function, 51..99 a function (IDA needs another proof), 100 a function (no other proofs needed) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a978a9e36b842dfe0e7380c3521fa2e1d" name="a2d184a313fab28b517e82c1717d562a0a978a9e36b842dfe0e7380c3521fa2e1d"></a>ev_is_basic_block_end&#160;</td><td class="fielddoc"><p >Is the current instruction end of a basic block?. </p>
<p >This function should be defined for processors with delayed jump slots. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">call_insn_stops_block</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a11d97a517b214dfde194a1de69e5e5ab" name="a2d184a313fab28b517e82c1717d562a0a11d97a517b214dfde194a1de69e5e5ab"></a>ev_is_indirect_jump&#160;</td><td class="fielddoc"><p >Determine if instruction is an indirect jump. </p>
<p >If <a class="el" href="idp_8hpp.html#afd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect jump or call (thus needs additional analysis)">CF_JUMP</a> bit cannot describe all jump types jumps, please define this callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>use <a class="el" href="idp_8hpp.html#afd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect jump or call (thus needs additional analysis)">CF_JUMP</a> </td></tr>
    <tr><td class="paramname">1</td><td>no </td></tr>
    <tr><td class="paramname">2</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0adeb44139bfc91c40cb8e3bd93659ca8e" name="a2d184a313fab28b517e82c1717d562a0adeb44139bfc91c40cb8e3bd93659ca8e"></a>ev_is_insn_table_jump&#160;</td><td class="fielddoc"><p >Reserved. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a9d42d8c2836dceec7666e4b8eb6f71a1" name="a2d184a313fab28b517e82c1717d562a0a9d42d8c2836dceec7666e4b8eb6f71a1"></a>ev_is_switch&#160;</td><td class="fielddoc"><p >Find 'switch' idiom or override processor module's decision. </p>
<p >It will be called for instructions marked with <a class="el" href="idp_8hpp.html#afd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect jump or call (thus needs additional analysis)">CF_JUMP</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">si</td><td>(<a class="el" href="structswitch__info__t.html" title="Information about a switch statement.">switch_info_t</a> *), out </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction possibly belonging to a switch </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>switch is found, 'si' is filled. IDA will create the switch using the filled 'si' </td></tr>
    <tr><td class="paramname">-1</td><td>no switch found. This value forbids switch creation by the processor module </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a98ff2357b62ae2783e781073a9549578" name="a2d184a313fab28b517e82c1717d562a0a98ff2357b62ae2783e781073a9549578"></a>ev_calc_switch_cases&#160;</td><td class="fielddoc"><p >Calculate case values and targets for a custom jump table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">casevec</td><td>(::casevec_t *) vector of case values (may be nullptr) </td></tr>
    <tr><td class="paramname">targets</td><td>(<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4" title="vector of addresses">eavec_t</a> *) corresponding target addresses (my be nullptr) </td></tr>
    <tr><td class="paramname">insn_ea</td><td>(::ea_t) address of the 'indirect jump' instruction </td></tr>
    <tr><td class="paramname">si</td><td>(<a class="el" href="structswitch__info__t.html" title="Information about a switch statement.">switch_info_t</a> *) switch information </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ab1fe188a32b7e4eeedbbbcbe5066af56" name="a2d184a313fab28b517e82c1717d562a0ab1fe188a32b7e4eeedbbbcbe5066af56"></a>ev_create_switch_xrefs&#160;</td><td class="fielddoc"><p >Create xrefs for a custom jump table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jumpea</td><td>(::ea_t) address of the jump insn </td></tr>
    <tr><td class="paramname">si</td><td>(const <a class="el" href="structswitch__info__t.html" title="Information about a switch statement.">switch_info_t</a> *) switch information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>must return 1 Must be implemented if module uses custom jump tables, <a class="el" href="nalt_8hpp.html#a9c8b1cc7dc7face3d01f48b8e2b78135">SWI_CUSTOM</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a4d200c0f82f9d32c4bda426aadc3e9dc" name="a2d184a313fab28b517e82c1717d562a0a4d200c0f82f9d32c4bda426aadc3e9dc"></a>ev_is_align_insn&#160;</td><td class="fielddoc"><p >Is the instruction created only for alignment purposes?. </p>
<p >Do not directly call this function, use <a class="el" href="idp_8hpp.html#a0fd0a2914e9e1fe193175e78a5a6cdeb" title="If the instruction at &#39;ea&#39; looks like an alignment instruction, return its length in bytes.">is_align_insn()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(ea_t) - instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">number</td><td>of bytes in the instruction </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ad25720c4c15166242743be03127e0a84" name="a2d184a313fab28b517e82c1717d562a0ad25720c4c15166242743be03127e0a84"></a>ev_is_alloca_probe&#160;</td><td class="fielddoc"><p >Does the function at 'ea' behave as __alloca_probe? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(::ea_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">0</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0af754550ff044ee8ba2bf4b90037eb4b1" name="a2d184a313fab28b517e82c1717d562a0af754550ff044ee8ba2bf4b90037eb4b1"></a>ev_delay_slot_insn&#160;</td><td class="fielddoc"><p >Get delay slot instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(::ea_t *) in: instruction address in question, out: (if the answer is positive) if the delay slot contains valid insn: the address of the delay slot insn else: BADADDR (invalid insn, e.g. a branch) </td></tr>
    <tr><td class="paramname">bexec</td><td>(bool *) execute slot if jumping, initially set to 'true' </td></tr>
    <tr><td class="paramname">fexec</td><td>(bool *) execute slot if not jumping, initally set to 'true' </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>positive answer </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>ordinary insn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Input EA may point to the instruction with a delay slot or to the delay slot instruction itself. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aef2ae5d93a83201e69e626f1308ca21f" name="a2d184a313fab28b517e82c1717d562a0aef2ae5d93a83201e69e626f1308ca21f"></a>ev_is_sp_based&#160;</td><td class="fielddoc"><p >Check whether the operand is relative to stack pointer or frame pointer This event is used to determine how to output a stack variable If not implemented, then all operands are sp based by default. </p>
<p >Implement this event only if some stack references use frame pointer instead of stack pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>(int *) out, combination of <a class="el" href="group___o_p___f_p___s_p.html">SP/FP operand flags</a> </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) </td></tr>
    <tr><td class="paramname">op</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction.">op_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a9b1b28b1c71c8d77861f528c78eade90" name="a2d184a313fab28b517e82c1717d562a0a9b1b28b1c71c8d77861f528c78eade90"></a>ev_can_have_type&#160;</td><td class="fielddoc"><p >Can the operand have a type as offset, segment, decimal, etc? (for example, a register AX can't have a type, meaning that the user can't change its representation. </p>
<p >see <a class="el" href="bytes_8hpp.html" title="Contains functions that deal with individual byte characteristics.">bytes.hpp</a> for information about types and flags) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction.">op_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a2996b08408addef7f16b01180e2efdc3" name="a2d184a313fab28b517e82c1717d562a0a2996b08408addef7f16b01180e2efdc3"></a>ev_cmp_operands&#160;</td><td class="fielddoc"><p >Compare instruction operands. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op1</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction.">op_t</a>*) </td></tr>
    <tr><td class="paramname">op2</td><td>(const <a class="el" href="classop__t.html" title="Operand of an instruction.">op_t</a>*) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>equal </td></tr>
    <tr><td class="paramname">-1</td><td>not equal </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0abf55189dd21fab945f35eab8fa9088cf" name="a2d184a313fab28b517e82c1717d562a0abf55189dd21fab945f35eab8fa9088cf"></a>ev_adjust_refinfo&#160;</td><td class="fielddoc"><p >Called from apply_fixup before converting operand to reference. </p>
<p >Can be used for changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some references) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ri</td><td>(<a class="el" href="structrefinfo__t.html" title="Information about a reference.">refinfo_t</a> *) </td></tr>
    <tr><td class="paramname">ea</td><td>(::ea_t) instruction address </td></tr>
    <tr><td class="paramname">n</td><td>(int) operand number </td></tr>
    <tr><td class="paramname">fd</td><td>(const <a class="el" href="structfixup__data__t.html">fixup_data_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>do not create an offset </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or refinfo adjusted </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae7391e79329dedc4bd100a629e61f569" name="a2d184a313fab28b517e82c1717d562a0ae7391e79329dedc4bd100a629e61f569"></a>ev_get_operand_string&#160;</td><td class="fielddoc"><p >Request text string for operand (cli, java, ...). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>(qstring *) </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">opnum</td><td>(int) operand number, -1 means any string operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>no string (or empty string) </td></tr>
    <tr><td class="paramname">&gt;0</td><td>original string length without terminating zero </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a8dcc2b7307fb19045e6acf6d6016d89d" name="a2d184a313fab28b517e82c1717d562a0a8dcc2b7307fb19045e6acf6d6016d89d"></a>ev_get_reg_name&#160;</td><td class="fielddoc"><p >Generate text representation of a register. </p>
<p >Most processor modules do not need to implement this callback. It is useful only if <a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307" title="array of register names">processor_t::reg_names</a>[reg] does not provide the correct register name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>(qstring *) output buffer </td></tr>
    <tr><td class="paramname">reg</td><td>(int) internal register number as defined in the processor module </td></tr>
    <tr><td class="paramname">width</td><td>(size_t) register width in bytes </td></tr>
    <tr><td class="paramname">reghi</td><td>(int) if not -1 then this function will return the register pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if error </td></tr>
    <tr><td class="paramname">strlen(buf)</td><td>if success </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aaddd272c33f61d746f850746a5451a9f" name="a2d184a313fab28b517e82c1717d562a0aaddd272c33f61d746f850746a5451a9f"></a>ev_str2reg&#160;</td><td class="fielddoc"><p >Convert a register name to a register number. </p>
<p >The register number is the register index in the <a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307" title="array of register names">processor_t::reg_names</a> array Most processor modules do not need to implement this callback It is useful only if <a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307" title="array of register names">processor_t::reg_names</a>[reg] does not provide the correct register names </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regname</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">register</td><td>number + 1 </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or could not be decoded </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a0fa6560db645bbc4751b5cee7760cf30" name="a2d184a313fab28b517e82c1717d562a0a0fa6560db645bbc4751b5cee7760cf30"></a>ev_get_autocmt&#160;</td><td class="fielddoc"><p >Callback: get dynamic auto comment. </p>
<p >Will be called if the autocomments are enabled and the comment retrieved from ida.int starts with '$!'. 'insn' contains valid info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>(qstring *) output buffer </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>new comment has been generated </td></tr>
    <tr><td class="paramname">0</td><td>callback has not been handled. the buffer must not be changed in this case </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a0de30b0749ce3401ec930a1904bcb274" name="a2d184a313fab28b517e82c1717d562a0a0de30b0749ce3401ec930a1904bcb274"></a>ev_get_bg_color&#160;</td><td class="fielddoc"><p >Get item background color. </p>
<p >Plugins can hook this callback to color disassembly lines dynamically </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>(<a class="el" href="pro_8h.html#a3df5040891132e50157aee66affdf1de" title="background color in RGB">bgcolor_t</a> *), out </td></tr>
    <tr><td class="paramname">ea</td><td>(::ea_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>color set </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a1f6f7128d8213f4433c5c94e16635aa7" name="a2d184a313fab28b517e82c1717d562a0a1f6f7128d8213f4433c5c94e16635aa7"></a>ev_is_jump_func&#160;</td><td class="fielddoc"><p >Is the function a trivial "jump" function?. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a> *) </td></tr>
    <tr><td class="paramname">jump_target</td><td>(::ea_t *) </td></tr>
    <tr><td class="paramname">func_pointer</td><td>(::ea_t *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>no </td></tr>
    <tr><td class="paramname">0</td><td>don't know </td></tr>
    <tr><td class="paramname">1</td><td>yes, see 'jump_target' and 'func_pointer' </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a54a6dfcb795c6d8167ebdb5116bcf579" name="a2d184a313fab28b517e82c1717d562a0a54a6dfcb795c6d8167ebdb5116bcf579"></a>ev_func_bounds&#160;</td><td class="fielddoc"><p ><a class="el" href="funcs_8hpp.html#af27a7eb0cc4e210f6ffa21e6aa06e589" title="Determine the boundaries of a new function.">find_func_bounds()</a> finished its work. </p>
<p >The module may fine tune the function bounds </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">possible_return_code</td><td>(int *), in/out </td></tr>
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a> *) </td></tr>
    <tr><td class="paramname">max_func_end_ea</td><td>(::ea_t) (from the kernel's point of view) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">void</td><td></td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a726a4a238e3c41a53777e5e04b911029" name="a2d184a313fab28b517e82c1717d562a0a726a4a238e3c41a53777e5e04b911029"></a>ev_verify_sp&#160;</td><td class="fielddoc"><p >All function instructions have been analyzed. </p>
<p >Now the processor module can analyze the stack pointer for the whole function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;0</td><td>bad stack pointer </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae161c5b9fbb789a4ed5a9e88539802f7" name="a2d184a313fab28b517e82c1717d562a0ae161c5b9fbb789a4ed5a9e88539802f7"></a>ev_verify_noreturn&#160;</td><td class="fielddoc"><p >The kernel wants to set 'noreturn' flags for a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok. any other value: do not set 'noreturn' flag </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a4e97147365c7e9487f57ffc2bd82894a" name="a2d184a313fab28b517e82c1717d562a0a4e97147365c7e9487f57ffc2bd82894a"></a>ev_create_func_frame&#160;</td><td class="fielddoc"><p >Create a function frame for a newly created function Set up frame size, its attributes etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a73d90e8e78294379f7efdb58e0fa4ca9" name="a2d184a313fab28b517e82c1717d562a0a73d90e8e78294379f7efdb58e0fa4ca9"></a>ev_get_frame_retsize&#160;</td><td class="fielddoc"><p >Get size of function return address in bytes If this event is not implemented, the kernel will assume. </p>
<ul>
<li>8 bytes for 64-bit function</li>
<li>4 bytes for 32-bit function</li>
<li>2 bytes otherwise <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frsize</td><td>(int *) frame size (out) </td></tr>
    <tr><td class="paramname">pfn</td><td>(const <a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a> *), can't be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae3c289592a68b9362e83fab157097cbf" name="a2d184a313fab28b517e82c1717d562a0ae3c289592a68b9362e83fab157097cbf"></a>ev_get_stkvar_scale_factor&#160;</td><td class="fielddoc"><p >Should stack variable references be multiplied by a coefficient before being used in the stack frame?. </p>
<p >Currently used by TMS320C55 because the references into the stack should be multiplied by 2 </p><dl class="section return"><dt>Returns</dt><dd>scaling factor </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="idp_8hpp.html#af96c8c11c1d33bf6b8b45cd0c596b9a9" title="use processor_t::get_stkvar_scale callback">PR_SCALE_STKVARS</a> should be set to use this callback </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ad1283662b4901e2ea7d85af70bc7f817" name="a2d184a313fab28b517e82c1717d562a0ad1283662b4901e2ea7d85af70bc7f817"></a>ev_demangle_name&#160;</td><td class="fielddoc"><p >Demangle a C++ (or another language) name into a user-readable string. </p>
<p >This event is called by <a class="el" href="name_8hpp.html#aa9c7d3ed8cf3b79dca8ee2262c9f3b56" title="Demangle a name.">demangle_name()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>(int32 *) value to return from <a class="el" href="name_8hpp.html#aa9c7d3ed8cf3b79dca8ee2262c9f3b56" title="Demangle a name.">demangle_name()</a> </td></tr>
    <tr><td class="paramname">out</td><td>(<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce" title="regular string">qstring</a> *) output buffer. may be nullptr </td></tr>
    <tr><td class="paramname">name</td><td>(const char *) mangled name </td></tr>
    <tr><td class="paramname">disable_mask</td><td>(uint32) flags to inhibit parts of output or compiler info/other (see MNG_) </td></tr>
    <tr><td class="paramname">demreq</td><td>(demreq_type_t) operation to perform </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if success </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if you call <a class="el" href="name_8hpp.html#aa9c7d3ed8cf3b79dca8ee2262c9f3b56" title="Demangle a name.">demangle_name()</a> from the handler, protect against recursion! </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a6362bc58103da0a115d1c15c3ce41fe1" name="a2d184a313fab28b517e82c1717d562a0a6362bc58103da0a115d1c15c3ce41fe1"></a>ev_add_cref&#160;</td><td class="fielddoc"><p >A code reference is being created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">to</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">type</td><td>(<a class="el" href="xref_8hpp.html#a44e2b79869a9595bbe6265ff2026aa98" title="CODE xref types.">cref_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>cancel cref creation </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or continue </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a64a7c332726e8a44498b879162e4d24f" name="a2d184a313fab28b517e82c1717d562a0a64a7c332726e8a44498b879162e4d24f"></a>ev_add_dref&#160;</td><td class="fielddoc"><p >A data reference is being created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">to</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">type</td><td>(<a class="el" href="xref_8hpp.html#a78aab6d0d6bd9cb4904bbdbb5ac4fa71" title="DATA xref types.">dref_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>cancel dref creation </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or continue </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a58ace401d909f95b24a1e8fcae9810d4" name="a2d184a313fab28b517e82c1717d562a0a58ace401d909f95b24a1e8fcae9810d4"></a>ev_del_cref&#160;</td><td class="fielddoc"><p >A code reference is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">to</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">expand</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>cancel cref deletion </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or continue </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0affd5e295fef35e6175c3db5150ca5396" name="a2d184a313fab28b517e82c1717d562a0affd5e295fef35e6175c3db5150ca5396"></a>ev_del_dref&#160;</td><td class="fielddoc"><p >A data reference is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">to</td><td>(::ea_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>cancel dref deletion </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or continue </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a00c056a442c9524d2c7f7e90669c8275" name="a2d184a313fab28b517e82c1717d562a0a00c056a442c9524d2c7f7e90669c8275"></a>ev_coagulate_dref&#160;</td><td class="fielddoc"><p >Data reference is being analyzed. </p>
<p >plugin may correct 'code_ea' (e.g. for thumb mode refs, we clear the last bit) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">to</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">may_define</td><td>(bool) </td></tr>
    <tr><td class="paramname">code_ea</td><td>(::ea_t *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>failed dref analysis, &gt;0 done dref analysis </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or continue </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a1edb3d05f21feee48cf7d271032dcbc2" name="a2d184a313fab28b517e82c1717d562a0a1edb3d05f21feee48cf7d271032dcbc2"></a>ev_may_show_sreg&#160;</td><td class="fielddoc"><p >The kernel wants to display the segment registers in the messages window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_ea</td><td>(::ea_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>if the kernel should not show the segment registers. (assuming that the module has done it) </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a268f12ba7873a0778460826a59e268aa" name="a2d184a313fab28b517e82c1717d562a0a268f12ba7873a0778460826a59e268aa"></a>ev_loader_elf_machine&#160;</td><td class="fielddoc"><p >ELF loader machine type checkpoint. </p>
<p >A plugin check of the 'machine_type'. If it is the desired one, the the plugin fills 'p_procname' with the processor name (one of the names present in <a class="el" href="structprocessor__t.html#a7f36c9be272d994bc341b3fcb78726f6" title="short processor names (nullptr terminated).">processor_t::psnames</a>). 'p_pd' is used to handle relocations, otherwise can be left untouched. This event occurs for each newly loaded ELF file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">li</td><td>(linput_t *) </td></tr>
    <tr><td class="paramname">machine_type</td><td>(int) </td></tr>
    <tr><td class="paramname">p_procname</td><td>(const char **) </td></tr>
    <tr><td class="paramname">p_pd</td><td>(proc_def_t **) (see ldr\elf.h) </td></tr>
    <tr><td class="paramname">loader</td><td>(elf_loader_t *) (see ldr\elf.h) </td></tr>
    <tr><td class="paramname">reader</td><td>(reader_t *) (see ldr\elf.h) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">e_machine</td><td>value (if it is different from the original e_machine value, procname and 'p_pd' will be ignored and the new value will be used) before replacing pd it is a good idea to delete the previous instance using 'delete pd;' The 'loader' and 'reader' arguments are available starting from IDA v7.7. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a0ca73f0b4d8eb1c319f668cb8c520b86" name="a2d184a313fab28b517e82c1717d562a0a0ca73f0b4d8eb1c319f668cb8c520b86"></a>ev_auto_queue_empty&#160;</td><td class="fielddoc"><p >One analysis queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>(<a class="el" href="auto_8hpp.html#ae3fe1a7af243ca1880188111193297cf" title="identifies an autoanalysis queue - see Autoanalysis queues">atype_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">void</td><td>see also <a class="el" href="namespaceidb__event.html#a0feb6e648b4e6e3f0ed954abea672784a8d4508d4ede7ad33b0df402700a95740">idb_event::auto_empty_finally</a> </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aac26bb0ae2ef530084cbeb8c3078bd43" name="a2d184a313fab28b517e82c1717d562a0aac26bb0ae2ef530084cbeb8c3078bd43"></a>ev_validate_flirt_func&#160;</td><td class="fielddoc"><p >Flirt has recognized a library function. </p>
<p >This callback can be used by a plugin or proc module to intercept it and validate such a function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">funcname</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>do not create a function, </td></tr>
    <tr><td class="paramname">0</td><td>function is validated </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a1cf0dcb7a9e11a5220863ddb8722bd09" name="a2d184a313fab28b517e82c1717d562a0a1cf0dcb7a9e11a5220863ddb8722bd09"></a>ev_adjust_libfunc_ea&#160;</td><td class="fielddoc"><p >Called when a signature module has been matched against bytes in the database. </p>
<p >This is used to compute the offset at which a particular module's libfunc should be applied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>(const idasgn_t *) </td></tr>
    <tr><td class="paramname">libfun</td><td>(const libfunc_t *) </td></tr>
    <tr><td class="paramname">ea</td><td>(::ea_t *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>'ea' initially contains the ea_t of the start of the pattern match </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>the ea_t pointed to by the third argument was modified. </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>not modified. use default algorithm. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a5f2ba1e8f4586958cc9cef0f514667e2" name="a2d184a313fab28b517e82c1717d562a0a5f2ba1e8f4586958cc9cef0f514667e2"></a>ev_assemble&#160;</td><td class="fielddoc"><p >Assemble an instruction. </p>
<p >(display a warning if an error is found). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bin</td><td>(<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc" title="unsigned 8 bit value">uchar</a> *) pointer to output opcode buffer </td></tr>
    <tr><td class="paramname">ea</td><td>(::ea_t) linear address of instruction </td></tr>
    <tr><td class="paramname">cs</td><td>(::ea_t) cs of instruction </td></tr>
    <tr><td class="paramname">ip</td><td>(::ea_t) ip of instruction </td></tr>
    <tr><td class="paramname">use32</td><td>(bool) is 32bit segment? </td></tr>
    <tr><td class="paramname">line</td><td>(const char *) line to assemble </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the instruction in bytes </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0abe5d814d671bf8564be4212cefb61238" name="a2d184a313fab28b517e82c1717d562a0abe5d814d671bf8564be4212cefb61238"></a>ev_extract_address&#160;</td><td class="fielddoc"><p >Extract address from a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_ea</td><td>(ea_t *), out </td></tr>
    <tr><td class="paramname">screen_ea</td><td>(ea_t) </td></tr>
    <tr><td class="paramname">string</td><td>(const char *) </td></tr>
    <tr><td class="paramname">position</td><td>(size_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>kernel should use the standard algorithm </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a5cccab69e499642d3873649769de31cf" name="a2d184a313fab28b517e82c1717d562a0a5cccab69e499642d3873649769de31cf"></a>ev_realcvt&#160;</td><td class="fielddoc"><p >Floating point -&gt; IEEE conversion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(void *) ptr to processor-specific floating point value </td></tr>
    <tr><td class="paramname">e</td><td>(<a class="el" href="structfpvalue__t.html" title="Processor-independent representation of a floating point value.">fpvalue_t</a> *) IDA representation of a floating point value </td></tr>
    <tr><td class="paramname">swt</td><td>(uint16) operation (see realcvt() in <a class="el" href="ieee_8h.html" title="IEEE floating point functions.">ieee.h</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>ref REAL_ERROR_ on error </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a87a749b6180d2fc6c4b4436df4eddc2f" name="a2d184a313fab28b517e82c1717d562a0a87a749b6180d2fc6c4b4436df4eddc2f"></a>ev_gen_asm_or_lst&#160;</td><td class="fielddoc"><p >Callback: generating asm or lst file. </p>
<p >The kernel calls this callback twice, at the beginning and at the end of listing generation. The processor module can intercept this event and adjust its output </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting</td><td>(bool) beginning listing generation </td></tr>
    <tr><td class="paramname">fp</td><td>(FILE *) output file </td></tr>
    <tr><td class="paramname">is_asm</td><td>(bool) true:assembler, false:listing </td></tr>
    <tr><td class="paramname">flags</td><td>(int) flags passed to <a class="el" href="loader_8hpp.html#a777046093020c790ec43bd207166bf09" title="Generate an output file.">gen_file()</a> </td></tr>
    <tr><td class="paramname">outline</td><td>(html_line_cb_t **) ptr to ptr to outline callback. if this callback is defined for this code, it will be used by the kernel to output the generated lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">void</td><td></td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ac4729fbc053f45a29a9370369eda3c21" name="a2d184a313fab28b517e82c1717d562a0ac4729fbc053f45a29a9370369eda3c21"></a>ev_gen_map_file&#160;</td><td class="fielddoc"><p >Generate map file. </p>
<p >If not implemented the kernel itself will create the map file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nlines</td><td>(int *) number of lines in map file (-1 means write error) </td></tr>
    <tr><td class="paramname">fp</td><td>(FILE *) output file </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>write error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a5fa3981e47a82bf57567c9e17fc69344" name="a2d184a313fab28b517e82c1717d562a0a5fa3981e47a82bf57567c9e17fc69344"></a>ev_create_flat_group&#160;</td><td class="fielddoc"><p >Create special segment representing the flat group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_base</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">bitness</td><td>(int) </td></tr>
    <tr><td class="paramname">dataseg_sel</td><td>(::sel_t) return value is ignored </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a5b7199e3af11fa25303602ba6093f307" name="a2d184a313fab28b517e82c1717d562a0a5b7199e3af11fa25303602ba6093f307"></a>ev_getreg&#160;</td><td class="fielddoc"><p >IBM PC only internal request, should never be used for other purpose Get register value by internal index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regval</td><td>(uval_t *), out </td></tr>
    <tr><td class="paramname">regnum</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">-1</td><td>failed (undefined value or bad regnum) </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ada84ccdbecd828227cf5891289d4a442" name="a2d184a313fab28b517e82c1717d562a0ada84ccdbecd828227cf5891289d4a442"></a>ev_analyze_prolog&#160;</td><td class="fielddoc"><p >Analyzes function prolog, epilog, and updates purge, and function attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(::ea_t) start of function </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ad634ef51985fc184b924840188825199" name="a2d184a313fab28b517e82c1717d562a0ad634ef51985fc184b924840188825199"></a>ev_calc_spdelta&#160;</td><td class="fielddoc"><p >Calculate amount of change to sp for the given insn. </p>
<p >This event is required to decompile code snippets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spdelta</td><td>(<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1" title="signed value used by the processor.">sval_t</a> *) </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a44113b21d13cb880233a52c38a84bea9" name="a2d184a313fab28b517e82c1717d562a0a44113b21d13cb880233a52c38a84bea9"></a>ev_calcrel&#160;</td><td class="fielddoc"><p >Reserved. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a05a8170fb8a243187c118dbcaa1fd954" name="a2d184a313fab28b517e82c1717d562a0a05a8170fb8a243187c118dbcaa1fd954"></a>ev_find_reg_value&#160;</td><td class="fielddoc"><p >Find register value via a register tracker. </p>
<p >The returned value in 'out' is valid before executing the instruction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(uval_t *) pointer to the found value </td></tr>
    <tr><td class="paramname">pinsn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction </td></tr>
    <tr><td class="paramname">reg</td><td>(int) register index </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if implemented, and value was found </td></tr>
    <tr><td class="paramname">0</td><td>not implemented, -1 decoding failed, or no value found </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ac0cdca25f97d06dfa6630abfd371cfea" name="a2d184a313fab28b517e82c1717d562a0ac0cdca25f97d06dfa6630abfd371cfea"></a>ev_find_op_value&#160;</td><td class="fielddoc"><p >Find operand value via a register tracker. </p>
<p >The returned value in 'out' is valid before executing the instruction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(uval_t *) pointer to the found value </td></tr>
    <tr><td class="paramname">pinsn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction </td></tr>
    <tr><td class="paramname">opn</td><td>(int) operand index </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if implemented, and value was found </td></tr>
    <tr><td class="paramname">0</td><td>not implemented, -1 decoding failed, or no value found </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a8455728c58bfbcf62ebed0a867319de0" name="a2d184a313fab28b517e82c1717d562a0a8455728c58bfbcf62ebed0a867319de0"></a>ev_replaying_undo&#160;</td><td class="fielddoc"><p >Replaying an undo/redo buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action_name</td><td>(const char *) action that we perform undo/redo for. may be nullptr for intermediary buffers. </td></tr>
    <tr><td class="paramname">vec</td><td>(const undo_records_t *) </td></tr>
    <tr><td class="paramname">is_undo</td><td>(bool) true if performing undo, false if performing redo This event may be generated multiple times per undo/redo </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a218975038c561f744c6d6722f3adee1c" name="a2d184a313fab28b517e82c1717d562a0a218975038c561f744c6d6722f3adee1c"></a>ev_ending_undo&#160;</td><td class="fielddoc"><p >Ended undoing/redoing an action. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action_name</td><td>(const char *) action that we finished undoing/redoing. is not nullptr. </td></tr>
    <tr><td class="paramname">is_undo</td><td>(bool) true if performing undo, false if performing redo </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a656a70048be41e4ef0f3d4d68c7f7f68" name="a2d184a313fab28b517e82c1717d562a0a656a70048be41e4ef0f3d4d68c7f7f68"></a>ev_set_code16_mode&#160;</td><td class="fielddoc"><p >Some processors have ISA 16-bit mode e.g. </p>
<p >ARM Thumb mode, PPC VLE, MIPS16 Set ISA 16-bit mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(ea_t) address to set new ISA mode </td></tr>
    <tr><td class="paramname">code16</td><td>(bool) true for 16-bit mode, false for 32-bit mode </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0adce61dd59d050ab2257ba9430542fd1f" name="a2d184a313fab28b517e82c1717d562a0adce61dd59d050ab2257ba9430542fd1f"></a>ev_get_code16_mode&#160;</td><td class="fielddoc"><p >Get ISA 16-bit mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(ea_t) address to get the ISA mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>16-bit mode </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or 32-bit mode </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a0508c681bd7d803d9a497b9df5071196" name="a2d184a313fab28b517e82c1717d562a0a0508c681bd7d803d9a497b9df5071196"></a>ev_get_procmod&#160;</td><td class="fielddoc"><p >Get pointer to the processor module object. </p>
<p >All processor modules must implement this. The pointer is returned as size_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ab680db8c1398d0f42ecd7a8a6302a8ae" name="a2d184a313fab28b517e82c1717d562a0ab680db8c1398d0f42ecd7a8a6302a8ae"></a>ev_asm_installed&#160;</td><td class="fielddoc"><p >After setting a new assembler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asmnum</td><td>(int) See also ev_newasm </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a793e05a7e4e3a941b127ab63b6c86bd0" name="a2d184a313fab28b517e82c1717d562a0a793e05a7e4e3a941b127ab63b6c86bd0"></a>ev_get_reg_accesses&#160;</td><td class="fielddoc"><p >Get info about the registers that are used/changed by an instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accvec</td><td>(<a class="el" href="structreg__accesses__t.html">reg_accesses_t</a>*) out: info about accessed registers </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) instruction in question </td></tr>
    <tr><td class="paramname">flags</td><td>(int) reserved, must be 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>if accvec is nullptr </td></tr>
    <tr><td class="paramname">1</td><td>found the requested access (and filled accvec) </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a585ff69fe61cd22e286dd82883668d20" name="a2d184a313fab28b517e82c1717d562a0a585ff69fe61cd22e286dd82883668d20"></a>ev_is_control_flow_guard&#160;</td><td class="fielddoc"><p >Detect if an instruction is a "thunk call" to a flow guard function (equivalent to call reg/return/nop) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_reg</td><td>(int *) indirect register number, may be -1 </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a> *) call/jump instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>no thunk detected </td></tr>
    <tr><td class="paramname">1</td><td>indirect call </td></tr>
    <tr><td class="paramname">2</td><td>security check routine call (NOP) </td></tr>
    <tr><td class="paramname">3</td><td>return thunk </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0acd9fa1f52f1597fa56b0049f5c915f35" name="a2d184a313fab28b517e82c1717d562a0acd9fa1f52f1597fa56b0049f5c915f35"></a>ev_broadcast&#160;</td><td class="fielddoc"><p >Broadcast call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">magic</td><td>(::int64) a magic number Other parameters and the return value depend on the magic </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a60d20a3db1d45b67e69038b0398ad960" name="a2d184a313fab28b517e82c1717d562a0a60d20a3db1d45b67e69038b0398ad960"></a>ev_create_merge_handlers&#160;</td><td class="fielddoc"><p >Create merge handlers, if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">md</td><td>(::merge_data_t *) This event is generated immediately after opening idbs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>must be 0 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a48bb851e42954b7a88af840120207c3e" name="a2d184a313fab28b517e82c1717d562a0a48bb851e42954b7a88af840120207c3e"></a>ev_privrange_changed&#160;</td><td class="fielddoc"><p >Privrange interval has been moved to a new location. </p>
<p >Most common actions to be done by module in this case: fix indices of netnodes used by module </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_privrange</td><td>(const <a class="el" href="structrange__t.html" title="Base class for an range.">range_t</a> *) - old privrange interval </td></tr>
    <tr><td class="paramname">delta</td><td>(::adiff_t) </td></tr>
    <tr><td class="paramname">errbuf</td><td>(<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce" title="regular string">qstring</a> *) - a error message will be returned here (can be nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 Ok </dd>
<dd>
-1 error (and message in errbuf) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a78fdb192b6eb8363352037dfd2e84e4e" name="a2d184a313fab28b517e82c1717d562a0a78fdb192b6eb8363352037dfd2e84e4e"></a>ev_cvt64_supval&#160;</td><td class="fielddoc"><p >perform 32-64 conversion for a netnode array element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>(::nodeidx_t) </td></tr>
    <tr><td class="paramname">tag</td><td>(<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc" title="unsigned 8 bit value">uchar</a>) </td></tr>
    <tr><td class="paramname">idx</td><td>(::nodeidx_t) </td></tr>
    <tr><td class="paramname">data</td><td>(const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc" title="unsigned 8 bit value">uchar</a> *) </td></tr>
    <tr><td class="paramname">datlen</td><td>(::size_t) </td></tr>
    <tr><td class="paramname">errbuf</td><td>(<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce" title="regular string">qstring</a> *) - a error message will be returned here (can be nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 nothing was done </dd>
<dd>
1 converted successfully </dd>
<dd>
-1 error (and message in errbuf) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a1767b137277fc1b09f82992fef05e70e" name="a2d184a313fab28b517e82c1717d562a0a1767b137277fc1b09f82992fef05e70e"></a>ev_cvt64_hashval&#160;</td><td class="fielddoc"><p >perform 32-64 conversion for a hash value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>(::nodeidx_t) </td></tr>
    <tr><td class="paramname">tag</td><td>(<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc" title="unsigned 8 bit value">uchar</a>) </td></tr>
    <tr><td class="paramname">name</td><td>(const ::char *) </td></tr>
    <tr><td class="paramname">data</td><td>(const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc" title="unsigned 8 bit value">uchar</a> *) </td></tr>
    <tr><td class="paramname">datlen</td><td>(::size_t) </td></tr>
    <tr><td class="paramname">errbuf</td><td>(<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce" title="regular string">qstring</a> *) - a error message will be returned here (can be nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 nothing was done </dd>
<dd>
1 converted successfully </dd>
<dd>
-1 error (and message in errbuf) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a5776ce7324886d47497e6b55fa985c2f" name="a2d184a313fab28b517e82c1717d562a0a5776ce7324886d47497e6b55fa985c2f"></a>ev_last_cb_before_debugger&#160;</td><td class="fielddoc"><p >START OF DEBUGGER CALLBACKS. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a035854be86d6e113db368eba96ec6a44" name="a2d184a313fab28b517e82c1717d562a0a035854be86d6e113db368eba96ec6a44"></a>ev_next_exec_insn&#160;</td><td class="fielddoc"><p >Get next address to be executed This function must return the next address to be executed. </p>
<p >If the instruction following the current one is executed, then it must return <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> Usually the instructions to consider are: jumps, branches, calls, returns. This function is essential if the 'single step' is not supported in hardware. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>(::ea_t *), out: pointer to the answer </td></tr>
    <tr><td class="paramname">ea</td><td>(::ea_t) instruction address </td></tr>
    <tr><td class="paramname">tid</td><td>(int) current therad id </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value.">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
    <tr><td class="paramname">1</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aa552c713d33cbf8b7088aa1279316279" name="a2d184a313fab28b517e82c1717d562a0aa552c713d33cbf8b7088aa1279316279"></a>ev_calc_step_over&#160;</td><td class="fielddoc"><p >Calculate the address of the instruction which will be executed after "step over". </p>
<p >The kernel will put a breakpoint there. If the step over is equal to step into or we cannot calculate the address, return <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>(::ea_t *) pointer to the answer </td></tr>
    <tr><td class="paramname">ip</td><td>(::ea_t) instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
    <tr><td class="paramname">1</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a15f393eb309882f724a87ba8680ed8b2" name="a2d184a313fab28b517e82c1717d562a0a15f393eb309882f724a87ba8680ed8b2"></a>ev_calc_next_eas&#160;</td><td class="fielddoc"><p >Calculate list of addresses the instruction in 'insn' may pass control to. </p>
<p >This callback is required for source level debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>(<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4" title="vector of addresses">eavec_t</a> *), out: array for the results. </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">over</td><td>(bool) calculate for step over (ignore call targets) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>incalculable (indirect jumps, for example) </td></tr>
    <tr><td class="paramname">&gt;=0</td><td>number of addresses of called functions in the array. They must be put at the beginning of the array (0 if over=true) </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a2f4da6daaf29d96db466f024a41b6cd6" name="a2d184a313fab28b517e82c1717d562a0a2f4da6daaf29d96db466f024a41b6cd6"></a>ev_get_macro_insn_head&#160;</td><td class="fielddoc"><p >Calculate the start of a macro instruction. </p>
<p >This notification is called if IP points to the middle of an instruction </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>(::ea_t *), out: answer, <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> means normal instruction </td></tr>
    <tr><td class="paramname">ip</td><td>(::ea_t) instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
    <tr><td class="paramname">1</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae19b6e2ec1f0f8dff6822e23d26ecf6f" name="a2d184a313fab28b517e82c1717d562a0ae19b6e2ec1f0f8dff6822e23d26ecf6f"></a>ev_get_dbr_opnum&#160;</td><td class="fielddoc"><p >Get the number of the operand to be displayed in the debugger reference view (text mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opnum</td><td>(int *) operand number (out, -1 means no such operand) </td></tr>
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
    <tr><td class="paramname">1</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a744ce375c380a22ef248cb5c8b2fe91e" name="a2d184a313fab28b517e82c1717d562a0a744ce375c380a22ef248cb5c8b2fe91e"></a>ev_insn_reads_tbit&#160;</td><td class="fielddoc"><p >Check if insn will read the TF bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>(const <a class="el" href="classinsn__t.html">insn_t</a>*) the instruction </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value.">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>yes, will generate 'step' exception </td></tr>
    <tr><td class="paramname">1</td><td>yes, will store the TF bit in memory </td></tr>
    <tr><td class="paramname">0</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a731a21b42e23b3a93212acc929590a44" name="a2d184a313fab28b517e82c1717d562a0a731a21b42e23b3a93212acc929590a44"></a>ev_clean_tbit&#160;</td><td class="fielddoc"><p >Clear the TF bit after an insn like pushf stored it in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(::ea_t) instruction address </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value.">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a4c99f3d0cae242c834db12429824c412" name="a2d184a313fab28b517e82c1717d562a0a4c99f3d0cae242c834db12429824c412"></a>ev_get_idd_opinfo&#160;</td><td class="fielddoc"><p >Get operand information. </p>
<p >This callback is used to calculate the operand value for double clicking on it, hints, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opinf</td><td>(<a class="el" href="structidd__opinfo__t.html" title="Instruction operand information.">idd_opinfo_t</a> *) the output buffer </td></tr>
    <tr><td class="paramname">ea</td><td>(::ea_t) instruction address </td></tr>
    <tr><td class="paramname">n</td><td>(int) operand number </td></tr>
    <tr><td class="paramname">thread_id</td><td>(int) current thread id </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value.">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ac3cc0f61a972f10943ffcb9b512bbfcd" name="a2d184a313fab28b517e82c1717d562a0ac3cc0f61a972f10943ffcb9b512bbfcd"></a>ev_get_reg_info&#160;</td><td class="fielddoc"><p >Get register information by its name. </p>
<p >example: "ah" returns:</p><ul>
<li>main_regname="eax"</li>
<li><a class="el" href="classbitrange__t.html" title="This class manages the offset and size of a value that occupies a number of contiguous bits within so...">bitrange_t</a> = { offset==8, nbits==8 }</li>
</ul>
<p >This callback may be unimplemented if the register names are all present in <a class="el" href="structprocessor__t.html#a0b75be7e30d134b1b288ab686c312307" title="array of register names">processor_t::reg_names</a> and they all have the same size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_regname</td><td>(const char **), out </td></tr>
    <tr><td class="paramname">bitrange</td><td>(<a class="el" href="classbitrange__t.html" title="This class manages the offset and size of a value that occupies a number of contiguous bits within so...">bitrange_t</a> *), out: position and size of the value within 'main_regname' (empty bitrange == whole register) </td></tr>
    <tr><td class="paramname">regname</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>failed (not found) </td></tr>
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ac347970270ca49b49cdf52a994eea7b6" name="a2d184a313fab28b517e82c1717d562a0ac347970270ca49b49cdf52a994eea7b6"></a>ev_update_call_stack&#160;</td><td class="fielddoc"><p >Calculate the call stack trace for the given thread. </p>
<p >This callback is invoked when the process is suspended and should fill the 'trace' object with the information about the current call stack. Note that this callback is NOT invoked if the current debugger backend implements stack tracing via debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes priority. Implementing this callback in the processor module is useful when multiple debugging platforms follow similar patterns, and thus the same processor-specific algorithm can be used for different platforms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>(<a class="el" href="structcall__stack__t.html" title="defined as struct so it can be forward-declared">call_stack_t</a> *) result </td></tr>
    <tr><td class="paramname">tid</td><td>(int) thread id </td></tr>
    <tr><td class="paramname">getreg</td><td>(::processor_t::regval_getter_t *) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value.">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>failed </td></tr>
    <tr><td class="paramname">0</td><td>unimplemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ab943223f3ca8d738c6a33aa2d1d5d5b2" name="a2d184a313fab28b517e82c1717d562a0ab943223f3ca8d738c6a33aa2d1d5d5b2"></a>ev_setup_til&#160;</td><td class="fielddoc"><p >Setup default type libraries. </p>
<p >(called after loading a new file into the database). The processor module may load tils, setup memory model and perform other actions required to set up the type system. This is an optional callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">void</td><td></td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aa97519e3d4a7c838b5bea894471d1605" name="a2d184a313fab28b517e82c1717d562a0aa97519e3d4a7c838b5bea894471d1605"></a>ev_get_abi_info&#160;</td><td class="fielddoc"><p >Get all possible ABI names and optional extensions for given compiler abiname/option is a string entirely consisting of letters, digits and underscore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abi_names</td><td>(qstrvec_t *) - all possible ABis each in form abiname-opt1-opt2-... </td></tr>
    <tr><td class="paramname">abi_opts</td><td>(qstrvec_t *) - array of all possible options in form "opt:description" or opt:hint-line#description </td></tr>
    <tr><td class="paramname">comp</td><td>(comp_t) - compiler ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aa72e8b0fefe1ccb4f97c3ab7d963403e" name="a2d184a313fab28b517e82c1717d562a0aa72e8b0fefe1ccb4f97c3ab7d963403e"></a>ev_max_ptr_size&#160;</td><td class="fielddoc"><p >Get maximal size of a pointer in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max possible size of a pointer </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a445f041d8992406148c70d2265aeeaeb" name="a2d184a313fab28b517e82c1717d562a0a445f041d8992406148c70d2265aeeaeb"></a>ev_get_default_enum_size&#160;</td><td class="fielddoc"><p >Get default enum size. </p>
<p >Not generated anymore. inf_get_cc_size_e() is used instead </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a4d4579748c4e9235161552951f41243e" name="a2d184a313fab28b517e82c1717d562a0a4d4579748c4e9235161552951f41243e"></a>ev_get_cc_regs&#160;</td><td class="fielddoc"><p >Get register allocation convention for given calling convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regs</td><td>(<a class="el" href="classcallregs__t.html" title="Register allocation calling convention.">callregs_t</a> *), out </td></tr>
    <tr><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model">cm_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td></td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a1bf26205e3b0ebac0487c0d398774771" name="a2d184a313fab28b517e82c1717d562a0a1bf26205e3b0ebac0487c0d398774771"></a>ev_obsolete1&#160;</td><td class="fielddoc"><p >ev_get_stkarg_offset is obsolete. </p>
<p >See ev_get_stkarg_area_info </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0abdf38950e08c904c24cf189f2f3be155" name="a2d184a313fab28b517e82c1717d562a0abdf38950e08c904c24cf189f2f3be155"></a>ev_obsolete2&#160;</td><td class="fielddoc"><p >ev_shadow_args_size is obsolete. </p>
<p >See ev_get_stkarg_area_info </p>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0afa23f72943023fbb22dbc682beca757c" name="a2d184a313fab28b517e82c1717d562a0afa23f72943023fbb22dbc682beca757c"></a>ev_get_simd_types&#160;</td><td class="fielddoc"><p >Get SIMD-related types according to given attributes ant/or argument location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>(::simd_info_vec_t *) </td></tr>
    <tr><td class="paramname">simd_attrs</td><td>(const <a class="el" href="structsimd__info__t.html" title="SIMD type info.">simd_info_t</a> *), may be nullptr </td></tr>
    <tr><td class="paramname">argloc</td><td>(const <a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> *), may be nullptr </td></tr>
    <tr><td class="paramname">create_tifs</td><td>(bool) return valid <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a> objects, create if neccessary </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">number</td><td>of found types </td></tr>
    <tr><td class="paramname">-1</td><td>error If name==nullptr, initialize all SIMD types </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae4a7bab1ce8d51fef3323630c8ab5986" name="a2d184a313fab28b517e82c1717d562a0ae4a7bab1ce8d51fef3323630c8ab5986"></a>ev_calc_cdecl_purged_bytes&#160;</td><td class="fielddoc"><p >Calculate number of purged bytes after call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(::ea_t) address of the call instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of purged bytes (usually add sp, N) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a04dc0f7ffee5e8ce6d9bd2659f5fb48d" name="a2d184a313fab28b517e82c1717d562a0a04dc0f7ffee5e8ce6d9bd2659f5fb48d"></a>ev_calc_purged_bytes&#160;</td><td class="fielddoc"><p >Calculate number of purged bytes by the given function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_purged_bytes</td><td>(int *) ptr to output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fti</td><td>(const <a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details())">func_type_data_t</a> *) func type details </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td></td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a0d69f230a16256b7c97ec87e16a6f814" name="a2d184a313fab28b517e82c1717d562a0a0d69f230a16256b7c97ec87e16a6f814"></a>ev_calc_retloc&#160;</td><td class="fielddoc"><p >Calculate return value location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">retloc</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> *) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rettype</td><td>(const <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a> *) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model">cm_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok, </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a8db94c9ea9bd7e6039821e897b952f82" name="a2d184a313fab28b517e82c1717d562a0a8db94c9ea9bd7e6039821e897b952f82"></a>ev_calc_arglocs&#160;</td><td class="fielddoc"><p >Calculate function argument locations. </p>
<p >This callback should fill retloc, all arglocs, and stkargs. This callback is never called for <a class="el" href="typeinf_8hpp.html#a377054c414ac35be6e5e9bf6c550b390" title="usercall: locations of all arguments and the return value are explicitly specified">CM_CC_SPECIAL</a> functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fti</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details())">func_type_data_t</a> *) points to the func type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a4537faf41cc6bd81946ec4cfd4b2db5a" name="a2d184a313fab28b517e82c1717d562a0a4537faf41cc6bd81946ec4cfd4b2db5a"></a>ev_calc_varglocs&#160;</td><td class="fielddoc"><p >Calculate locations of the arguments that correspond to '...'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ftd</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details())">func_type_data_t</a> *), inout: info about all arguments (including varargs) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aux_regs</td><td>(<a class="el" href="structregobjs__t.html">regobjs_t</a> *) buffer for hidden register arguments, may be nullptr </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aux_stkargs</td><td>(<a class="el" href="structrelobj__t.html" title="Relocatable object.">relobj_t</a> *) buffer for hidden stack arguments, may be nullptr </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nfixed</td><td>(int) number of fixed arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error On some platforms variadic calls require passing additional information: for example, number of floating variadic arguments must be passed in rax on gcc-x64. The locations and values that constitute this additional information are returned in the buffers pointed by aux_regs and aux_stkargs </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ae6d879a79e41acf6c15241f8a8616413" name="a2d184a313fab28b517e82c1717d562a0ae6d879a79e41acf6c15241f8a8616413"></a>ev_adjust_argloc&#160;</td><td class="fielddoc"><p >Adjust argloc according to its type/size and platform endianess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argloc</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> *), inout </td></tr>
    <tr><td class="paramname">type</td><td>(const <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a> *), may be nullptr nullptr means primitive type of given size </td></tr>
    <tr><td class="paramname">size</td><td>(int) 'size' makes no sense if type != nullptr (type-&gt;get_size() should be used instead) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0af54f85e43c332ae869c5e9015e1f3203" name="a2d184a313fab28b517e82c1717d562a0af54f85e43c332ae869c5e9015e1f3203"></a>ev_lower_func_type&#160;</td><td class="fielddoc"><p >Get function arguments which should be converted to pointers when lowering function prototype. </p>
<p >The processor module can also modify 'fti' in order to make non-standard conversion of some arguments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argnums</td><td>(intvec_t *), out - numbers of arguments to be converted to pointers in acsending order </td></tr>
    <tr><td class="paramname">fti</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details())">func_type_data_t</a> *), inout func type details (special values -1/-2 for return value - position of hidden 'retstr' argument: -1 - at the beginning, -2 - at the end) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
    <tr><td class="paramname">1</td><td>argnums was filled </td></tr>
    <tr><td class="paramname">2</td><td>argnums was filled and made substantial changes to fti </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0aacf3158cd80a47e0f87786c60f6f1b6a" name="a2d184a313fab28b517e82c1717d562a0aacf3158cd80a47e0f87786c60f6f1b6a"></a>ev_equal_reglocs&#160;</td><td class="fielddoc"><p >Are 2 register arglocs the same?. </p>
<p >We need this callback for the pc module. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> *) </td></tr>
    <tr><td class="paramname">a2</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">-1</td><td>no </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a5551d04ee2e1a9f77a06ea2da02e5ffc" name="a2d184a313fab28b517e82c1717d562a0a5551d04ee2e1a9f77a06ea2da02e5ffc"></a>ev_use_stkarg_type&#160;</td><td class="fielddoc"><p >Use information about a stack argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(::ea_t) address of the push instruction which pushes the function argument into the stack </td></tr>
    <tr><td class="paramname">arg</td><td>(const <a class="el" href="structfuncarg__t.html" title="Information about a single function argument.">funcarg_t</a> *) argument info </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>failed, the kernel will create a comment with the argument name or type for the instruction </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a239afca977e96df72bf4680c8843662a" name="a2d184a313fab28b517e82c1717d562a0a239afca977e96df72bf4680c8843662a"></a>ev_use_regarg_type&#160;</td><td class="fielddoc"><p >Use information about register argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">idx</td><td>(int *) pointer to the returned value, may contain:<ul>
<li>idx of the used argument, if the argument is defined in the current instruction, a comment will be applied by the kernel</li>
<li>idx | <a class="el" href="idp_8hpp.html#a062e4611e8876c7b1608cbecab0d94ed" title="processor_t::use_regarg_type uses this bit in the return value to indicate that the register value ha...">REG_SPOIL</a> - argument is spoiled by the instruction</li>
<li>-1 if the instruction doesn't change any registers</li>
<li>-2 if the instruction spoils all registers </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ea</td><td>(::ea_t) address of the instruction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rargs</td><td>(const <a class="el" href="typeinf_8hpp.html#a6b5faeba43c9a59ec3aae166657ff78a" title="vector of function argument objects">funcargvec_t</a> *) vector of register arguments (including regs extracted from scattered arguments) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td></td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a97d8ef8f70c0d9e0e53726ab6cea7671" name="a2d184a313fab28b517e82c1717d562a0a97d8ef8f70c0d9e0e53726ab6cea7671"></a>ev_use_arg_types&#160;</td><td class="fielddoc"><p >Use information about callee arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(::ea_t) address of the call instruction </td></tr>
    <tr><td class="paramname">fti</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details())">func_type_data_t</a> *) info about function type </td></tr>
    <tr><td class="paramname">rargs</td><td>(<a class="el" href="typeinf_8hpp.html#a6b5faeba43c9a59ec3aae166657ff78a" title="vector of function argument objects">funcargvec_t</a> *) array of register arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>(and removes handled arguments from fti and rargs) </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a63c06a7cbeccfbc66ba9981ccde80e77" name="a2d184a313fab28b517e82c1717d562a0a63c06a7cbeccfbc66ba9981ccde80e77"></a>ev_arg_addrs_ready&#160;</td><td class="fielddoc"><p >Argument address info is ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>(::ea_t) </td></tr>
    <tr><td class="paramname">n</td><td>(int) number of formal arguments </td></tr>
    <tr><td class="paramname">tif</td><td>(<a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a> *) call prototype </td></tr>
    <tr><td class="paramname">addrs</td><td>(::ea_t *) argument intilization addresses </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;0</td><td>do not save into idb; other values mean "ok to save" </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a8341bbf9f53b19f61d4d7adcdc51783b" name="a2d184a313fab28b517e82c1717d562a0a8341bbf9f53b19f61d4d7adcdc51783b"></a>ev_decorate_name&#160;</td><td class="fielddoc"><p >Decorate/undecorate a C symbol name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuf</td><td>(<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce" title="regular string">qstring</a> *) output buffer </td></tr>
    <tr><td class="paramname">name</td><td>(const char *) name of symbol </td></tr>
    <tr><td class="paramname">mangle</td><td>(bool) true-mangle, false-unmangle </td></tr>
    <tr><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model">cm_t</a>) calling convention </td></tr>
    <tr><td class="paramname">type</td><td>(const <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a> *) name type (nullptr-unknown) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if success </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0ad7314c36f63706b4471231a362ff9fcc" name="a2d184a313fab28b517e82c1717d562a0ad7314c36f63706b4471231a362ff9fcc"></a>ev_arch_changed&#160;</td><td class="fielddoc"><p >The loader is done parsing arch-related information, which the processor module might want to use to finish its initialization. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if success </td></tr>
    <tr><td class="paramname">0</td><td>not implemented or failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a0047baea74fe2c1d040d1c1feeb48e8f" name="a2d184a313fab28b517e82c1717d562a0a0047baea74fe2c1d040d1c1feeb48e8f"></a>ev_get_stkarg_area_info&#160;</td><td class="fielddoc"><p >Get some metrics of the stack argument area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>(<a class="el" href="structstkarg__area__info__t.html" title="Some calling conventions foresee special areas on the stack for call arguments.">stkarg_area_info_t</a> *) ptr to <a class="el" href="structstkarg__area__info__t.html" title="Some calling conventions foresee special areas on the stack for call arguments.">stkarg_area_info_t</a> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model">cm_t</a>) calling convention </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>if success </td></tr>
    <tr><td class="paramname">0</td><td>not implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="a2d184a313fab28b517e82c1717d562a0a562fb16cff7e5e0c0f5750788c24d99c" name="a2d184a313fab28b517e82c1717d562a0a562fb16cff7e5e0c0f5750788c24d99c"></a>ev_loader&#160;</td><td class="fielddoc"><p >This code and higher ones are reserved for the loaders. </p>
<p >The arguments and the return values are defined by the loaders </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a94a0f415add42933cb196bec15d66b11" name="a94a0f415add42933cb196bec15d66b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a0f415add42933cb196bec15d66b11">&#9670;&nbsp;</a></span>get_default_segm_bitness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int processor_t::get_default_segm_bitness </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_64bit_app</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get default segment bitness. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td><a class="el" href="idp_8hpp.html#a51211ffe0d08c32dece2d318a462e139" title="segments are 64-bit by default">PR_DEFSEG64</a> </td></tr>
    <tr><td class="paramname">1</td><td><a class="el" href="idp_8hpp.html#a91a0359d79ef2256ffb0b29ae7e481cb" title="segments are 32-bit by default">PR_DEFSEG32</a> </td></tr>
    <tr><td class="paramname">0</td><td>none specified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a107c1d598682bbc3fd8edb8d51ae6f4e" name="a107c1d598682bbc3fd8edb8d51ae6f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107c1d598682bbc3fd8edb8d51ae6f4e">&#9670;&nbsp;</a></span>get_proc_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int processor_t::get_proc_index </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">currently</td><td>selected processor subtype (index into psnames/plnames) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03d0cfc92bf4cb082e74da3cf18020a5" name="a03d0cfc92bf4cb082e74da3cf18020a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d0cfc92bf4cb082e74da3cf18020a5">&#9670;&nbsp;</a></span>get_reg_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * processor_t::get_reg_info </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbitrange__t.html">bitrange_t</a> *&#160;</td>
          <td class="paramname"><em>bitrange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get register information - useful for registers like al, ah, dil, etc. </p>
<p >Example: this function for "al" returns "eax" in 32bit mode </p><dl class="section return"><dt>Returns</dt><dd>main register name (nullptr no such register) </dd></dl>

</div>
</div>
<a id="abe691f9f3c80817bd9d1e19e8ee5f926" name="abe691f9f3c80817bd9d1e19e8ee5f926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe691f9f3c80817bd9d1e19e8ee5f926">&#9670;&nbsp;</a></span>get_stkvar_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int processor_t::get_stkvar_scale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stack variable scaling factor. </p>
<p >Useful for processors who refer to the stack with implicit scaling factor. TMS320C55 for example: SP(#1) really refers to (SP+2) </p>

</div>
</div>
<a id="a461e26b10900db7a5e6b843fe8ce7434" name="a461e26b10900db7a5e6b843fe8ce7434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461e26b10900db7a5e6b843fe8ce7434">&#9670;&nbsp;</a></span>is_canon_insn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool processor_t::is_canon_insn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>itype</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the given value specify a valid instruction for this instruction set?. </p>
<p >See <a class="el" href="structprocessor__t.html#a35f080945b61116baab1bfc67f195f62" title="icode of the first instruction">instruc_start</a> and <a class="el" href="structprocessor__t.html#a5bc594ff4b32014972b205b5c9b07deb" title="icode of the last instruction + 1">instruc_end</a> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae86f81b3e716d4bf17f424688cf5aeab" name="ae86f81b3e716d4bf17f424688cf5aeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86f81b3e716d4bf17f424688cf5aeab">&#9670;&nbsp;</a></span>cnbits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> processor_t::cnbits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits in a byte for code segments (usually 8). </p>
<p >IDA supports values up to supported address bits size </p>

</div>
</div>
<a id="a94c90b8e3ee733f9f843fc6297bd1977" name="a94c90b8e3ee733f9f843fc6297bd1977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c90b8e3ee733f9f843fc6297bd1977">&#9670;&nbsp;</a></span>dnbits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> processor_t::dnbits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits in a byte for non-code segments (usually 8). </p>
<p >IDA supports values up to supported address bit size </p>

</div>
</div>
<a id="a7f36c9be272d994bc341b3fcb78726f6" name="a7f36c9be272d994bc341b3fcb78726f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f36c9be272d994bc341b3fcb78726f6">&#9670;&nbsp;</a></span>psnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* processor_t::psnames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>short processor names (nullptr terminated). </p>
<p >Each name should be shorter than 9 characters </p>

</div>
</div>
<a id="adb54cc1d2faab6891ad190e2e5b7bf08" name="adb54cc1d2faab6891ad190e2e5b7bf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb54cc1d2faab6891ad190e2e5b7bf08">&#9670;&nbsp;</a></span>plnames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* processor_t::plnames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>long processor names (nullptr terminated). </p>
<p >No restriction on name lengths. </p>

</div>
</div>
<a id="a13faa23b7174cbdbae5da42c71602d24" name="a13faa23b7174cbdbae5da42c71602d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13faa23b7174cbdbae5da42c71602d24">&#9670;&nbsp;</a></span>assemblers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structasm__t.html">asm_t</a>* const* processor_t::assemblers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to array of target </p>
<p >assembler definitions. You may change this array when current processor is changed. (nullptr terminated) </p>

</div>
</div>
<a id="a9414a4e585ab47514144871a585cc120" name="a9414a4e585ab47514144871a585cc120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9414a4e585ab47514144871a585cc120">&#9670;&nbsp;</a></span>codestart</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbytes__t.html">bytes_t</a>* processor_t::codestart</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of typical code start sequences. </p>
<p >This array is used when a new file is loaded to find the beginnings of code sequences. This array is terminated with a zero length item. </p>

</div>
</div>
<a id="ab3849caf742c36dc743f0aa88267221a" name="ab3849caf742c36dc743f0aa88267221a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3849caf742c36dc743f0aa88267221a">&#9670;&nbsp;</a></span>retcodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbytes__t.html">bytes_t</a>* processor_t::retcodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of 'return' instruction opcodes. </p>
<p >This array is used to determine form of autogenerated locret_... labels. The last item of it should be { 0, nullptr } This array may be nullptr Better way of handling return instructions is to define the <a class="el" href="">is_ret_insn</a> callback in the notify() function </p>

</div>
</div>
<a id="ab1ed6541f40864dcf175219db42afa90" name="ab1ed6541f40864dcf175219db42afa90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ed6541f40864dcf175219db42afa90">&#9670;&nbsp;</a></span>real_width</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char processor_t::real_width[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of digits in floating numbers after the decimal point. </p>
<p >If an element of this array equals 0, then the corresponding floating point data is not used for the processor. This array is used to align numbers in the output.</p><ul>
<li>real_width[0] - number of digits for short floats (only PDP-11 has them)</li>
<li>real_width[1] - number of digits for "float"</li>
<li>real_width[2] - number of digits for "double"</li>
<li>real_width[3] - number of digits for "long double"</li>
</ul>
<p >Example: IBM PC module has { 0,7,15,19 } </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li><a class="el" href="idp_8hpp.html">idp.hpp</a></li>
<li><a class="el" href="frame_8hpp.html">frame.hpp</a></li>
<li><a class="el" href="typeinf_8hpp.html">typeinf.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
