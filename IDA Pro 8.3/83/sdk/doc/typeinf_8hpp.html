<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: typeinf.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">typeinf.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Describes the type information records in IDA.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtype__attr__t.html">type_attr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended type attributes.  <a href="structtype__attr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtil__t.html">til_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Information Library.  <a href="structtil__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrrel__t.html">rrel_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register-relative argument location.  <a href="structrrel__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcustloc__desc__t.html">custloc_desc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of a custom argloc.  <a href="structcustloc__desc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classargloc__t.html">argloc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes an argument location.  <a href="classargloc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structargpart__t.html">argpart_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subsection of an argument location.  <a href="structargpart__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscattered__aloc__t.html">scattered_aloc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to manage arguments that are described by multiple locations (also see <a class="el" href="typeinf_8hpp.html#a77ee658648b8a9f916838508ab40fb5a" title="distributed (scattered)">ALOC_DIST</a>)  <a href="classscattered__aloc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaloc__visitor__t.html">aloc_visitor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all argument locations.  <a href="structaloc__visitor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structconst__aloc__visitor__t.html">const_aloc_visitor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="structaloc__visitor__t.html" title="Visit all argument locations.">aloc_visitor_t</a>, but may not modify the argloc.  <a href="structconst__aloc__visitor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcallregs__t.html">callregs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register allocation calling convention.  <a href="classcallregs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html">tinfo_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary mechanism for managing type information.  <a href="classtinfo__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimd__info__t.html">simd_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SIMD type info.  <a href="structsimd__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptr__type__data__t.html">ptr_type_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type information (see <a class="el" href="classtinfo__t.html#a5e4c70cdadcbc8f14d8d91444f75e95d" title="Get the pointer info.">tinfo_t::get_ptr_details()</a>)  <a href="structptr__type__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structarray__type__data__t.html">array_type_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array type information (see <a class="el" href="classtinfo__t.html#a0a918da4bbf7aec65717812fdf697609" title="Get the array specific info.">tinfo_t::get_array_details()</a>)  <a href="structarray__type__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuncarg__t.html">funcarg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a single function argument.  <a href="structfuncarg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfunc__type__data__t.html">func_type_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type information (see <a class="el" href="classtinfo__t.html#adfb1d3f3412255927be1249a0324cbf6" title="Get only the function specific info for this tinfo_t.">tinfo_t::get_func_details()</a>)  <a href="structfunc__type__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstkarg__area__info__t.html">stkarg_area_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some calling conventions foresee special areas on the stack for call arguments.  <a href="structstkarg__area__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenum__member__t.html">enum_member_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes an enum value.  <a href="structenum__member__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenum__type__data__t.html">enum_type_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum type information (see <a class="el" href="classtinfo__t.html#a22c28682b2e16f80556083729baf6784" title="Get the enum specific info.">tinfo_t::get_enum_details()</a>)  <a href="structenum__type__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtypedef__type__data__t.html">typedef_type_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for typedefs.  <a href="structtypedef__type__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudt__member__t.html">udt_member_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object to represent struct or union members.  <a href="structudt__member__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudtmembervec__t.html">udtmembervec_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of udt member objects  <a href="structudtmembervec__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudt__type__data__t.html">udt_type_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object to represent struct or union types (see <a class="el" href="classtinfo__t.html#a573d7effeb0a38326f7e4e7d8d94658e" title="Get the udt specific info.">tinfo_t::get_udt_details()</a>)  <a href="structudt__type__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbitfield__type__data__t.html">bitfield_type_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitfield type information (see <a class="el" href="classtinfo__t.html#ad2e073cee94ccb0ed8b2e98db467ed8f" title="Get the bitfield specific info.">tinfo_t::get_bitfield_details()</a>)  <a href="structbitfield__type__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtype__mods__t.html">type_mods_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about how to modify the current type, used by <a class="el" href="structtinfo__visitor__t.html" title="Visit all subtypes of a type. Derive your visitor from this class and use apply_to()">tinfo_visitor_t</a>.  <a href="structtype__mods__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtinfo__visitor__t.html">tinfo_visitor_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all subtypes of a type. Derive your visitor from this class and use <a class="el" href="structtinfo__visitor__t.html#a8b4268fad62279ce820eb222ff3558be" title="Call this function to initiate the traversal.">apply_to()</a>  <a href="structtinfo__visitor__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregobj__t.html">regobj_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object that represents a register.  <a href="structregobj__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregobjs__t.html">regobjs_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structargtinfo__helper__t.html">argtinfo_helper_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlowertype__helper__t.html">lowertype_helper_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class - see <a class="el" href="classida__lowertype__helper__t.html" title="An implementation of lowertype_helper_t that has access to the IDB, and thus can help spot holes in t...">ida_lowertype_helper_t</a>.  <a href="classlowertype__helper__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classida__lowertype__helper__t.html">ida_lowertype_helper_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <a class="el" href="classlowertype__helper__t.html" title="Interface class - see ida_lowertype_helper_t.">lowertype_helper_t</a> that has access to the IDB, and thus can help spot holes in the stack arguments.  <a href="classida__lowertype__helper__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structformat__data__info__t.html">format_data_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#ae2724af804f94383fa884c10d8774425" title="Format a data value as a C initializer.">format_cdata()</a>  <a href="structformat__data__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvalinfo__t.html">valinfo_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional information about the output lines.  <a href="structvalinfo__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvalstr__t.html">valstr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Text representation of a data value (value string).  <a href="classvalstr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvalstrs__t.html">valstrs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of value strings.  <a href="structvalstrs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtext__sink__t.html">text_sink_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush formatted text.  <a href="structtext__sink__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtil__symbol__t.html">til_symbol_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol in a type library.  <a href="structtil__symbol__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpredicate__t.html">predicate_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for <a class="el" href="typeinf_8hpp.html#a52f7cfb48f3f391a78f8fea18e3e51ea" title="Choose a type from a type library.">choose_named_type()</a>.  <a href="structpredicate__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8ac9fa3da7151dc5ffd9fbf0563a9417"><td class="memItemLeft" align="right" valign="top"><a id="a8ac9fa3da7151dc5ffd9fbf0563a9417" name="a8ac9fa3da7151dc5ffd9fbf0563a9417"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RESERVED_BYTE</b>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:a8ac9fa3da7151dc5ffd9fbf0563a9417"><td class="mdescLeft">&#160;</td><td class="mdescRight">multifunctional purpose <br /></td></tr>
<tr class="separator:a8ac9fa3da7151dc5ffd9fbf0563a9417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d014aaf0adefbc58fe6f6331ce7463f"><td class="memItemLeft" align="right" valign="top"><a id="a4d014aaf0adefbc58fe6f6331ce7463f" name="a4d014aaf0adefbc58fe6f6331ce7463f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAH_BYTE</b>&#160;&#160;&#160;0xFE</td></tr>
<tr class="memdesc:a4d014aaf0adefbc58fe6f6331ce7463f"><td class="mdescLeft">&#160;</td><td class="mdescRight">type attribute header byte <br /></td></tr>
<tr class="separator:a4d014aaf0adefbc58fe6f6331ce7463f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68b66c0853e4271d2ab199fa3a50f3f"><td class="memItemLeft" align="right" valign="top"><a id="ab68b66c0853e4271d2ab199fa3a50f3f" name="ab68b66c0853e4271d2ab199fa3a50f3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FAH_BYTE</b>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ab68b66c0853e4271d2ab199fa3a50f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function argument attribute header byte <br /></td></tr>
<tr class="separator:ab68b66c0853e4271d2ab199fa3a50f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82df752b4c58e1cd29da4c2d4fbac83f"><td class="memItemLeft" align="right" valign="top"><a id="a82df752b4c58e1cd29da4c2d4fbac83f" name="a82df752b4c58e1cd29da4c2d4fbac83f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_DECL_ALIGN</b>&#160;&#160;&#160;0x000F</td></tr>
<tr class="separator:a82df752b4c58e1cd29da4c2d4fbac83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916d3ac71d35862753a03da1dad9ae3f"><td class="memItemLeft" align="right" valign="top"><a id="a916d3ac71d35862753a03da1dad9ae3f" name="a916d3ac71d35862753a03da1dad9ae3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAH_HASATTRS</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a916d3ac71d35862753a03da1dad9ae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">has extended attributes <br /></td></tr>
<tr class="separator:a916d3ac71d35862753a03da1dad9ae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ae2c2bf042458d4fc491cfd36a1911"><td class="memItemLeft" align="right" valign="top"><a id="a81ae2c2bf042458d4fc491cfd36a1911" name="a81ae2c2bf042458d4fc491cfd36a1911"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAUDT_UNALIGNED</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a81ae2c2bf042458d4fc491cfd36a1911"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct: unaligned struct <br /></td></tr>
<tr class="separator:a81ae2c2bf042458d4fc491cfd36a1911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83281db9fdbee27bcda12845c5e4a864"><td class="memItemLeft" align="right" valign="top"><a id="a83281db9fdbee27bcda12845c5e4a864" name="a83281db9fdbee27bcda12845c5e4a864"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAUDT_MSSTRUCT</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a83281db9fdbee27bcda12845c5e4a864"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct: gcc msstruct attribute <br /></td></tr>
<tr class="separator:a83281db9fdbee27bcda12845c5e4a864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab368afc5cc062fe59b4c983d1b630dbd"><td class="memItemLeft" align="right" valign="top"><a id="ab368afc5cc062fe59b4c983d1b630dbd" name="ab368afc5cc062fe59b4c983d1b630dbd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAUDT_CPPOBJ</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:ab368afc5cc062fe59b4c983d1b630dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct: a c++ object, not simple pod type <br /></td></tr>
<tr class="separator:ab368afc5cc062fe59b4c983d1b630dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7472d4a2330849f0f77a3dbd4fafa895"><td class="memItemLeft" align="right" valign="top"><a id="a7472d4a2330849f0f77a3dbd4fafa895" name="a7472d4a2330849f0f77a3dbd4fafa895"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAUDT_VFTABLE</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a7472d4a2330849f0f77a3dbd4fafa895"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct: is virtual function table <br /></td></tr>
<tr class="separator:a7472d4a2330849f0f77a3dbd4fafa895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab00c307a36c53a11b2dbcf7d727b88"><td class="memItemLeft" align="right" valign="top"><a id="a0ab00c307a36c53a11b2dbcf7d727b88" name="a0ab00c307a36c53a11b2dbcf7d727b88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAFLD_BASECLASS</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a0ab00c307a36c53a11b2dbcf7d727b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">field: do not include but inherit from the current field <br /></td></tr>
<tr class="separator:a0ab00c307a36c53a11b2dbcf7d727b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b7e17baf9740c9798df7f0cf4d2aeb"><td class="memItemLeft" align="right" valign="top"><a id="a00b7e17baf9740c9798df7f0cf4d2aeb" name="a00b7e17baf9740c9798df7f0cf4d2aeb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAFLD_UNALIGNED</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a00b7e17baf9740c9798df7f0cf4d2aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">field: unaligned field <br /></td></tr>
<tr class="separator:a00b7e17baf9740c9798df7f0cf4d2aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e55aa9978345a61f18ccdedc773d4a"><td class="memItemLeft" align="right" valign="top"><a id="af8e55aa9978345a61f18ccdedc773d4a" name="af8e55aa9978345a61f18ccdedc773d4a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAFLD_VIRTBASE</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:af8e55aa9978345a61f18ccdedc773d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">field: virtual base (not supported yet) <br /></td></tr>
<tr class="separator:af8e55aa9978345a61f18ccdedc773d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9061798631889a6bfc3aaf846266cc02"><td class="memItemLeft" align="right" valign="top"><a id="a9061798631889a6bfc3aaf846266cc02" name="a9061798631889a6bfc3aaf846266cc02"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAFLD_VFTABLE</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a9061798631889a6bfc3aaf846266cc02"><td class="mdescLeft">&#160;</td><td class="mdescRight">field: ptr to virtual function table <br /></td></tr>
<tr class="separator:a9061798631889a6bfc3aaf846266cc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f06ecd91852274bb42634708ad112b6"><td class="memItemLeft" align="right" valign="top"><a id="a1f06ecd91852274bb42634708ad112b6" name="a1f06ecd91852274bb42634708ad112b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAFLD_METHOD</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:a1f06ecd91852274bb42634708ad112b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">denotes a udt member function <br /></td></tr>
<tr class="separator:a1f06ecd91852274bb42634708ad112b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af777c7d25915e872577ad083a7d41c72"><td class="memItemLeft" align="right" valign="top"><a id="af777c7d25915e872577ad083a7d41c72" name="af777c7d25915e872577ad083a7d41c72"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAPTR_PTR32</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:af777c7d25915e872577ad083a7d41c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">ptr: __ptr32 <br /></td></tr>
<tr class="separator:af777c7d25915e872577ad083a7d41c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc50904a31ca70cc52336b97a79f7ba"><td class="memItemLeft" align="right" valign="top"><a id="a1fc50904a31ca70cc52336b97a79f7ba" name="a1fc50904a31ca70cc52336b97a79f7ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAPTR_PTR64</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a1fc50904a31ca70cc52336b97a79f7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">ptr: __ptr64 <br /></td></tr>
<tr class="separator:a1fc50904a31ca70cc52336b97a79f7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab402eeeb093941cab4c5591b9493d59d"><td class="memItemLeft" align="right" valign="top"><a id="ab402eeeb093941cab4c5591b9493d59d" name="ab402eeeb093941cab4c5591b9493d59d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAPTR_RESTRICT</b>&#160;&#160;&#160;0x0060</td></tr>
<tr class="memdesc:ab402eeeb093941cab4c5591b9493d59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ptr: __restrict <br /></td></tr>
<tr class="separator:ab402eeeb093941cab4c5591b9493d59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc0e4c4ae2bec591baa6c19ab7d6f02"><td class="memItemLeft" align="right" valign="top"><a id="a9fc0e4c4ae2bec591baa6c19ab7d6f02" name="a9fc0e4c4ae2bec591baa6c19ab7d6f02"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAPTR_SHIFTED</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:a9fc0e4c4ae2bec591baa6c19ab7d6f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">ptr: __shifted(parent_struct, delta) <br /></td></tr>
<tr class="separator:a9fc0e4c4ae2bec591baa6c19ab7d6f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fa401c2f279d191558e81c4f331f76"><td class="memItemLeft" align="right" valign="top"><a id="a31fa401c2f279d191558e81c4f331f76" name="a31fa401c2f279d191558e81c4f331f76"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAENUM_64BIT</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a31fa401c2f279d191558e81c4f331f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum: store 64-bit values <br /></td></tr>
<tr class="separator:a31fa401c2f279d191558e81c4f331f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff240e83c8f81a5e2b8c8e49b74b846"><td class="memItemLeft" align="right" valign="top"><a id="acff240e83c8f81a5e2b8c8e49b74b846" name="acff240e83c8f81a5e2b8c8e49b74b846"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAENUM_UNSIGNED</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:acff240e83c8f81a5e2b8c8e49b74b846"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum: unsigned <br /></td></tr>
<tr class="separator:acff240e83c8f81a5e2b8c8e49b74b846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d40a79f327565a325cf463511c53b0"><td class="memItemLeft" align="right" valign="top"><a id="a62d40a79f327565a325cf463511c53b0" name="a62d40a79f327565a325cf463511c53b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAENUM_SIGNED</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:a62d40a79f327565a325cf463511c53b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum: signed <br /></td></tr>
<tr class="separator:a62d40a79f327565a325cf463511c53b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c9c788d7c5c02a4159bd84cc2bccf8"><td class="memItemLeft" align="right" valign="top"><a id="ae3c9c788d7c5c02a4159bd84cc2bccf8" name="ae3c9c788d7c5c02a4159bd84cc2bccf8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TAH_ALL</b>&#160;&#160;&#160;0x03F0</td></tr>
<tr class="memdesc:ae3c9c788d7c5c02a4159bd84cc2bccf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">all defined bits <br /></td></tr>
<tr class="separator:ae3c9c788d7c5c02a4159bd84cc2bccf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e20be490cde97b1bee4d26d513b13"><td class="memItemLeft" align="right" valign="top"><a id="a5f8e20be490cde97b1bee4d26d513b13" name="a5f8e20be490cde97b1bee4d26d513b13"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_ZIP</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a5f8e20be490cde97b1bee4d26d513b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">pack buckets using zip <br /></td></tr>
<tr class="separator:a5f8e20be490cde97b1bee4d26d513b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f74661c533ae3f9e912d2407a5cf789"><td class="memItemLeft" align="right" valign="top"><a id="a1f74661c533ae3f9e912d2407a5cf789" name="a1f74661c533ae3f9e912d2407a5cf789"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_MAC</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a1f74661c533ae3f9e912d2407a5cf789"><td class="mdescLeft">&#160;</td><td class="mdescRight">til has macro table <br /></td></tr>
<tr class="separator:a1f74661c533ae3f9e912d2407a5cf789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0f0ec96c78c8d64826acda52858e7a"><td class="memItemLeft" align="right" valign="top"><a id="abc0f0ec96c78c8d64826acda52858e7a" name="abc0f0ec96c78c8d64826acda52858e7a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_ESI</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:abc0f0ec96c78c8d64826acda52858e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">extended sizeof info (short, long, longlong) <br /></td></tr>
<tr class="separator:abc0f0ec96c78c8d64826acda52858e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a557dd3f34c36916e9efd02761a14e0"><td class="memItemLeft" align="right" valign="top"><a id="a3a557dd3f34c36916e9efd02761a14e0" name="a3a557dd3f34c36916e9efd02761a14e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_UNI</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a3a557dd3f34c36916e9efd02761a14e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">universal til for any compiler <br /></td></tr>
<tr class="separator:a3a557dd3f34c36916e9efd02761a14e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7d816683f98e6d7f2818b580722988"><td class="memItemLeft" align="right" valign="top"><a id="aab7d816683f98e6d7f2818b580722988" name="aab7d816683f98e6d7f2818b580722988"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_ORD</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:aab7d816683f98e6d7f2818b580722988"><td class="mdescLeft">&#160;</td><td class="mdescRight">type ordinal numbers are present <br /></td></tr>
<tr class="separator:aab7d816683f98e6d7f2818b580722988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bbc047d02e335aaddeef63e9ea2f29"><td class="memItemLeft" align="right" valign="top"><a id="a72bbc047d02e335aaddeef63e9ea2f29" name="a72bbc047d02e335aaddeef63e9ea2f29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_ALI</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a72bbc047d02e335aaddeef63e9ea2f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">type aliases are present (this bit is used only on the disk) <br /></td></tr>
<tr class="separator:a72bbc047d02e335aaddeef63e9ea2f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff79474fab46b219eb0c3742ad8a7760"><td class="memItemLeft" align="right" valign="top"><a id="aff79474fab46b219eb0c3742ad8a7760" name="aff79474fab46b219eb0c3742ad8a7760"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_MOD</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:aff79474fab46b219eb0c3742ad8a7760"><td class="mdescLeft">&#160;</td><td class="mdescRight">til has been modified, should be saved <br /></td></tr>
<tr class="separator:aff79474fab46b219eb0c3742ad8a7760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e55d20cec4a151520a8cd2f6a75331"><td class="memItemLeft" align="right" valign="top"><a id="ad0e55d20cec4a151520a8cd2f6a75331" name="ad0e55d20cec4a151520a8cd2f6a75331"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_STM</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:ad0e55d20cec4a151520a8cd2f6a75331"><td class="mdescLeft">&#160;</td><td class="mdescRight">til has extra streams <br /></td></tr>
<tr class="separator:ad0e55d20cec4a151520a8cd2f6a75331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052bbb807f2442e196a3491cb0999399"><td class="memItemLeft" align="right" valign="top"><a id="a052bbb807f2442e196a3491cb0999399" name="a052bbb807f2442e196a3491cb0999399"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_SLD</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a052bbb807f2442e196a3491cb0999399"><td class="mdescLeft">&#160;</td><td class="mdescRight">sizeof(long double) <br /></td></tr>
<tr class="separator:a052bbb807f2442e196a3491cb0999399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce913832e5d048d6f27551fb01b0f19"><td class="memItemLeft" align="right" valign="top"><a id="a7ce913832e5d048d6f27551fb01b0f19" name="a7ce913832e5d048d6f27551fb01b0f19"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_ADD_FAILED</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a7ce913832e5d048d6f27551fb01b0f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">see errbuf <br /></td></tr>
<tr class="separator:a7ce913832e5d048d6f27551fb01b0f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03512c4fb24398232153bf591a68dee7"><td class="memItemLeft" align="right" valign="top"><a id="a03512c4fb24398232153bf591a68dee7" name="a03512c4fb24398232153bf591a68dee7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_ADD_OK</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a03512c4fb24398232153bf591a68dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">some tils were added <br /></td></tr>
<tr class="separator:a03512c4fb24398232153bf591a68dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada17fd23631b72662f75c17f6474fc5"><td class="memItemLeft" align="right" valign="top"><a id="aada17fd23631b72662f75c17f6474fc5" name="aada17fd23631b72662f75c17f6474fc5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIL_ADD_ALREADY</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:aada17fd23631b72662f75c17f6474fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the base til was already added <br /></td></tr>
<tr class="separator:aada17fd23631b72662f75c17f6474fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1065a51e16a3c2c241ab10e9d2b87b07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a1065a51e16a3c2c241ab10e9d2b87b07">ARGLOC_HELPER_DEFINITIONS</a>(decl)</td></tr>
<tr class="memdesc:a1065a51e16a3c2c241ab10e9d2b87b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to declare common <a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> related functions.  <a href="typeinf_8hpp.html#a1065a51e16a3c2c241ab10e9d2b87b07">More...</a><br /></td></tr>
<tr class="separator:a1065a51e16a3c2c241ab10e9d2b87b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad116a63144af8d2ec22c38fe52a83afc"><td class="memItemLeft" align="right" valign="top"><a id="ad116a63144af8d2ec22c38fe52a83afc" name="ad116a63144af8d2ec22c38fe52a83afc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRALOC_VERIFY</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ad116a63144af8d2ec22c38fe52a83afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">interr if illegal argloc <br /></td></tr>
<tr class="separator:ad116a63144af8d2ec22c38fe52a83afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51017e98e13d8514261572bba7766e75"><td class="memItemLeft" align="right" valign="top"><a id="a51017e98e13d8514261572bba7766e75" name="a51017e98e13d8514261572bba7766e75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRALOC_STKOFF</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:a51017e98e13d8514261572bba7766e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">print stack offsets <br /></td></tr>
<tr class="separator:a51017e98e13d8514261572bba7766e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56c8127b00e8320c3d8d055b28febf1"><td class="memItemLeft" align="right" valign="top"><a id="ad56c8127b00e8320c3d8d055b28febf1" name="ad56c8127b00e8320c3d8d055b28febf1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SETCOMP_OVERRIDE</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:ad56c8127b00e8320c3d8d055b28febf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">may override old compiler info <br /></td></tr>
<tr class="separator:ad56c8127b00e8320c3d8d055b28febf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeecd262c386f90bffb8b60a17fc1e69"><td class="memItemLeft" align="right" valign="top"><a id="aaeecd262c386f90bffb8b60a17fc1e69" name="aaeecd262c386f90bffb8b60a17fc1e69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SETCOMP_ONLY_ID</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:aaeecd262c386f90bffb8b60a17fc1e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">cc has only 'id' field; the rest will be set to defaults corresponding to the program bitness <br /></td></tr>
<tr class="separator:aaeecd262c386f90bffb8b60a17fc1e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac2eeb3b722e6839795598d40beaa24"><td class="memItemLeft" align="right" valign="top"><a id="a4ac2eeb3b722e6839795598d40beaa24" name="a4ac2eeb3b722e6839795598d40beaa24"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SETCOMP_ONLY_ABI</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a4ac2eeb3b722e6839795598d40beaa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore cc field complete, use only abiname <br /></td></tr>
<tr class="separator:a4ac2eeb3b722e6839795598d40beaa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79055d3e62cc32d2178681d62dadcc2d"><td class="memItemLeft" align="right" valign="top"><a id="a79055d3e62cc32d2178681d62dadcc2d" name="a79055d3e62cc32d2178681d62dadcc2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SETCOMP_BY_USER</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a79055d3e62cc32d2178681d62dadcc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoked by user, cannot be replaced by module/loader <br /></td></tr>
<tr class="separator:a79055d3e62cc32d2178681d62dadcc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37518bc74bd0a87c02ca65a1fe8a5842"><td class="memItemLeft" align="right" valign="top"><a id="a37518bc74bd0a87c02ca65a1fe8a5842" name="a37518bc74bd0a87c02ca65a1fe8a5842"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_FUNC_ARGS</b>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:a37518bc74bd0a87c02ca65a1fe8a5842"><td class="mdescLeft">&#160;</td><td class="mdescRight">max number of function arguments <br /></td></tr>
<tr class="separator:a37518bc74bd0a87c02ca65a1fe8a5842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cce1e1fc7eabd7b9eed24de066fb45"><td class="memItemLeft" align="right" valign="top"><a id="a49cce1e1fc7eabd7b9eed24de066fb45" name="a49cce1e1fc7eabd7b9eed24de066fb45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_CPP</b>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="memdesc:a49cce1e1fc7eabd7b9eed24de066fb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ mode (not implemented) <br /></td></tr>
<tr class="separator:a49cce1e1fc7eabd7b9eed24de066fb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbb0ec83121e0da97f2a3d5f8004adf"><td class="memItemLeft" align="right" valign="top"><a id="a4dbb0ec83121e0da97f2a3d5f8004adf" name="a4dbb0ec83121e0da97f2a3d5f8004adf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_INT</b>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="memdesc:a4dbb0ec83121e0da97f2a3d5f8004adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">debug: print internal representation of types <br /></td></tr>
<tr class="separator:a4dbb0ec83121e0da97f2a3d5f8004adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbca1dd0a7f2e5018f5cae7a25368c32"><td class="memItemLeft" align="right" valign="top"><a id="adbca1dd0a7f2e5018f5cae7a25368c32" name="adbca1dd0a7f2e5018f5cae7a25368c32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_EXT</b>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="memdesc:adbca1dd0a7f2e5018f5cae7a25368c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">debug: print external representation of types <br /></td></tr>
<tr class="separator:adbca1dd0a7f2e5018f5cae7a25368c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54721f91611a9e1204882276172b1b8"><td class="memItemLeft" align="right" valign="top"><a id="aa54721f91611a9e1204882276172b1b8" name="aa54721f91611a9e1204882276172b1b8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_LEX</b>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="memdesc:aa54721f91611a9e1204882276172b1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">debug: print tokens <br /></td></tr>
<tr class="separator:aa54721f91611a9e1204882276172b1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707bfb6bc9b4b8ae415124f0fbae003a"><td class="memItemLeft" align="right" valign="top"><a id="a707bfb6bc9b4b8ae415124f0fbae003a" name="a707bfb6bc9b4b8ae415124f0fbae003a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_UNP</b>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="memdesc:a707bfb6bc9b4b8ae415124f0fbae003a"><td class="mdescLeft">&#160;</td><td class="mdescRight">debug: check the result by unpacking it <br /></td></tr>
<tr class="separator:a707bfb6bc9b4b8ae415124f0fbae003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a519695c936b5be4f4f980abf6a6067"><td class="memItemLeft" align="right" valign="top"><a id="a4a519695c936b5be4f4f980abf6a6067" name="a4a519695c936b5be4f4f980abf6a6067"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_TST</b>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="memdesc:a4a519695c936b5be4f4f980abf6a6067"><td class="mdescLeft">&#160;</td><td class="mdescRight">test mode: discard the result <br /></td></tr>
<tr class="separator:a4a519695c936b5be4f4f980abf6a6067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1213cf554de359b9ee23ab2bd4da40"><td class="memItemLeft" align="right" valign="top"><a id="aba1213cf554de359b9ee23ab2bd4da40" name="aba1213cf554de359b9ee23ab2bd4da40"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_FIL</b>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="memdesc:aba1213cf554de359b9ee23ab2bd4da40"><td class="mdescLeft">&#160;</td><td class="mdescRight">"input" is file name, otherwise "input" contains a C declaration <br /></td></tr>
<tr class="separator:aba1213cf554de359b9ee23ab2bd4da40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9bd5e9585c1eb1faab1575c535c115"><td class="memItemLeft" align="right" valign="top"><a id="a5c9bd5e9585c1eb1faab1575c535c115" name="a5c9bd5e9585c1eb1faab1575c535c115"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_MAC</b>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="memdesc:a5c9bd5e9585c1eb1faab1575c535c115"><td class="mdescLeft">&#160;</td><td class="mdescRight">define macros from the base tils <br /></td></tr>
<tr class="separator:a5c9bd5e9585c1eb1faab1575c535c115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26c399e91cd381483f91ef070f2ff37"><td class="memItemLeft" align="right" valign="top"><a id="ad26c399e91cd381483f91ef070f2ff37" name="ad26c399e91cd381483f91ef070f2ff37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_NWR</b>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="memdesc:ad26c399e91cd381483f91ef070f2ff37"><td class="mdescLeft">&#160;</td><td class="mdescRight">no warning messages <br /></td></tr>
<tr class="separator:ad26c399e91cd381483f91ef070f2ff37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26c5cf9257e85b6ec981e43dc6fc7e4"><td class="memItemLeft" align="right" valign="top"><a id="ad26c5cf9257e85b6ec981e43dc6fc7e4" name="ad26c5cf9257e85b6ec981e43dc6fc7e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_NER</b>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="memdesc:ad26c5cf9257e85b6ec981e43dc6fc7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore all errors but display them <br /></td></tr>
<tr class="separator:ad26c5cf9257e85b6ec981e43dc6fc7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eadeea97aa05317c41e939b70714a56"><td class="memItemLeft" align="right" valign="top"><a id="a7eadeea97aa05317c41e939b70714a56" name="a7eadeea97aa05317c41e939b70714a56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_DCL</b>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="memdesc:a7eadeea97aa05317c41e939b70714a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't complain about redeclarations <br /></td></tr>
<tr class="separator:a7eadeea97aa05317c41e939b70714a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162a5cfcabc80d65c8e50a4c36c68b3e"><td class="memItemLeft" align="right" valign="top"><a id="a162a5cfcabc80d65c8e50a4c36c68b3e" name="a162a5cfcabc80d65c8e50a4c36c68b3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_NDC</b>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="memdesc:a162a5cfcabc80d65c8e50a4c36c68b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't decorate names <br /></td></tr>
<tr class="separator:a162a5cfcabc80d65c8e50a4c36c68b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2bfd701e01e14726882db806328b93"><td class="memItemLeft" align="right" valign="top"><a id="adf2bfd701e01e14726882db806328b93" name="adf2bfd701e01e14726882db806328b93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_PAK</b>&#160;&#160;&#160;0x00007000</td></tr>
<tr class="memdesc:adf2bfd701e01e14726882db806328b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicit structure pack value (#pragma pack) <br /></td></tr>
<tr class="separator:adf2bfd701e01e14726882db806328b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01db4a44ee642c8b9cb2fc022c9ee615"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a01db4a44ee642c8b9cb2fc022c9ee615">HTI_PAK_SHIFT</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:a01db4a44ee642c8b9cb2fc022c9ee615"><td class="mdescLeft">&#160;</td><td class="mdescRight">shift for <a class="el" href="typeinf_8hpp.html#adf2bfd701e01e14726882db806328b93" title="explicit structure pack value (#pragma pack)">HTI_PAK</a>.  <a href="typeinf_8hpp.html#a01db4a44ee642c8b9cb2fc022c9ee615">More...</a><br /></td></tr>
<tr class="separator:a01db4a44ee642c8b9cb2fc022c9ee615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f214d59147447ad7fd889d4287d216"><td class="memItemLeft" align="right" valign="top"><a id="a04f214d59147447ad7fd889d4287d216" name="a04f214d59147447ad7fd889d4287d216"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_PAKDEF</b>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="memdesc:a04f214d59147447ad7fd889d4287d216"><td class="mdescLeft">&#160;</td><td class="mdescRight">default pack value <br /></td></tr>
<tr class="separator:a04f214d59147447ad7fd889d4287d216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e27d22a23d0b4424fcb397f8a8bd0fa"><td class="memItemLeft" align="right" valign="top"><a id="a3e27d22a23d0b4424fcb397f8a8bd0fa" name="a3e27d22a23d0b4424fcb397f8a8bd0fa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_PAK1</b>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="memdesc:a3e27d22a23d0b4424fcb397f8a8bd0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">#pragma pack(1) <br /></td></tr>
<tr class="separator:a3e27d22a23d0b4424fcb397f8a8bd0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bbc6117e0f39f556ecf367ea5efd5e"><td class="memItemLeft" align="right" valign="top"><a id="a51bbc6117e0f39f556ecf367ea5efd5e" name="a51bbc6117e0f39f556ecf367ea5efd5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_PAK2</b>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="memdesc:a51bbc6117e0f39f556ecf367ea5efd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">#pragma pack(2) <br /></td></tr>
<tr class="separator:a51bbc6117e0f39f556ecf367ea5efd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1ac9d3ee42f13f54139d4835e290f1"><td class="memItemLeft" align="right" valign="top"><a id="a9f1ac9d3ee42f13f54139d4835e290f1" name="a9f1ac9d3ee42f13f54139d4835e290f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_PAK4</b>&#160;&#160;&#160;0x00003000</td></tr>
<tr class="memdesc:a9f1ac9d3ee42f13f54139d4835e290f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">#pragma pack(4) <br /></td></tr>
<tr class="separator:a9f1ac9d3ee42f13f54139d4835e290f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad316fbc28b048f2e5c44249026791f8c"><td class="memItemLeft" align="right" valign="top"><a id="ad316fbc28b048f2e5c44249026791f8c" name="ad316fbc28b048f2e5c44249026791f8c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_PAK8</b>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="memdesc:ad316fbc28b048f2e5c44249026791f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">#pragma pack(8) <br /></td></tr>
<tr class="separator:ad316fbc28b048f2e5c44249026791f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a272c42dee0ca7a79e087587573688"><td class="memItemLeft" align="right" valign="top"><a id="a78a272c42dee0ca7a79e087587573688" name="a78a272c42dee0ca7a79e087587573688"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_PAK16</b>&#160;&#160;&#160;0x00005000</td></tr>
<tr class="memdesc:a78a272c42dee0ca7a79e087587573688"><td class="mdescLeft">&#160;</td><td class="mdescRight">#pragma pack(16) <br /></td></tr>
<tr class="separator:a78a272c42dee0ca7a79e087587573688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2d19a5da522effe48cfe67e14fc479"><td class="memItemLeft" align="right" valign="top"><a id="a1a2d19a5da522effe48cfe67e14fc479" name="a1a2d19a5da522effe48cfe67e14fc479"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_HIGH</b>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="memdesc:a1a2d19a5da522effe48cfe67e14fc479"><td class="mdescLeft">&#160;</td><td class="mdescRight">assume high level prototypes (with hidden args, etc) <br /></td></tr>
<tr class="separator:a1a2d19a5da522effe48cfe67e14fc479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ab57fb403189b513dc0af7286383d9"><td class="memItemLeft" align="right" valign="top"><a id="a10ab57fb403189b513dc0af7286383d9" name="a10ab57fb403189b513dc0af7286383d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_LOWER</b>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="memdesc:a10ab57fb403189b513dc0af7286383d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower the function prototypes <br /></td></tr>
<tr class="separator:a10ab57fb403189b513dc0af7286383d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2236cc615e41a0bc67e86a93ed82fb46"><td class="memItemLeft" align="right" valign="top"><a id="a2236cc615e41a0bc67e86a93ed82fb46" name="a2236cc615e41a0bc67e86a93ed82fb46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HTI_RAWARGS</b>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="memdesc:a2236cc615e41a0bc67e86a93ed82fb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">leave argument names unchanged (do not remove underscores) <br /></td></tr>
<tr class="separator:a2236cc615e41a0bc67e86a93ed82fb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add54cb3cb262adaa24e8e0a064db915c"><td class="memItemLeft" align="right" valign="top"><a id="add54cb3cb262adaa24e8e0a064db915c" name="add54cb3cb262adaa24e8e0a064db915c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_SIL</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:add54cb3cb262adaa24e8e0a064db915c"><td class="mdescLeft">&#160;</td><td class="mdescRight">silent, no messages <br /></td></tr>
<tr class="separator:add54cb3cb262adaa24e8e0a064db915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57609d69c3433c3a5e4a7cfcf33ceaeb"><td class="memItemLeft" align="right" valign="top"><a id="a57609d69c3433c3a5e4a7cfcf33ceaeb" name="a57609d69c3433c3a5e4a7cfcf33ceaeb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_NDC</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a57609d69c3433c3a5e4a7cfcf33ceaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't decorate names <br /></td></tr>
<tr class="separator:a57609d69c3433c3a5e4a7cfcf33ceaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275f154b9415ddab5d773d3f2ce48a30"><td class="memItemLeft" align="right" valign="top"><a id="a275f154b9415ddab5d773d3f2ce48a30" name="a275f154b9415ddab5d773d3f2ce48a30"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_TYP</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a275f154b9415ddab5d773d3f2ce48a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">return declared type information <br /></td></tr>
<tr class="separator:a275f154b9415ddab5d773d3f2ce48a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2372a33ffe07dcfaae46a1873a453e8f"><td class="memItemLeft" align="right" valign="top"><a id="a2372a33ffe07dcfaae46a1873a453e8f" name="a2372a33ffe07dcfaae46a1873a453e8f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_VAR</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a2372a33ffe07dcfaae46a1873a453e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return declared object information <br /></td></tr>
<tr class="separator:a2372a33ffe07dcfaae46a1873a453e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218f8fa41b94eb9d4065d2a6e70ca991"><td class="memItemLeft" align="right" valign="top"><a id="a218f8fa41b94eb9d4065d2a6e70ca991" name="a218f8fa41b94eb9d4065d2a6e70ca991"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_PACKMASK</b>&#160;&#160;&#160;0x0070</td></tr>
<tr class="memdesc:a218f8fa41b94eb9d4065d2a6e70ca991"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask for pack alignment values <br /></td></tr>
<tr class="separator:a218f8fa41b94eb9d4065d2a6e70ca991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6284f488e8820aee39aa19cfab3c583"><td class="memItemLeft" align="right" valign="top"><a id="ac6284f488e8820aee39aa19cfab3c583" name="ac6284f488e8820aee39aa19cfab3c583"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_HIGH</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:ac6284f488e8820aee39aa19cfab3c583"><td class="mdescLeft">&#160;</td><td class="mdescRight">assume high level prototypes (with hidden args, etc) <br /></td></tr>
<tr class="separator:ac6284f488e8820aee39aa19cfab3c583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8c7cbf15346f19cfab0634f38668b3"><td class="memItemLeft" align="right" valign="top"><a id="a8d8c7cbf15346f19cfab0634f38668b3" name="a8d8c7cbf15346f19cfab0634f38668b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LOWER</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a8d8c7cbf15346f19cfab0634f38668b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower the function prototypes <br /></td></tr>
<tr class="separator:a8d8c7cbf15346f19cfab0634f38668b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04abaa7e18028fd14722db3ca00f900"><td class="memItemLeft" align="right" valign="top"><a id="ab04abaa7e18028fd14722db3ca00f900" name="ab04abaa7e18028fd14722db3ca00f900"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_REPLACE</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:ab04abaa7e18028fd14722db3ca00f900"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace the old type (used in idc) <br /></td></tr>
<tr class="separator:ab04abaa7e18028fd14722db3ca00f900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596fed0e18a485e36cc46e6f3d4961ba"><td class="memItemLeft" align="right" valign="top"><a id="a596fed0e18a485e36cc46e6f3d4961ba" name="a596fed0e18a485e36cc46e6f3d4961ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_RAWARGS</b>&#160;&#160;&#160;0x0400</td></tr>
<tr class="memdesc:a596fed0e18a485e36cc46e6f3d4961ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">leave argument names unchanged (do not remove underscores) <br /></td></tr>
<tr class="separator:a596fed0e18a485e36cc46e6f3d4961ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3719af59224847206f30d143bc0decb"><td class="memItemLeft" align="right" valign="top"><a id="ab3719af59224847206f30d143bc0decb" name="ab3719af59224847206f30d143bc0decb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_1LINE</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:ab3719af59224847206f30d143bc0decb"><td class="mdescLeft">&#160;</td><td class="mdescRight">print to one line <br /></td></tr>
<tr class="separator:ab3719af59224847206f30d143bc0decb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab647e3d3753c1c87cf1143ca1202f1a3"><td class="memItemLeft" align="right" valign="top"><a id="ab647e3d3753c1c87cf1143ca1202f1a3" name="ab647e3d3753c1c87cf1143ca1202f1a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_MULTI</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:ab647e3d3753c1c87cf1143ca1202f1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">print to many lines <br /></td></tr>
<tr class="separator:ab647e3d3753c1c87cf1143ca1202f1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f70431b8da99f5cae4aa98fd93e6be"><td class="memItemLeft" align="right" valign="top"><a id="a56f70431b8da99f5cae4aa98fd93e6be" name="a56f70431b8da99f5cae4aa98fd93e6be"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_TYPE</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a56f70431b8da99f5cae4aa98fd93e6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">print type declaration (not variable declaration) <br /></td></tr>
<tr class="separator:a56f70431b8da99f5cae4aa98fd93e6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564107f5a98219d717438e18213095e"><td class="memItemLeft" align="right" valign="top"><a id="ae564107f5a98219d717438e18213095e" name="ae564107f5a98219d717438e18213095e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_PRAGMA</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:ae564107f5a98219d717438e18213095e"><td class="mdescLeft">&#160;</td><td class="mdescRight">print pragmas for alignment <br /></td></tr>
<tr class="separator:ae564107f5a98219d717438e18213095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ba5f1ae2f27c58cc3024729c17bba4"><td class="memItemLeft" align="right" valign="top"><a id="ac6ba5f1ae2f27c58cc3024729c17bba4" name="ac6ba5f1ae2f27c58cc3024729c17bba4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_SEMI</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:ac6ba5f1ae2f27c58cc3024729c17bba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">append ; to the end <br /></td></tr>
<tr class="separator:ac6ba5f1ae2f27c58cc3024729c17bba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379c0608ff4f6420333d7ef966acdf44"><td class="memItemLeft" align="right" valign="top"><a id="a379c0608ff4f6420333d7ef966acdf44" name="a379c0608ff4f6420333d7ef966acdf44"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_CPP</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a379c0608ff4f6420333d7ef966acdf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">use c++ name (only for <a class="el" href="typeinf_8hpp.html#a43ef73f0df2c860b554c5fef7ce273f3" title="Get type declaration for the specified address.">print_type()</a>) <br /></td></tr>
<tr class="separator:a379c0608ff4f6420333d7ef966acdf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a717c29896809ca1da80bf94d50992"><td class="memItemLeft" align="right" valign="top"><a id="ad6a717c29896809ca1da80bf94d50992" name="ad6a717c29896809ca1da80bf94d50992"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_DEF</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:ad6a717c29896809ca1da80bf94d50992"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>: print definition, if available <br /></td></tr>
<tr class="separator:ad6a717c29896809ca1da80bf94d50992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbe8109e29629334e9ebfa118398491"><td class="memItemLeft" align="right" valign="top"><a id="aacbe8109e29629334e9ebfa118398491" name="aacbe8109e29629334e9ebfa118398491"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_NOARGS</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:aacbe8109e29629334e9ebfa118398491"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>: do not print function argument names <br /></td></tr>
<tr class="separator:aacbe8109e29629334e9ebfa118398491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0abdd33ca089e3b78da3aa1c1fe168"><td class="memItemLeft" align="right" valign="top"><a id="adb0abdd33ca089e3b78da3aa1c1fe168" name="adb0abdd33ca089e3b78da3aa1c1fe168"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_NOARRS</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:adb0abdd33ca089e3b78da3aa1c1fe168"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>: print arguments with <a class="el" href="typeinf_8hpp.html#a7cd5b032edc5675d9853779744009f72" title="was initially an array; see &quot;__org_typedef&quot; or &quot;__org_arrdim&quot; type attributes to determine the origin...">FAI_ARRAY</a> as pointers <br /></td></tr>
<tr class="separator:adb0abdd33ca089e3b78da3aa1c1fe168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf11cbf1abb08f4f30a2626c23d1b67"><td class="memItemLeft" align="right" valign="top"><a id="a8bf11cbf1abb08f4f30a2626c23d1b67" name="a8bf11cbf1abb08f4f30a2626c23d1b67"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_NORES</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a8bf11cbf1abb08f4f30a2626c23d1b67"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>: never resolve types (meaningful with PRTYPE_DEF) <br /></td></tr>
<tr class="separator:a8bf11cbf1abb08f4f30a2626c23d1b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6026ba171330f529e96e996ca1b022d"><td class="memItemLeft" align="right" valign="top"><a id="ae6026ba171330f529e96e996ca1b022d" name="ae6026ba171330f529e96e996ca1b022d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_RESTORE</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:ae6026ba171330f529e96e996ca1b022d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>: print restored types for <a class="el" href="typeinf_8hpp.html#a7cd5b032edc5675d9853779744009f72" title="was initially an array; see &quot;__org_typedef&quot; or &quot;__org_arrdim&quot; type attributes to determine the origin...">FAI_ARRAY</a> and <a class="el" href="typeinf_8hpp.html#a81b8d1889e7b8f7f54fc4240ac181752" title="was initially a structure">FAI_STRUCT</a> <br /></td></tr>
<tr class="separator:ae6026ba171330f529e96e996ca1b022d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af768c40a3dbd8866f61d8b7cd6532d83"><td class="memItemLeft" align="right" valign="top"><a id="af768c40a3dbd8866f61d8b7cd6532d83" name="af768c40a3dbd8866f61d8b7cd6532d83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_NOREGEX</b>&#160;&#160;&#160;0x0400</td></tr>
<tr class="memdesc:af768c40a3dbd8866f61d8b7cd6532d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not apply regular expressions to beautify name <br /></td></tr>
<tr class="separator:af768c40a3dbd8866f61d8b7cd6532d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9632a79f69e281bc93f3d610be266e2"><td class="memItemLeft" align="right" valign="top"><a id="ad9632a79f69e281bc93f3d610be266e2" name="ad9632a79f69e281bc93f3d610be266e2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_COLORED</b>&#160;&#160;&#160;0x0800</td></tr>
<tr class="memdesc:ad9632a79f69e281bc93f3d610be266e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">add color tag COLOR_SYMBOL for any parentheses, commas and colons <br /></td></tr>
<tr class="separator:ad9632a79f69e281bc93f3d610be266e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293ab06f4adfc2d2708dd9f4d562c1c8"><td class="memItemLeft" align="right" valign="top"><a id="a293ab06f4adfc2d2708dd9f4d562c1c8" name="a293ab06f4adfc2d2708dd9f4d562c1c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_METHODS</b>&#160;&#160;&#160;0x1000</td></tr>
<tr class="memdesc:a293ab06f4adfc2d2708dd9f4d562c1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>: print udt methods <br /></td></tr>
<tr class="separator:a293ab06f4adfc2d2708dd9f4d562c1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f760cdd0efee72dfb9001d2c03befbe"><td class="memItemLeft" align="right" valign="top"><a id="a4f760cdd0efee72dfb9001d2c03befbe" name="a4f760cdd0efee72dfb9001d2c03befbe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PRTYPE_1LINCMT</b>&#160;&#160;&#160;0x2000</td></tr>
<tr class="memdesc:a4f760cdd0efee72dfb9001d2c03befbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">print comments in one line mode <br /></td></tr>
<tr class="separator:a4f760cdd0efee72dfb9001d2c03befbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4844995290490378ae0dd75d3acf1e9c"><td class="memItemLeft" align="right" valign="top"><a id="a4844995290490378ae0dd75d3acf1e9c" name="a4844995290490378ae0dd75d3acf1e9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_TYPE</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a4844995290490378ae0dd75d3acf1e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type name <br /></td></tr>
<tr class="separator:a4844995290490378ae0dd75d3acf1e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcee89fdd77d983c812bc8d42053cf2a"><td class="memItemLeft" align="right" valign="top"><a id="afcee89fdd77d983c812bc8d42053cf2a" name="afcee89fdd77d983c812bc8d42053cf2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_SYMU</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:afcee89fdd77d983c812bc8d42053cf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">symbol, name is unmangled ('func') <br /></td></tr>
<tr class="separator:afcee89fdd77d983c812bc8d42053cf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3cda8cc0f916fe6af7c2227c096ca6"><td class="memItemLeft" align="right" valign="top"><a id="acd3cda8cc0f916fe6af7c2227c096ca6" name="acd3cda8cc0f916fe6af7c2227c096ca6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_SYMM</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:acd3cda8cc0f916fe6af7c2227c096ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">symbol, name is mangled ('_func'); only one of <a class="el" href="typeinf_8hpp.html#a4844995290490378ae0dd75d3acf1e9c" title="type name">NTF_TYPE</a> and <a class="el" href="typeinf_8hpp.html#afcee89fdd77d983c812bc8d42053cf2a" title="symbol, name is unmangled (&#39;func&#39;)">NTF_SYMU</a>, <a class="el" href="typeinf_8hpp.html#acd3cda8cc0f916fe6af7c2227c096ca6" title="symbol, name is mangled (&#39;_func&#39;); only one of NTF_TYPE and NTF_SYMU, NTF_SYMM can be used">NTF_SYMM</a> can be used <br /></td></tr>
<tr class="separator:acd3cda8cc0f916fe6af7c2227c096ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f1cf2eee24fa287b41be608cd5c82e"><td class="memItemLeft" align="right" valign="top"><a id="a59f1cf2eee24fa287b41be608cd5c82e" name="a59f1cf2eee24fa287b41be608cd5c82e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_NOBASE</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a59f1cf2eee24fa287b41be608cd5c82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't inspect base tils (for get_named_type) <br /></td></tr>
<tr class="separator:a59f1cf2eee24fa287b41be608cd5c82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d425180386ad9f256f191e88ff1ffe"><td class="memItemLeft" align="right" valign="top"><a id="a99d425180386ad9f256f191e88ff1ffe" name="a99d425180386ad9f256f191e88ff1ffe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_REPLACE</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a99d425180386ad9f256f191e88ff1ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace original type (for set_named_type) <br /></td></tr>
<tr class="separator:a99d425180386ad9f256f191e88ff1ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45f8c82851006366914ec555fe963f8"><td class="memItemLeft" align="right" valign="top"><a id="af45f8c82851006366914ec555fe963f8" name="af45f8c82851006366914ec555fe963f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_UMANGLED</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:af45f8c82851006366914ec555fe963f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is unmangled (don't use this flag) <br /></td></tr>
<tr class="separator:af45f8c82851006366914ec555fe963f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73410ff512a73114b2c564717dcfa58a"><td class="memItemLeft" align="right" valign="top"><a id="a73410ff512a73114b2c564717dcfa58a" name="a73410ff512a73114b2c564717dcfa58a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_NOCUR</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a73410ff512a73114b2c564717dcfa58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't inspect current til file (for get_named_type) <br /></td></tr>
<tr class="separator:a73410ff512a73114b2c564717dcfa58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c63d1c35028b20e395e0a5bc814404"><td class="memItemLeft" align="right" valign="top"><a id="ac6c63d1c35028b20e395e0a5bc814404" name="ac6c63d1c35028b20e395e0a5bc814404"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_64BIT</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:ac6c63d1c35028b20e395e0a5bc814404"><td class="mdescLeft">&#160;</td><td class="mdescRight">value is 64bit <br /></td></tr>
<tr class="separator:ac6c63d1c35028b20e395e0a5bc814404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298db04cef52eff57f0c2d719eb023aa"><td class="memItemLeft" align="right" valign="top"><a id="a298db04cef52eff57f0c2d719eb023aa" name="a298db04cef52eff57f0c2d719eb023aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_FIXNAME</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:a298db04cef52eff57f0c2d719eb023aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">force-validate the name of the type when setting (set_named_type, set_numbered_type only) <br /></td></tr>
<tr class="separator:a298db04cef52eff57f0c2d719eb023aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebc3745a16bce97c72110fa02f73abd"><td class="memItemLeft" align="right" valign="top"><a id="a7ebc3745a16bce97c72110fa02f73abd" name="a7ebc3745a16bce97c72110fa02f73abd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_IDBENC</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a7ebc3745a16bce97c72110fa02f73abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly (set_named_type, set_numbered_type only) <br /></td></tr>
<tr class="separator:a7ebc3745a16bce97c72110fa02f73abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e3d4dd73519597bbf1ae60c7fad21c"><td class="memItemLeft" align="right" valign="top"><a id="a30e3d4dd73519597bbf1ae60c7fad21c" name="a30e3d4dd73519597bbf1ae60c7fad21c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NTF_CHKSYNC</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:a30e3d4dd73519597bbf1ae60c7fad21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">check that synchronization to IDB passed OK (set_numbered_type, set_named_type) <br /></td></tr>
<tr class="separator:a30e3d4dd73519597bbf1ae60c7fad21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e351d20547e76f7da3ef1dfc8b5e58"><td class="memItemLeft" align="right" valign="top"><a id="a72e351d20547e76f7da3ef1dfc8b5e58" name="a72e351d20547e76f7da3ef1dfc8b5e58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CCN_C</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:a72e351d20547e76f7da3ef1dfc8b5e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b06d552bacb452c8ca005a4914dc5"><td class="memItemLeft" align="right" valign="top"><a id="ace8b06d552bacb452c8ca005a4914dc5" name="ace8b06d552bacb452c8ca005a4914dc5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CCN_CPP</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ace8b06d552bacb452c8ca005a4914dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd91fbe162e41d37b8f02af78cc2c58"><td class="memItemLeft" align="right" valign="top"><a id="a6cd91fbe162e41d37b8f02af78cc2c58" name="a6cd91fbe162e41d37b8f02af78cc2c58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IMPTYPE_VERBOSE</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a6cd91fbe162e41d37b8f02af78cc2c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">more verbose output (dialog boxes may appear) <br /></td></tr>
<tr class="separator:a6cd91fbe162e41d37b8f02af78cc2c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299edee3b2cde79401bfb9fb118c2fab"><td class="memItemLeft" align="right" valign="top"><a id="a299edee3b2cde79401bfb9fb118c2fab" name="a299edee3b2cde79401bfb9fb118c2fab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>IMPTYPE_OVERRIDE</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a299edee3b2cde79401bfb9fb118c2fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">override existing type <br /></td></tr>
<tr class="separator:a299edee3b2cde79401bfb9fb118c2fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced117327d7b21c347311a28a8676fe2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aced117327d7b21c347311a28a8676fe2">IMPTYPE_LOCAL</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:aced117327d7b21c347311a28a8676fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type is local, the struct/enum won't be marked as til type.  <a href="typeinf_8hpp.html#aced117327d7b21c347311a28a8676fe2">More...</a><br /></td></tr>
<tr class="separator:aced117327d7b21c347311a28a8676fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bdef9bff72c4d21c3499d5a5c98af4"><td class="memItemLeft" align="right" valign="top"><a id="ab0bdef9bff72c4d21c3499d5a5c98af4" name="ab0bdef9bff72c4d21c3499d5a5c98af4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDTIL_DEFAULT</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:ab0bdef9bff72c4d21c3499d5a5c98af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">default behavior <br /></td></tr>
<tr class="separator:ab0bdef9bff72c4d21c3499d5a5c98af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92892b6a857c38374ab2516f275f02fd"><td class="memItemLeft" align="right" valign="top"><a id="a92892b6a857c38374ab2516f275f02fd" name="a92892b6a857c38374ab2516f275f02fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDTIL_INCOMP</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a92892b6a857c38374ab2516f275f02fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">load incompatible tils <br /></td></tr>
<tr class="separator:a92892b6a857c38374ab2516f275f02fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150b63463349508a1eb9b89fee0f8405"><td class="memItemLeft" align="right" valign="top"><a id="a150b63463349508a1eb9b89fee0f8405" name="a150b63463349508a1eb9b89fee0f8405"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDTIL_SILENT</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a150b63463349508a1eb9b89fee0f8405"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not ask any questions <br /></td></tr>
<tr class="separator:a150b63463349508a1eb9b89fee0f8405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a998ce8353062744feb51868a406ea1"><td class="memItemLeft" align="right" valign="top"><a id="a2a998ce8353062744feb51868a406ea1" name="a2a998ce8353062744feb51868a406ea1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDTIL_FAILED</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a2a998ce8353062744feb51868a406ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">something bad, the warning is displayed <br /></td></tr>
<tr class="separator:a2a998ce8353062744feb51868a406ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86de707a0a8d30d9fbe3b234782b98f"><td class="memItemLeft" align="right" valign="top"><a id="af86de707a0a8d30d9fbe3b234782b98f" name="af86de707a0a8d30d9fbe3b234782b98f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDTIL_OK</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:af86de707a0a8d30d9fbe3b234782b98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ok, til is loaded <br /></td></tr>
<tr class="separator:af86de707a0a8d30d9fbe3b234782b98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45e1faf7bbc42c19c79ab78cc21ae94"><td class="memItemLeft" align="right" valign="top"><a id="aa45e1faf7bbc42c19c79ab78cc21ae94" name="aa45e1faf7bbc42c19c79ab78cc21ae94"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDTIL_COMP</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:aa45e1faf7bbc42c19c79ab78cc21ae94"><td class="mdescLeft">&#160;</td><td class="mdescRight">ok, but til is not compatible with the current compiler <br /></td></tr>
<tr class="separator:aa45e1faf7bbc42c19c79ab78cc21ae94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48acce0ca293fa55b3e91f8b5b3441b0"><td class="memItemLeft" align="right" valign="top"><a id="a48acce0ca293fa55b3e91f8b5b3441b0" name="a48acce0ca293fa55b3e91f8b5b3441b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDTIL_ABORTED</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a48acce0ca293fa55b3e91f8b5b3441b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">til was not loaded (incompatible til rejected by user) <br /></td></tr>
<tr class="separator:a48acce0ca293fa55b3e91f8b5b3441b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd0c6ab9a8d3e5c8efc95b5d3783265"><td class="memItemLeft" align="right" valign="top"><a id="a5cd0c6ab9a8d3e5c8efc95b5d3783265" name="a5cd0c6ab9a8d3e5c8efc95b5d3783265"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TINFO_GUESSED</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:a5cd0c6ab9a8d3e5c8efc95b5d3783265"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is a guessed type <br /></td></tr>
<tr class="separator:a5cd0c6ab9a8d3e5c8efc95b5d3783265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a831ce211c89ef0c30c59d7e893ba5a"><td class="memItemLeft" align="right" valign="top"><a id="a2a831ce211c89ef0c30c59d7e893ba5a" name="a2a831ce211c89ef0c30c59d7e893ba5a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TINFO_DEFINITE</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a2a831ce211c89ef0c30c59d7e893ba5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is a definite type <br /></td></tr>
<tr class="separator:a2a831ce211c89ef0c30c59d7e893ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c75f13fbbb9bfab7a32f08d2f24c064"><td class="memItemLeft" align="right" valign="top"><a id="a9c75f13fbbb9bfab7a32f08d2f24c064" name="a9c75f13fbbb9bfab7a32f08d2f24c064"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TINFO_DELAYFUNC</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a9c75f13fbbb9bfab7a32f08d2f24c064"><td class="mdescLeft">&#160;</td><td class="mdescRight">if type is a function and no function exists at ea, schedule its creation and argument renaming to auto-analysis, otherwise try to create it immediately <br /></td></tr>
<tr class="separator:a9c75f13fbbb9bfab7a32f08d2f24c064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083af7d8f46a0cae66ada17dbc613ed1"><td class="memItemLeft" align="right" valign="top"><a id="a083af7d8f46a0cae66ada17dbc613ed1" name="a083af7d8f46a0cae66ada17dbc613ed1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TINFO_STRICT</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a083af7d8f46a0cae66ada17dbc613ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">never convert given type to another one before applying <br /></td></tr>
<tr class="separator:a083af7d8f46a0cae66ada17dbc613ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77927ed8d33d6a42525ac865cb93ef0"><td class="memItemLeft" align="right" valign="top"><a id="aa77927ed8d33d6a42525ac865cb93ef0" name="aa77927ed8d33d6a42525ac865cb93ef0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GUESS_FUNC_FAILED</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa77927ed8d33d6a42525ac865cb93ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">couldn't guess the function type <br /></td></tr>
<tr class="separator:aa77927ed8d33d6a42525ac865cb93ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adfb6d3e179afe44a502cee3ee03ae9"><td class="memItemLeft" align="right" valign="top"><a id="a0adfb6d3e179afe44a502cee3ee03ae9" name="a0adfb6d3e179afe44a502cee3ee03ae9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GUESS_FUNC_TRIVIAL</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a0adfb6d3e179afe44a502cee3ee03ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the function type doesn't have interesting info <br /></td></tr>
<tr class="separator:a0adfb6d3e179afe44a502cee3ee03ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa689955199b1c9e70e092cba214682fe"><td class="memItemLeft" align="right" valign="top"><a id="aa689955199b1c9e70e092cba214682fe" name="aa689955199b1c9e70e092cba214682fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GUESS_FUNC_OK</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:aa689955199b1c9e70e092cba214682fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">ok, some non-trivial information is gathered <br /></td></tr>
<tr class="separator:aa689955199b1c9e70e092cba214682fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7becf33db69eeae6168435acb39b0010"><td class="memItemLeft" align="right" valign="top"><a id="a7becf33db69eeae6168435acb39b0010" name="a7becf33db69eeae6168435acb39b0010"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUDT_SORT</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a7becf33db69eeae6168435acb39b0010"><td class="mdescLeft">&#160;</td><td class="mdescRight">fields are not sorted by offset, sort them first <br /></td></tr>
<tr class="separator:a7becf33db69eeae6168435acb39b0010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab935733a0cdd7a9dd608f372c0164381"><td class="memItemLeft" align="right" valign="top"><a id="ab935733a0cdd7a9dd608f372c0164381" name="ab935733a0cdd7a9dd608f372c0164381"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUDT_ALIGN</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:ab935733a0cdd7a9dd608f372c0164381"><td class="mdescLeft">&#160;</td><td class="mdescRight">recalculate field alignments, struct packing, etc to match the offsets and size info <br /></td></tr>
<tr class="separator:ab935733a0cdd7a9dd608f372c0164381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25d2bd3d8185187ceae4cc16f4cc3dc"><td class="memItemLeft" align="right" valign="top"><a id="ac25d2bd3d8185187ceae4cc16f4cc3dc" name="ac25d2bd3d8185187ceae4cc16f4cc3dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUDT_GAPS</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:ac25d2bd3d8185187ceae4cc16f4cc3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">allow to fill gaps with additional members (_BYTE[]) <br /></td></tr>
<tr class="separator:ac25d2bd3d8185187ceae4cc16f4cc3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d5efeca5c98ebbe16208d506df4231"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aa2d5efeca5c98ebbe16208d506df4231">SUDT_UNEX</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:aa2d5efeca5c98ebbe16208d506df4231"><td class="mdescLeft">&#160;</td><td class="mdescRight">references to nonexistent member types are acceptable; in this case it is better to set the corresponding <a class="el" href="structudt__member__t.html#aa2531c429ae5d76784c359fd1ef07105" title="field alignment (shift amount)">udt_member_t::fda</a> field to the type alignment.  <a href="typeinf_8hpp.html#aa2d5efeca5c98ebbe16208d506df4231">More...</a><br /></td></tr>
<tr class="separator:aa2d5efeca5c98ebbe16208d506df4231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa511ce041efaeb0ce9659fcb35b7a7"><td class="memItemLeft" align="right" valign="top"><a id="aeaa511ce041efaeb0ce9659fcb35b7a7" name="aeaa511ce041efaeb0ce9659fcb35b7a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUDT_FAST</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:aeaa511ce041efaeb0ce9659fcb35b7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize without verifying offsets and alignments <br /></td></tr>
<tr class="separator:aeaa511ce041efaeb0ce9659fcb35b7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a49c1f8d93c62e3a8c3ba35f10be585"><td class="memItemLeft" align="right" valign="top"><a id="a9a49c1f8d93c62e3a8c3ba35f10be585" name="a9a49c1f8d93c62e3a8c3ba35f10be585"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUDT_CONST</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a9a49c1f8d93c62e3a8c3ba35f10be585"><td class="mdescLeft">&#160;</td><td class="mdescRight">only for serialize_udt: make type const <br /></td></tr>
<tr class="separator:a9a49c1f8d93c62e3a8c3ba35f10be585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc68f14b473c222381efd52ca7cb90d4"><td class="memItemLeft" align="right" valign="top"><a id="adc68f14b473c222381efd52ca7cb90d4" name="adc68f14b473c222381efd52ca7cb90d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUDT_VOLATILE</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:adc68f14b473c222381efd52ca7cb90d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">only for serialize_udt: make type volatile <br /></td></tr>
<tr class="separator:adc68f14b473c222381efd52ca7cb90d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e082c951f7e37bafdf409d66aa785a2"><td class="memItemLeft" align="right" valign="top"><a id="a1e082c951f7e37bafdf409d66aa785a2" name="a1e082c951f7e37bafdf409d66aa785a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SUDT_TRUNC</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a1e082c951f7e37bafdf409d66aa785a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize: truncate useless strings from fields, fldcmts <br /></td></tr>
<tr class="separator:a1e082c951f7e37bafdf409d66aa785a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653346f8c2f0accc90038d22c91abd09"><td class="memItemLeft" align="right" valign="top"><a id="a653346f8c2f0accc90038d22c91abd09" name="a653346f8c2f0accc90038d22c91abd09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DECLARE_TINFO_HELPERS</b>(decl)</td></tr>
<tr class="memdesc:a653346f8c2f0accc90038d22c91abd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to declare common <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a> related functions. <br /></td></tr>
<tr class="separator:a653346f8c2f0accc90038d22c91abd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af528bfd6d968b17ae57aee1dee443c29"><td class="memItemLeft" align="right" valign="top"><a id="af528bfd6d968b17ae57aee1dee443c29" name="af528bfd6d968b17ae57aee1dee443c29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRMEM_MASK</b>&#160;&#160;&#160;0x0007</td></tr>
<tr class="separator:af528bfd6d968b17ae57aee1dee443c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7e55c621c65b2a81792e39a67d75b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#afc7e55c621c65b2a81792e39a67d75b2">STRMEM_OFFSET</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:afc7e55c621c65b2a81792e39a67d75b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get member by offset  <a href="typeinf_8hpp.html#afc7e55c621c65b2a81792e39a67d75b2">More...</a><br /></td></tr>
<tr class="separator:afc7e55c621c65b2a81792e39a67d75b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad91f2151cfd8e41e7f937287bf18f56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aad91f2151cfd8e41e7f937287bf18f56">STRMEM_INDEX</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:aad91f2151cfd8e41e7f937287bf18f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">get member by number  <a href="typeinf_8hpp.html#aad91f2151cfd8e41e7f937287bf18f56">More...</a><br /></td></tr>
<tr class="separator:aad91f2151cfd8e41e7f937287bf18f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5ba39c4308bbc445aaa8bfc5315bfd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a0b5ba39c4308bbc445aaa8bfc5315bfd">STRMEM_AUTO</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a0b5ba39c4308bbc445aaa8bfc5315bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get member by offset if struct, or get member by index if union  <a href="typeinf_8hpp.html#a0b5ba39c4308bbc445aaa8bfc5315bfd">More...</a><br /></td></tr>
<tr class="separator:a0b5ba39c4308bbc445aaa8bfc5315bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c04aa29f158d3544957d5bf9513115a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a8c04aa29f158d3544957d5bf9513115a">STRMEM_NAME</a>&#160;&#160;&#160;0x0003</td></tr>
<tr class="memdesc:a8c04aa29f158d3544957d5bf9513115a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get member by name  <a href="typeinf_8hpp.html#a8c04aa29f158d3544957d5bf9513115a">More...</a><br /></td></tr>
<tr class="separator:a8c04aa29f158d3544957d5bf9513115a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e2d52ab4b1acb0ed5571b7135ee6dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a62e2d52ab4b1acb0ed5571b7135ee6dd">STRMEM_TYPE</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a62e2d52ab4b1acb0ed5571b7135ee6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get member by type.  <a href="typeinf_8hpp.html#a62e2d52ab4b1acb0ed5571b7135ee6dd">More...</a><br /></td></tr>
<tr class="separator:a62e2d52ab4b1acb0ed5571b7135ee6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3a31e8de28a5b68b31fd42d8465048"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a0e3a31e8de28a5b68b31fd42d8465048">STRMEM_SIZE</a>&#160;&#160;&#160;0x0005</td></tr>
<tr class="memdesc:a0e3a31e8de28a5b68b31fd42d8465048"><td class="mdescLeft">&#160;</td><td class="mdescRight">get member by size.  <a href="typeinf_8hpp.html#a0e3a31e8de28a5b68b31fd42d8465048">More...</a><br /></td></tr>
<tr class="separator:a0e3a31e8de28a5b68b31fd42d8465048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfb7742720049da887ac63077488b74"><td class="memItemLeft" align="right" valign="top"><a id="aecfb7742720049da887ac63077488b74" name="aecfb7742720049da887ac63077488b74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRMEM_MINS</b>&#160;&#160;&#160;0x0006</td></tr>
<tr class="memdesc:aecfb7742720049da887ac63077488b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">get smallest member by size. <br /></td></tr>
<tr class="separator:aecfb7742720049da887ac63077488b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e977634794b06f003f4827d9df5028"><td class="memItemLeft" align="right" valign="top"><a id="a85e977634794b06f003f4827d9df5028" name="a85e977634794b06f003f4827d9df5028"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRMEM_MAXS</b>&#160;&#160;&#160;0x0007</td></tr>
<tr class="memdesc:a85e977634794b06f003f4827d9df5028"><td class="mdescLeft">&#160;</td><td class="mdescRight">get biggest member by size. <br /></td></tr>
<tr class="separator:a85e977634794b06f003f4827d9df5028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a1dad69d95268c390c2d859b0334b3"><td class="memItemLeft" align="right" valign="top"><a id="aa3a1dad69d95268c390c2d859b0334b3" name="aa3a1dad69d95268c390c2d859b0334b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRMEM_VFTABLE</b>&#160;&#160;&#160;0x10000000</td></tr>
<tr class="memdesc:aa3a1dad69d95268c390c2d859b0334b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">can be combined with <a class="el" href="typeinf_8hpp.html#afc7e55c621c65b2a81792e39a67d75b2" title="get member by offset">STRMEM_OFFSET</a>, <a class="el" href="typeinf_8hpp.html#a0b5ba39c4308bbc445aaa8bfc5315bfd" title="get member by offset if struct, or get member by index if union">STRMEM_AUTO</a> get vftable instead of the base class <br /></td></tr>
<tr class="separator:aa3a1dad69d95268c390c2d859b0334b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ab6d5aeb400abaec8c64d4849d049d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#af9ab6d5aeb400abaec8c64d4849d049d">STRMEM_SKIP_EMPTY</a>&#160;&#160;&#160;0x20000000</td></tr>
<tr class="memdesc:af9ab6d5aeb400abaec8c64d4849d049d"><td class="mdescLeft">&#160;</td><td class="mdescRight">can be combined with <a class="el" href="typeinf_8hpp.html#afc7e55c621c65b2a81792e39a67d75b2" title="get member by offset">STRMEM_OFFSET</a>, <a class="el" href="typeinf_8hpp.html#a0b5ba39c4308bbc445aaa8bfc5315bfd" title="get member by offset if struct, or get member by index if union">STRMEM_AUTO</a> skip empty members (i.e.  <a href="typeinf_8hpp.html#af9ab6d5aeb400abaec8c64d4849d049d">More...</a><br /></td></tr>
<tr class="separator:af9ab6d5aeb400abaec8c64d4849d049d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454bfbfea961d64f7efdea9fa565a18a"><td class="memItemLeft" align="right" valign="top"><a id="a454bfbfea961d64f7efdea9fa565a18a" name="a454bfbfea961d64f7efdea9fa565a18a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STRMEM_CASTABLE_TO</b>&#160;&#160;&#160;0x40000000</td></tr>
<tr class="memdesc:a454bfbfea961d64f7efdea9fa565a18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">can be combined with <a class="el" href="typeinf_8hpp.html#a62e2d52ab4b1acb0ed5571b7135ee6dd" title="get member by type.">STRMEM_TYPE</a>: member type must be castable to the specified type <br /></td></tr>
<tr class="separator:a454bfbfea961d64f7efdea9fa565a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70e5a781439aef62e61cdfe061f7170"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ae70e5a781439aef62e61cdfe061f7170">STRMEM_ANON</a>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:ae70e5a781439aef62e61cdfe061f7170"><td class="mdescLeft">&#160;</td><td class="mdescRight">can be combined with <a class="el" href="typeinf_8hpp.html#a8c04aa29f158d3544957d5bf9513115a" title="get member by name">STRMEM_NAME</a>: look inside anonymous members too.  <a href="typeinf_8hpp.html#ae70e5a781439aef62e61cdfe061f7170">More...</a><br /></td></tr>
<tr class="separator:ae70e5a781439aef62e61cdfe061f7170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91038fc97378aa2a884552f82d0e05ce"><td class="memItemLeft" align="right" valign="top"><a id="a91038fc97378aa2a884552f82d0e05ce" name="a91038fc97378aa2a884552f82d0e05ce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FAI_HIDDEN</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a91038fc97378aa2a884552f82d0e05ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">hidden argument <br /></td></tr>
<tr class="separator:a91038fc97378aa2a884552f82d0e05ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f89490f56d1255bf75cdd57b512966f"><td class="memItemLeft" align="right" valign="top"><a id="a9f89490f56d1255bf75cdd57b512966f" name="a9f89490f56d1255bf75cdd57b512966f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FAI_RETPTR</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a9f89490f56d1255bf75cdd57b512966f"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to return value. implies hidden <br /></td></tr>
<tr class="separator:a9f89490f56d1255bf75cdd57b512966f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b8d1889e7b8f7f54fc4240ac181752"><td class="memItemLeft" align="right" valign="top"><a id="a81b8d1889e7b8f7f54fc4240ac181752" name="a81b8d1889e7b8f7f54fc4240ac181752"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FAI_STRUCT</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a81b8d1889e7b8f7f54fc4240ac181752"><td class="mdescLeft">&#160;</td><td class="mdescRight">was initially a structure <br /></td></tr>
<tr class="separator:a81b8d1889e7b8f7f54fc4240ac181752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd5b032edc5675d9853779744009f72"><td class="memItemLeft" align="right" valign="top"><a id="a7cd5b032edc5675d9853779744009f72" name="a7cd5b032edc5675d9853779744009f72"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FAI_ARRAY</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a7cd5b032edc5675d9853779744009f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">was initially an array; see "__org_typedef" or "__org_arrdim" type attributes to determine the original type <br /></td></tr>
<tr class="separator:a7cd5b032edc5675d9853779744009f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4ff2e1307f216add7e526fb9f4f14e"><td class="memItemLeft" align="right" valign="top"><a id="a7a4ff2e1307f216add7e526fb9f4f14e" name="a7a4ff2e1307f216add7e526fb9f4f14e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FAI_UNUSED</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a7a4ff2e1307f216add7e526fb9f4f14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">argument is not used by the function <br /></td></tr>
<tr class="separator:a7a4ff2e1307f216add7e526fb9f4f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecee61a83c985dbc2af27e5b1c323093"><td class="memItemLeft" align="right" valign="top"><a id="aecee61a83c985dbc2af27e5b1c323093" name="aecee61a83c985dbc2af27e5b1c323093"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TA_ORG_TYPEDEF</b>&#160;&#160;&#160;&quot;__org_typedef&quot;</td></tr>
<tr class="memdesc:aecee61a83c985dbc2af27e5b1c323093"><td class="mdescLeft">&#160;</td><td class="mdescRight">the original typedef name (simple string) <br /></td></tr>
<tr class="separator:aecee61a83c985dbc2af27e5b1c323093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5925981bcc6ef6ede47737ecebbd5bca"><td class="memItemLeft" align="right" valign="top"><a id="a5925981bcc6ef6ede47737ecebbd5bca" name="a5925981bcc6ef6ede47737ecebbd5bca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TA_ORG_ARRDIM</b>&#160;&#160;&#160;&quot;__org_arrdim&quot;</td></tr>
<tr class="memdesc:a5925981bcc6ef6ede47737ecebbd5bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">the original array dimension (pack_dd) <br /></td></tr>
<tr class="separator:a5925981bcc6ef6ede47737ecebbd5bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce293d4927b47b87edd19fea49b50ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#afce293d4927b47b87edd19fea49b50ae">TA_FORMAT</a>&#160;&#160;&#160;&quot;format&quot;</td></tr>
<tr class="memdesc:afce293d4927b47b87edd19fea49b50ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">info about the 'format' argument.  <a href="typeinf_8hpp.html#afce293d4927b47b87edd19fea49b50ae">More...</a><br /></td></tr>
<tr class="separator:afce293d4927b47b87edd19fea49b50ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df339dbafd18e09dff205606dd74ef7"><td class="memItemLeft" align="right" valign="top"><a id="a8df339dbafd18e09dff205606dd74ef7" name="a8df339dbafd18e09dff205606dd74ef7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_SPOILED</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a8df339dbafd18e09dff205606dd74ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">information about spoiled registers is present <br /></td></tr>
<tr class="separator:a8df339dbafd18e09dff205606dd74ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22493ebc3efb1464a49a1da0a51743ca"><td class="memItemLeft" align="right" valign="top"><a id="a22493ebc3efb1464a49a1da0a51743ca" name="a22493ebc3efb1464a49a1da0a51743ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_NORET</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a22493ebc3efb1464a49a1da0a51743ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">noreturn <br /></td></tr>
<tr class="separator:a22493ebc3efb1464a49a1da0a51743ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e26f297fe482ab7a5c7cb2251d013f0"><td class="memItemLeft" align="right" valign="top"><a id="a3e26f297fe482ab7a5c7cb2251d013f0" name="a3e26f297fe482ab7a5c7cb2251d013f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_PURE</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a3e26f297fe482ab7a5c7cb2251d013f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">__pure <br /></td></tr>
<tr class="separator:a3e26f297fe482ab7a5c7cb2251d013f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c49eb47a2f43c602070b01684ba871"><td class="memItemLeft" align="right" valign="top"><a id="a59c49eb47a2f43c602070b01684ba871" name="a59c49eb47a2f43c602070b01684ba871"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_HIGH</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a59c49eb47a2f43c602070b01684ba871"><td class="mdescLeft">&#160;</td><td class="mdescRight">high level prototype (with possibly hidden args) <br /></td></tr>
<tr class="separator:a59c49eb47a2f43c602070b01684ba871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac532957fbd5ccc4e337b40d112dd7c54"><td class="memItemLeft" align="right" valign="top"><a id="ac532957fbd5ccc4e337b40d112dd7c54" name="ac532957fbd5ccc4e337b40d112dd7c54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_STATIC</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:ac532957fbd5ccc4e337b40d112dd7c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">static <br /></td></tr>
<tr class="separator:ac532957fbd5ccc4e337b40d112dd7c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5467592f5c51d137ea24c78d8d4a8e45"><td class="memItemLeft" align="right" valign="top"><a id="a5467592f5c51d137ea24c78d8d4a8e45" name="a5467592f5c51d137ea24c78d8d4a8e45"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_VIRTUAL</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a5467592f5c51d137ea24c78d8d4a8e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <br /></td></tr>
<tr class="separator:a5467592f5c51d137ea24c78d8d4a8e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b1697e6881a620be7decafeabea9bb"><td class="memItemLeft" align="right" valign="top"><a id="a05b1697e6881a620be7decafeabea9bb" name="a05b1697e6881a620be7decafeabea9bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_CALLTYPE</b>&#160;&#160;&#160;0x00C0</td></tr>
<tr class="memdesc:a05b1697e6881a620be7decafeabea9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">mask for FTI_*CALL <br /></td></tr>
<tr class="separator:a05b1697e6881a620be7decafeabea9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ac9279d74c695f58e7a06109748443"><td class="memItemLeft" align="right" valign="top"><a id="aa8ac9279d74c695f58e7a06109748443" name="aa8ac9279d74c695f58e7a06109748443"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_DEFCALL</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:aa8ac9279d74c695f58e7a06109748443"><td class="mdescLeft">&#160;</td><td class="mdescRight">default call <br /></td></tr>
<tr class="separator:aa8ac9279d74c695f58e7a06109748443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165cf2a53a0f7a76e0149c3078fee21a"><td class="memItemLeft" align="right" valign="top"><a id="a165cf2a53a0f7a76e0149c3078fee21a" name="a165cf2a53a0f7a76e0149c3078fee21a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_NEARCALL</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a165cf2a53a0f7a76e0149c3078fee21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">near call <br /></td></tr>
<tr class="separator:a165cf2a53a0f7a76e0149c3078fee21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace01167eeb994769a54d1e1ea40de29c"><td class="memItemLeft" align="right" valign="top"><a id="ace01167eeb994769a54d1e1ea40de29c" name="ace01167eeb994769a54d1e1ea40de29c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_FARCALL</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:ace01167eeb994769a54d1e1ea40de29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">far call <br /></td></tr>
<tr class="separator:ace01167eeb994769a54d1e1ea40de29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5100aea70d3aa7ba318cf1d83b3685b"><td class="memItemLeft" align="right" valign="top"><a id="ab5100aea70d3aa7ba318cf1d83b3685b" name="ab5100aea70d3aa7ba318cf1d83b3685b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_INTCALL</b>&#160;&#160;&#160;0x00C0</td></tr>
<tr class="memdesc:ab5100aea70d3aa7ba318cf1d83b3685b"><td class="mdescLeft">&#160;</td><td class="mdescRight">interrupt call <br /></td></tr>
<tr class="separator:ab5100aea70d3aa7ba318cf1d83b3685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d459fcaacc13e99f99317207c1b7c6"><td class="memItemLeft" align="right" valign="top"><a id="ae2d459fcaacc13e99f99317207c1b7c6" name="ae2d459fcaacc13e99f99317207c1b7c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_ARGLOCS</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:ae2d459fcaacc13e99f99317207c1b7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">info about argument locations has been calculated (stkargs and retloc too) <br /></td></tr>
<tr class="separator:ae2d459fcaacc13e99f99317207c1b7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91411e9ecb4f37b303497f1840a1266c"><td class="memItemLeft" align="right" valign="top"><a id="a91411e9ecb4f37b303497f1840a1266c" name="a91411e9ecb4f37b303497f1840a1266c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_EXPLOCS</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:a91411e9ecb4f37b303497f1840a1266c"><td class="mdescLeft">&#160;</td><td class="mdescRight">all arglocs are specified explicitly <br /></td></tr>
<tr class="separator:a91411e9ecb4f37b303497f1840a1266c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7d148b6efd5e4cc2d5ab5c96de98a8"><td class="memItemLeft" align="right" valign="top"><a id="abf7d148b6efd5e4cc2d5ab5c96de98a8" name="abf7d148b6efd5e4cc2d5ab5c96de98a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_CONST</b>&#160;&#160;&#160;0x0400</td></tr>
<tr class="memdesc:abf7d148b6efd5e4cc2d5ab5c96de98a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">const member function <br /></td></tr>
<tr class="separator:abf7d148b6efd5e4cc2d5ab5c96de98a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7803609d10b10f1f231474ce7b3354"><td class="memItemLeft" align="right" valign="top"><a id="a8a7803609d10b10f1f231474ce7b3354" name="a8a7803609d10b10f1f231474ce7b3354"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_CTOR</b>&#160;&#160;&#160;0x0800</td></tr>
<tr class="memdesc:a8a7803609d10b10f1f231474ce7b3354"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor <br /></td></tr>
<tr class="separator:a8a7803609d10b10f1f231474ce7b3354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31645e4ce2719c4c25a6cedc46f778bb"><td class="memItemLeft" align="right" valign="top"><a id="a31645e4ce2719c4c25a6cedc46f778bb" name="a31645e4ce2719c4c25a6cedc46f778bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_DTOR</b>&#160;&#160;&#160;0x1000</td></tr>
<tr class="memdesc:a31645e4ce2719c4c25a6cedc46f778bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a31645e4ce2719c4c25a6cedc46f778bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8e33f82e8adebf5a6a837c58b92040"><td class="memItemLeft" align="right" valign="top"><a id="a0f8e33f82e8adebf5a6a837c58b92040" name="a0f8e33f82e8adebf5a6a837c58b92040"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FTI_ALL</b>&#160;&#160;&#160;0x1FFF</td></tr>
<tr class="memdesc:a0f8e33f82e8adebf5a6a837c58b92040"><td class="mdescLeft">&#160;</td><td class="mdescRight">all defined bits <br /></td></tr>
<tr class="separator:a0f8e33f82e8adebf5a6a837c58b92040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7695b0c12296a19b769ba883e7bcf61"><td class="memItemLeft" align="right" valign="top"><a id="ad7695b0c12296a19b769ba883e7bcf61" name="ad7695b0c12296a19b769ba883e7bcf61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CC_CDECL_OK</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ad7695b0c12296a19b769ba883e7bcf61"><td class="mdescLeft">&#160;</td><td class="mdescRight">can use __cdecl calling convention? <br /></td></tr>
<tr class="separator:ad7695b0c12296a19b769ba883e7bcf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ec64457731f1b6382e6eb6d2e02c2f"><td class="memItemLeft" align="right" valign="top"><a id="a11ec64457731f1b6382e6eb6d2e02c2f" name="a11ec64457731f1b6382e6eb6d2e02c2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CC_ALLOW_ARGPERM</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:a11ec64457731f1b6382e6eb6d2e02c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">disregard argument order? <br /></td></tr>
<tr class="separator:a11ec64457731f1b6382e6eb6d2e02c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aef6a321d05d94745b70be88e1d67b6"><td class="memItemLeft" align="right" valign="top"><a id="a8aef6a321d05d94745b70be88e1d67b6" name="a8aef6a321d05d94745b70be88e1d67b6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CC_ALLOW_REGHOLES</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:a8aef6a321d05d94745b70be88e1d67b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">allow holes in register argument list? <br /></td></tr>
<tr class="separator:a8aef6a321d05d94745b70be88e1d67b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7531e798f24ea3515247abe3f9b7aa3e"><td class="memItemLeft" align="right" valign="top"><a id="a7531e798f24ea3515247abe3f9b7aa3e" name="a7531e798f24ea3515247abe3f9b7aa3e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CC_HAS_ELLIPSIS</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:a7531e798f24ea3515247abe3f9b7aa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function has a variable list of arguments? <br /></td></tr>
<tr class="separator:a7531e798f24ea3515247abe3f9b7aa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9237e4621a23df63acc8c0b5c11853d2"><td class="memItemLeft" align="right" valign="top"><a id="a9237e4621a23df63acc8c0b5c11853d2" name="a9237e4621a23df63acc8c0b5c11853d2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CC_GOLANG_OK</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a9237e4621a23df63acc8c0b5c11853d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">can use __golang calling convention <br /></td></tr>
<tr class="separator:a9237e4621a23df63acc8c0b5c11853d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8e344ef06861c61ccee2926fccc775"><td class="memItemLeft" align="right" valign="top"><a id="a6f8e344ef06861c61ccee2926fccc775" name="a6f8e344ef06861c61ccee2926fccc775"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VTBL_SUFFIX</b>&#160;&#160;&#160;&quot;_vtbl&quot;</td></tr>
<tr class="separator:a6f8e344ef06861c61ccee2926fccc775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d38b0a4ce18e318f9cebfe8d23efde"><td class="memItemLeft" align="right" valign="top"><a id="a88d38b0a4ce18e318f9cebfe8d23efde" name="a88d38b0a4ce18e318f9cebfe8d23efde"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VTBL_MEMNAME</b>&#160;&#160;&#160;&quot;__vftable&quot;</td></tr>
<tr class="separator:a88d38b0a4ce18e318f9cebfe8d23efde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9d8d09f8cf33f3fe852a309002d35c"><td class="memItemLeft" align="right" valign="top"><a id="a6a9d8d09f8cf33f3fe852a309002d35c" name="a6a9d8d09f8cf33f3fe852a309002d35c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TPOS_LNNUM</b>&#160;&#160;&#160;&quot;\x05&quot;</td></tr>
<tr class="separator:a6a9d8d09f8cf33f3fe852a309002d35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411b1c97d919f52e0eaf374eac7fd506"><td class="memItemLeft" align="right" valign="top"><a id="a411b1c97d919f52e0eaf374eac7fd506" name="a411b1c97d919f52e0eaf374eac7fd506"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TVIS_TYPE</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a411b1c97d919f52e0eaf374eac7fd506"><td class="mdescLeft">&#160;</td><td class="mdescRight">new type info is present <br /></td></tr>
<tr class="separator:a411b1c97d919f52e0eaf374eac7fd506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0634cf54218951d620298127a022c6"><td class="memItemLeft" align="right" valign="top"><a id="aeb0634cf54218951d620298127a022c6" name="aeb0634cf54218951d620298127a022c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TVIS_NAME</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:aeb0634cf54218951d620298127a022c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">new name is present <br /></td></tr>
<tr class="separator:aeb0634cf54218951d620298127a022c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8107421a9d4b0158d826de18607845d3"><td class="memItemLeft" align="right" valign="top"><a id="a8107421a9d4b0158d826de18607845d3" name="a8107421a9d4b0158d826de18607845d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TVIS_CMT</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a8107421a9d4b0158d826de18607845d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">new comment is present <br /></td></tr>
<tr class="separator:a8107421a9d4b0158d826de18607845d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecd7fc21799f6bc2a0c107f93237fb4"><td class="memItemLeft" align="right" valign="top"><a id="a5ecd7fc21799f6bc2a0c107f93237fb4" name="a5ecd7fc21799f6bc2a0c107f93237fb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TVST_PRUNE</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:a5ecd7fc21799f6bc2a0c107f93237fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't visit children of current type <br /></td></tr>
<tr class="separator:a5ecd7fc21799f6bc2a0c107f93237fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79530cdefdd426b9253ebd4f5a197db"><td class="memItemLeft" align="right" valign="top"><a id="ad79530cdefdd426b9253ebd4f5a197db" name="ad79530cdefdd426b9253ebd4f5a197db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TVST_DEF</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ad79530cdefdd426b9253ebd4f5a197db"><td class="mdescLeft">&#160;</td><td class="mdescRight">visit type definition (meaningful for typerefs) <br /></td></tr>
<tr class="separator:ad79530cdefdd426b9253ebd4f5a197db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2310b06eb52fdf48ff6a05400f1fdc7"><td class="memItemLeft" align="right" valign="top"><a id="af2310b06eb52fdf48ff6a05400f1fdc7" name="af2310b06eb52fdf48ff6a05400f1fdc7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TVST_LEVEL</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:af2310b06eb52fdf48ff6a05400f1fdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab938d9be9a5d674172a6ccdc612c97e1"><td class="memItemLeft" align="right" valign="top"><a id="ab938d9be9a5d674172a6ccdc612c97e1" name="ab938d9be9a5d674172a6ccdc612c97e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PIO_NOATTR_FAIL</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:ab938d9be9a5d674172a6ccdc612c97e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">missing attributes are not ok <br /></td></tr>
<tr class="separator:ab938d9be9a5d674172a6ccdc612c97e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c114dc666c6867c10132e1957607a14"><td class="memItemLeft" align="right" valign="top"><a id="a3c114dc666c6867c10132e1957607a14" name="a3c114dc666c6867c10132e1957607a14"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PIO_IGNORE_PTRS</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a3c114dc666c6867c10132e1957607a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not follow pointers <br /></td></tr>
<tr class="separator:a3c114dc666c6867c10132e1957607a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cd3059626ab4ab40a530fdfcc99abb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ac2cd3059626ab4ab40a530fdfcc99abb">PTV_DEREF</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:ac2cd3059626ab4ab40a530fdfcc99abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">take value to print from the debugged process.  <a href="typeinf_8hpp.html#ac2cd3059626ab4ab40a530fdfcc99abb">More...</a><br /></td></tr>
<tr class="separator:ac2cd3059626ab4ab40a530fdfcc99abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156121be3a2cd423ebd876f26f5c5b85"><td class="memItemLeft" align="right" valign="top"><a id="a156121be3a2cd423ebd876f26f5c5b85" name="a156121be3a2cd423ebd876f26f5c5b85"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_QUEST</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a156121be3a2cd423ebd876f26f5c5b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">print '?' for uninited data <br /></td></tr>
<tr class="separator:a156121be3a2cd423ebd876f26f5c5b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0177bf01caa85ed297e8a2c206ccde52"><td class="memItemLeft" align="right" valign="top"><a id="a0177bf01caa85ed297e8a2c206ccde52" name="a0177bf01caa85ed297e8a2c206ccde52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_EMPTY</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a0177bf01caa85ed297e8a2c206ccde52"><td class="mdescLeft">&#160;</td><td class="mdescRight">return empty string for uninited data; should not specify PTV_QUEST and PTV_EMPTY together <br /></td></tr>
<tr class="separator:a0177bf01caa85ed297e8a2c206ccde52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5843023faccf3e228bcaaf102978d667"><td class="memItemLeft" align="right" valign="top"><a id="a5843023faccf3e228bcaaf102978d667" name="a5843023faccf3e228bcaaf102978d667"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_CSTR</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a5843023faccf3e228bcaaf102978d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">print constant strings inline <br /></td></tr>
<tr class="separator:a5843023faccf3e228bcaaf102978d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3961c67927e9f622c548d492555ecda7"><td class="memItemLeft" align="right" valign="top"><a id="a3961c67927e9f622c548d492555ecda7" name="a3961c67927e9f622c548d492555ecda7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_EXPAND</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a3961c67927e9f622c548d492555ecda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">print only top level on separate lines; max_length applies to separate lines; margin is ignored <br /></td></tr>
<tr class="separator:a3961c67927e9f622c548d492555ecda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652ab7f0c08c4c906ca21617dd9f2041"><td class="memItemLeft" align="right" valign="top"><a id="a652ab7f0c08c4c906ca21617dd9f2041" name="a652ab7f0c08c4c906ca21617dd9f2041"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_LZHEX</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a652ab7f0c08c4c906ca21617dd9f2041"><td class="mdescLeft">&#160;</td><td class="mdescRight">print hex numbers with leading zeroes <br /></td></tr>
<tr class="separator:a652ab7f0c08c4c906ca21617dd9f2041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373eeb90ac754fe4e80ef450c210ed24"><td class="memItemLeft" align="right" valign="top"><a id="a373eeb90ac754fe4e80ef450c210ed24" name="a373eeb90ac754fe4e80ef450c210ed24"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_STPFLT</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a373eeb90ac754fe4e80ef450c210ed24"><td class="mdescLeft">&#160;</td><td class="mdescRight">fail on bad floating point numbers (if not set, just print ?flt for them) <br /></td></tr>
<tr class="separator:a373eeb90ac754fe4e80ef450c210ed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76a9c7baf7bddf882d963855ffa120e"><td class="memItemLeft" align="right" valign="top"><a id="aa76a9c7baf7bddf882d963855ffa120e" name="aa76a9c7baf7bddf882d963855ffa120e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_SPACE</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:aa76a9c7baf7bddf882d963855ffa120e"><td class="mdescLeft">&#160;</td><td class="mdescRight">add spaces after commas and around braces <br /></td></tr>
<tr class="separator:aa76a9c7baf7bddf882d963855ffa120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1cfa4d03ebded255c8564ae86758e4"><td class="memItemLeft" align="right" valign="top"><a id="a8a1cfa4d03ebded255c8564ae86758e4" name="a8a1cfa4d03ebded255c8564ae86758e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_DEBUG</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a8a1cfa4d03ebded255c8564ae86758e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">format output for debugger <br /></td></tr>
<tr class="separator:a8a1cfa4d03ebded255c8564ae86758e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4fe127ed5ba1b21d33b44dbf161833"><td class="memItemLeft" align="right" valign="top"><a id="aff4fe127ed5ba1b21d33b44dbf161833" name="aff4fe127ed5ba1b21d33b44dbf161833"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_NOPTR</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:aff4fe127ed5ba1b21d33b44dbf161833"><td class="mdescLeft">&#160;</td><td class="mdescRight">prevent pointer values from appearing in the output <br /></td></tr>
<tr class="separator:aff4fe127ed5ba1b21d33b44dbf161833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ab5cf5e31d427494eccc50753e956e"><td class="memItemLeft" align="right" valign="top"><a id="a64ab5cf5e31d427494eccc50753e956e" name="a64ab5cf5e31d427494eccc50753e956e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_NTOP</b>&#160;&#160;&#160;0x40000000</td></tr>
<tr class="memdesc:a64ab5cf5e31d427494eccc50753e956e"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal flag, do not use <br /></td></tr>
<tr class="separator:a64ab5cf5e31d427494eccc50753e956e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a74deafea6f8166a3083351852f418"><td class="memItemLeft" align="right" valign="top"><a id="a99a74deafea6f8166a3083351852f418" name="a99a74deafea6f8166a3083351852f418"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PTV_KEEP</b>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:a99a74deafea6f8166a3083351852f418"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal flag, do not use <br /></td></tr>
<tr class="separator:a99a74deafea6f8166a3083351852f418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48e19cb49e4c575c66e6f09cb740e99"><td class="memItemLeft" align="right" valign="top"><a id="ab48e19cb49e4c575c66e6f09cb740e99" name="ab48e19cb49e4c575c66e6f09cb740e99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VALSTR_OPEN</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ab48e19cb49e4c575c66e6f09cb740e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">printed opening curly brace '{' <br /></td></tr>
<tr class="separator:ab48e19cb49e4c575c66e6f09cb740e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ff1cf61b5fd76fd24f6d29e5a6b326"><td class="memItemLeft" align="right" valign="top"><a id="ad9ff1cf61b5fd76fd24f6d29e5a6b326" name="ad9ff1cf61b5fd76fd24f6d29e5a6b326"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PDF_INCL_DEPS</b>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:ad9ff1cf61b5fd76fd24f6d29e5a6b326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include all type dependencies. <br /></td></tr>
<tr class="separator:ad9ff1cf61b5fd76fd24f6d29e5a6b326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2250bf6beb5da6b346fb6436ab3c51c6"><td class="memItemLeft" align="right" valign="top"><a id="a2250bf6beb5da6b346fb6436ab3c51c6" name="a2250bf6beb5da6b346fb6436ab3c51c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PDF_DEF_FWD</b>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:a2250bf6beb5da6b346fb6436ab3c51c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow forward declarations. <br /></td></tr>
<tr class="separator:a2250bf6beb5da6b346fb6436ab3c51c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3300d368429d8077549d501d98091b75"><td class="memItemLeft" align="right" valign="top"><a id="a3300d368429d8077549d501d98091b75" name="a3300d368429d8077549d501d98091b75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PDF_DEF_BASE</b>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:a3300d368429d8077549d501d98091b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include base types: __int8, __int16, etc.. <br /></td></tr>
<tr class="separator:a3300d368429d8077549d501d98091b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe52addf8e1d8d9ff975fdec23011ce"><td class="memItemLeft" align="right" valign="top"><a id="aefe52addf8e1d8d9ff975fdec23011ce" name="aefe52addf8e1d8d9ff975fdec23011ce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PDF_HEADER_CMT</b>&#160;&#160;&#160;0x8</td></tr>
<tr class="memdesc:aefe52addf8e1d8d9ff975fdec23011ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend output with a descriptive comment. <br /></td></tr>
<tr class="separator:aefe52addf8e1d8d9ff975fdec23011ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7756d1cbc54de302daabf331a5acb409"><td class="memItemLeft" align="right" valign="top"><a id="a7756d1cbc54de302daabf331a5acb409" name="a7756d1cbc54de302daabf331a5acb409"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_RADIX</b>&#160;&#160;&#160;0x07</td></tr>
<tr class="memdesc:a7756d1cbc54de302daabf331a5acb409"><td class="mdescLeft">&#160;</td><td class="mdescRight">number base to use <br /></td></tr>
<tr class="separator:a7756d1cbc54de302daabf331a5acb409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01db281c510426448f4ba6690093bb1f"><td class="memItemLeft" align="right" valign="top"><a id="a01db281c510426448f4ba6690093bb1f" name="a01db281c510426448f4ba6690093bb1f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_DEC</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:a01db281c510426448f4ba6690093bb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">decimal <br /></td></tr>
<tr class="separator:a01db281c510426448f4ba6690093bb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d28f6fee65104f5348690ea800904f"><td class="memItemLeft" align="right" valign="top"><a id="aa1d28f6fee65104f5348690ea800904f" name="aa1d28f6fee65104f5348690ea800904f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_HEX</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:aa1d28f6fee65104f5348690ea800904f"><td class="mdescLeft">&#160;</td><td class="mdescRight">hexadecimal <br /></td></tr>
<tr class="separator:aa1d28f6fee65104f5348690ea800904f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4236f5ff0be0d8954080a8d88356c12f"><td class="memItemLeft" align="right" valign="top"><a id="a4236f5ff0be0d8954080a8d88356c12f" name="a4236f5ff0be0d8954080a8d88356c12f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_OCT</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:a4236f5ff0be0d8954080a8d88356c12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">octal <br /></td></tr>
<tr class="separator:a4236f5ff0be0d8954080a8d88356c12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ad228fd673e70dc3520b8ecb5af13a"><td class="memItemLeft" align="right" valign="top"><a id="aa0ad228fd673e70dc3520b8ecb5af13a" name="aa0ad228fd673e70dc3520b8ecb5af13a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_CHR</b>&#160;&#160;&#160;0x03</td></tr>
<tr class="memdesc:aa0ad228fd673e70dc3520b8ecb5af13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">character <br /></td></tr>
<tr class="separator:aa0ad228fd673e70dc3520b8ecb5af13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8cdf42eea0a4b38d69701b8f66ee0b"><td class="memItemLeft" align="right" valign="top"><a id="a0a8cdf42eea0a4b38d69701b8f66ee0b" name="a0a8cdf42eea0a4b38d69701b8f66ee0b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_UNSIGNED</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:a0a8cdf42eea0a4b38d69701b8f66ee0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">add 'u' suffix <br /></td></tr>
<tr class="separator:a0a8cdf42eea0a4b38d69701b8f66ee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198c99d83d30fe9c74e1db215a6c4b21"><td class="memItemLeft" align="right" valign="top"><a id="a198c99d83d30fe9c74e1db215a6c4b21" name="a198c99d83d30fe9c74e1db215a6c4b21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_LZHEX</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a198c99d83d30fe9c74e1db215a6c4b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">print leading zeroes for hexdecimal number <br /></td></tr>
<tr class="separator:a198c99d83d30fe9c74e1db215a6c4b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e49c27b6a7848a5d13f7f86d1ce8e8"><td class="memItemLeft" align="right" valign="top"><a id="a72e49c27b6a7848a5d13f7f86d1ce8e8" name="a72e49c27b6a7848a5d13f7f86d1ce8e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_NEGSIGN</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:a72e49c27b6a7848a5d13f7f86d1ce8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">print negated value (-N) for negative numbers <br /></td></tr>
<tr class="separator:a72e49c27b6a7848a5d13f7f86d1ce8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8350d6705e02d69582e5b88d1585d4d8"><td class="memItemLeft" align="right" valign="top"><a id="a8350d6705e02d69582e5b88d1585d4d8" name="a8350d6705e02d69582e5b88d1585d4d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PCN_DECSEXT</b>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:a8350d6705e02d69582e5b88d1585d4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">automatically extend sign of signed decimal numbers <br /></td></tr>
<tr class="separator:a8350d6705e02d69582e5b88d1585d4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Work with type modifiers: const and volatile </p>
</div></td></tr>
<tr class="memitem:a73745575ef1ce96d1128c32c78056473"><td class="memItemLeft" align="right" valign="top"><a id="a73745575ef1ce96d1128c32c78056473" name="a73745575ef1ce96d1128c32c78056473"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_EQUAL</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:a73745575ef1ce96d1128c32c78056473"><td class="mdescLeft">&#160;</td><td class="mdescRight">are types equal? <br /></td></tr>
<tr class="separator:a73745575ef1ce96d1128c32c78056473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9729204bc8db15ef336290593ead04"><td class="memItemLeft" align="right" valign="top"><a id="a9b9729204bc8db15ef336290593ead04" name="a9b9729204bc8db15ef336290593ead04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_IGNMODS</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a9b9729204bc8db15ef336290593ead04"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore const/volatile modifiers <br /></td></tr>
<tr class="separator:a9b9729204bc8db15ef336290593ead04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add983394ea2843e6eecf832ce89864b7"><td class="memItemLeft" align="right" valign="top"><a id="add983394ea2843e6eecf832ce89864b7" name="add983394ea2843e6eecf832ce89864b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_AUTOCAST</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:add983394ea2843e6eecf832ce89864b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">can t1 be cast into t2 automatically? <br /></td></tr>
<tr class="separator:add983394ea2843e6eecf832ce89864b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec10cd8cb06035bff94cadb3ad0c0316"><td class="memItemLeft" align="right" valign="top"><a id="aec10cd8cb06035bff94cadb3ad0c0316" name="aec10cd8cb06035bff94cadb3ad0c0316"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_MANCAST</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:aec10cd8cb06035bff94cadb3ad0c0316"><td class="mdescLeft">&#160;</td><td class="mdescRight">can t1 be cast into t2 manually? <br /></td></tr>
<tr class="separator:aec10cd8cb06035bff94cadb3ad0c0316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd06c6ff9de33211639458ea969b8ab"><td class="memItemLeft" align="right" valign="top"><a id="a2fd06c6ff9de33211639458ea969b8ab" name="a2fd06c6ff9de33211639458ea969b8ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_CALL</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a2fd06c6ff9de33211639458ea969b8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">can t1 be called with t2 type? <br /></td></tr>
<tr class="separator:a2fd06c6ff9de33211639458ea969b8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f73445bfc95b7b0398bfbb4ab82246"><td class="memItemLeft" align="right" valign="top"><a id="a15f73445bfc95b7b0398bfbb4ab82246" name="a15f73445bfc95b7b0398bfbb4ab82246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_DELPTR</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a15f73445bfc95b7b0398bfbb4ab82246"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove pointer from types before comparing <br /></td></tr>
<tr class="separator:a15f73445bfc95b7b0398bfbb4ab82246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9335b458b4c944621b97db52be82c8"><td class="memItemLeft" align="right" valign="top"><a id="a7a9335b458b4c944621b97db52be82c8" name="a7a9335b458b4c944621b97db52be82c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_DECL</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a7a9335b458b4c944621b97db52be82c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare declarations without resolving them <br /></td></tr>
<tr class="separator:a7a9335b458b4c944621b97db52be82c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7c9bb69a7cbb588177d53af41a0e7a"><td class="memItemLeft" align="right" valign="top"><a id="a0a7c9bb69a7cbb588177d53af41a0e7a" name="a0a7c9bb69a7cbb588177d53af41a0e7a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_ANYBASE</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a0a7c9bb69a7cbb588177d53af41a0e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">accept any base class when casting <br /></td></tr>
<tr class="separator:a0a7c9bb69a7cbb588177d53af41a0e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7368b5ef3f6e74c9e2686774ccc91c9c"><td class="memItemLeft" align="right" valign="top"><a id="a7368b5ef3f6e74c9e2686774ccc91c9c" name="a7368b5ef3f6e74c9e2686774ccc91c9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TCMP_SKIPTHIS</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:a7368b5ef3f6e74c9e2686774ccc91c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip the first function argument in comparison <br /></td></tr>
<tr class="separator:a7368b5ef3f6e74c9e2686774ccc91c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7a9c029b924959e0fe4f14b3531fb733"><td class="memItemLeft" align="right" valign="top"><a id="a7a9c029b924959e0fe4f14b3531fb733" name="a7a9c029b924959e0fe4f14b3531fb733"></a>
typedef <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>type_t</b></td></tr>
<tr class="memdesc:a7a9c029b924959e0fe4f14b3531fb733"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte sequence used to describe a type in IDA (see <a class="el" href="group__tf.html">Type flags</a>) <br /></td></tr>
<tr class="separator:a7a9c029b924959e0fe4f14b3531fb733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c34de97522bfad60d58ac37f150f81a"><td class="memItemLeft" align="right" valign="top"><a id="a3c34de97522bfad60d58ac37f150f81a" name="a3c34de97522bfad60d58ac37f150f81a"></a>
typedef <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>p_string</b></td></tr>
<tr class="memdesc:a3c34de97522bfad60d58ac37f150f81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">pascal-like string: dt length, characters <br /></td></tr>
<tr class="separator:a3c34de97522bfad60d58ac37f150f81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828c7e985f83b1e74eb4ea7b716abfb1"><td class="memItemLeft" align="right" valign="top"><a id="a828c7e985f83b1e74eb4ea7b716abfb1" name="a828c7e985f83b1e74eb4ea7b716abfb1"></a>
typedef <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>p_list</b></td></tr>
<tr class="memdesc:a828c7e985f83b1e74eb4ea7b716abfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">several <a class="el" href="typeinf_8hpp.html#a3c34de97522bfad60d58ac37f150f81a" title="pascal-like string: dt length, characters">p_string</a>'s <br /></td></tr>
<tr class="separator:a828c7e985f83b1e74eb4ea7b716abfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae7aa54dbc597ec17cbb17555306a02"><td class="memItemLeft" align="right" valign="top"><a id="a9ae7aa54dbc597ec17cbb17555306a02" name="a9ae7aa54dbc597ec17cbb17555306a02"></a>
typedef <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bte_t</b></td></tr>
<tr class="memdesc:a9ae7aa54dbc597ec17cbb17555306a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum type flags. <br /></td></tr>
<tr class="separator:a9ae7aa54dbc597ec17cbb17555306a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ddf13221681bc7444911f100dc5f5b"><td class="memItemLeft" align="right" valign="top"><a id="a59ddf13221681bc7444911f100dc5f5b" name="a59ddf13221681bc7444911f100dc5f5b"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structtype__attr__t.html">type_attr_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>type_attrs_t</b></td></tr>
<tr class="memdesc:a59ddf13221681bc7444911f100dc5f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">this vector must be sorted by keys <br /></td></tr>
<tr class="separator:a59ddf13221681bc7444911f100dc5f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91970b0d779fe968b3b22572526048a0"><td class="memItemLeft" align="right" valign="top"><a id="a91970b0d779fe968b3b22572526048a0" name="a91970b0d779fe968b3b22572526048a0"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>type_sign_t</b></td></tr>
<tr class="memdesc:a91970b0d779fe968b3b22572526048a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">type signedness <br /></td></tr>
<tr class="separator:a91970b0d779fe968b3b22572526048a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa486b80f279565c5e29558d6694afd"><td class="memItemLeft" align="right" valign="top"><a id="afaa486b80f279565c5e29558d6694afd" name="afaa486b80f279565c5e29558d6694afd"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>argloc_type_t</b></td></tr>
<tr class="memdesc:afaa486b80f279565c5e29558d6694afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the location type of a function argument - see <a class="el" href="group___a_l_o_c__.html">Argument location types</a>. <br /></td></tr>
<tr class="separator:afaa486b80f279565c5e29558d6694afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d78bf064365f662c656f53d9296358"><td class="memItemLeft" align="right" valign="top"><a id="ad3d78bf064365f662c656f53d9296358" name="ad3d78bf064365f662c656f53d9296358"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="classargloc__t.html">argloc_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>arglocs_t</b></td></tr>
<tr class="memdesc:ad3d78bf064365f662c656f53d9296358"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of argument locations <br /></td></tr>
<tr class="separator:ad3d78bf064365f662c656f53d9296358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fa236e5a8bba22cb2996497e9f82d1"><td class="memItemLeft" align="right" valign="top"><a id="a67fa236e5a8bba22cb2996497e9f82d1" name="a67fa236e5a8bba22cb2996497e9f82d1"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structargpart__t.html">argpart_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>argpartvec_t</b></td></tr>
<tr class="separator:a67fa236e5a8bba22cb2996497e9f82d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d65e448c6e1903b22a2ad528ed9d9d7"><td class="memItemLeft" align="right" valign="top"><a id="a6d65e448c6e1903b22a2ad528ed9d9d7" name="a6d65e448c6e1903b22a2ad528ed9d9d7"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>compvec_t</b></td></tr>
<tr class="memdesc:a6d65e448c6e1903b22a2ad528ed9d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of compiler descriptions. <br /></td></tr>
<tr class="separator:a6d65e448c6e1903b22a2ad528ed9d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034013ece7194a003ffd1727075100d2"><td class="memItemLeft" align="right" valign="top">typedef int idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a034013ece7194a003ffd1727075100d2">h2ti_type_cb</a>(const char *name, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, const char *cmt, const uint64 *value, void *cb_data)</td></tr>
<tr class="memdesc:a034013ece7194a003ffd1727075100d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This callback will be called for each type/variable declaration.  <a href="typeinf_8hpp.html#a034013ece7194a003ffd1727075100d2">More...</a><br /></td></tr>
<tr class="separator:a034013ece7194a003ffd1727075100d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc521f1e3d068d8cdf760885a8f53c4"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#abcc521f1e3d068d8cdf760885a8f53c4">printer_t</a>(const char *format,...)</td></tr>
<tr class="memdesc:abcc521f1e3d068d8cdf760885a8f53c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a printing callback when parsing types.  <a href="typeinf_8hpp.html#abcc521f1e3d068d8cdf760885a8f53c4">More...</a><br /></td></tr>
<tr class="separator:abcc521f1e3d068d8cdf760885a8f53c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd6c6a8661308225119ef20b1fed47"><td class="memItemLeft" align="right" valign="top"><a id="a48fd6c6a8661308225119ef20b1fed47" name="a48fd6c6a8661308225119ef20b1fed47"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="classtinfo__t.html">tinfo_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tinfovec_t</b></td></tr>
<tr class="memdesc:a48fd6c6a8661308225119ef20b1fed47"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of tinfo objects <br /></td></tr>
<tr class="separator:a48fd6c6a8661308225119ef20b1fed47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0da5f34cdb584f01f870e5f7bbbdbf0"><td class="memItemLeft" align="right" valign="top"><a id="ac0da5f34cdb584f01f870e5f7bbbdbf0" name="ac0da5f34cdb584f01f870e5f7bbbdbf0"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structsimd__info__t.html">simd_info_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simd_info_vec_t</b></td></tr>
<tr class="separator:ac0da5f34cdb584f01f870e5f7bbbdbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5faeba43c9a59ec3aae166657ff78a"><td class="memItemLeft" align="right" valign="top"><a id="a6b5faeba43c9a59ec3aae166657ff78a" name="a6b5faeba43c9a59ec3aae166657ff78a"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structfuncarg__t.html">funcarg_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>funcargvec_t</b></td></tr>
<tr class="memdesc:a6b5faeba43c9a59ec3aae166657ff78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of function argument objects <br /></td></tr>
<tr class="separator:a6b5faeba43c9a59ec3aae166657ff78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2aadabcca84a77fa5b48ef883eef18"><td class="memItemLeft" align="right" valign="top"><a id="a9b2aadabcca84a77fa5b48ef883eef18" name="a9b2aadabcca84a77fa5b48ef883eef18"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structenum__member__t.html">enum_member_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>enum_member_vec_t</b></td></tr>
<tr class="memdesc:a9b2aadabcca84a77fa5b48ef883eef18"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of enum values <br /></td></tr>
<tr class="separator:a9b2aadabcca84a77fa5b48ef883eef18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e94c1e088d978519655ab31fb96c6"><td class="memItemLeft" align="right" valign="top"><a id="a2b3e94c1e088d978519655ab31fb96c6" name="a2b3e94c1e088d978519655ab31fb96c6"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structregobj__t.html">regobj_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>regobjvec_t</b></td></tr>
<tr class="separator:a2b3e94c1e088d978519655ab31fb96c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d835e2fb9a6449a84c4f4f00aa5a53e"><td class="memItemLeft" align="right" valign="top"><a id="a9d835e2fb9a6449a84c4f4f00aa5a53e" name="a9d835e2fb9a6449a84c4f4f00aa5a53e"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="classvalstr__t.html">valstr_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>valstrvec_t</b></td></tr>
<tr class="separator:a9d835e2fb9a6449a84c4f4f00aa5a53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e20ac5ddb94b98b2c0826f3615c5c57"><td class="memItemLeft" align="right" valign="top"><a id="a6e20ac5ddb94b98b2c0826f3615c5c57" name="a6e20ac5ddb94b98b2c0826f3615c5c57"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ordvec_t</b></td></tr>
<tr class="separator:a6e20ac5ddb94b98b2c0826f3615c5c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50d6548ef1add1a4a33341539d9f737"><td class="memItemLeft" align="right" valign="top">typedef int idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ab50d6548ef1add1a4a33341539d9f737">local_tinfo_predicate_t</a>(<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ord, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;type, void *ud)</td></tr>
<tr class="memdesc:ab50d6548ef1add1a4a33341539d9f737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls which types are displayed/selected when choosing local types.  <a href="typeinf_8hpp.html#ab50d6548ef1add1a4a33341539d9f737">More...</a><br /></td></tr>
<tr class="separator:ab50d6548ef1add1a4a33341539d9f737"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1213616e618bb2e2eeef3789c5a3066a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a1213616e618bb2e2eeef3789c5a3066a">argreg_policy_t</a> { <br />
&#160;&#160;<b>ARGREGS_POLICY_UNDEFINED</b>
, <a class="el" href="typeinf_8hpp.html#a1213616e618bb2e2eeef3789c5a3066aa78b105fc74836db7dfc4892af9e69c06">ARGREGS_GP_ONLY</a>
, <a class="el" href="typeinf_8hpp.html#a1213616e618bb2e2eeef3789c5a3066aaed785e829f5e0b1f404dc2b512cb0698">ARGREGS_INDEPENDENT</a>
, <a class="el" href="typeinf_8hpp.html#a1213616e618bb2e2eeef3789c5a3066aae440e0d293e7994fec765a045ec0b7de">ARGREGS_BY_SLOTS</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a1213616e618bb2e2eeef3789c5a3066aaa5cdf7a88dcb45b3f820bb4a854229d6">ARGREGS_FP_CONSUME_GP</a>
, <a class="el" href="typeinf_8hpp.html#a1213616e618bb2e2eeef3789c5a3066aaea1dbb58dd762e078ac9b45b2e19975e">ARGREGS_MIPS_O32</a>
<br />
 }</td></tr>
<tr class="memdesc:a1213616e618bb2e2eeef3789c5a3066a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function argument passing: how GP &amp; FP registers cooperate with each other.  <a href="typeinf_8hpp.html#a1213616e618bb2e2eeef3789c5a3066a">More...</a><br /></td></tr>
<tr class="separator:a1213616e618bb2e2eeef3789c5a3066a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784254a39507ac759a9f373a52a75ac1"><td class="memItemLeft" align="right" valign="top"><a id="a784254a39507ac759a9f373a52a75ac1" name="a784254a39507ac759a9f373a52a75ac1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a784254a39507ac759a9f373a52a75ac1">abs_t</a> { <b>abs_unk</b>
, <b>abs_no</b>
, <b>abs_yes</b>
 }</td></tr>
<tr class="memdesc:a784254a39507ac759a9f373a52a75ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstractness of declaration (see <a class="el" href="typeinf_8hpp.html#a6a2c9c8787240c725a87bb5cb5ffc7a4" title="Convert declarations to type_t*.">h2ti()</a>) <br /></td></tr>
<tr class="separator:a784254a39507ac759a9f373a52a75ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9a05934a8418932a82a2d39476d97d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> { <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97da89e3586b675e0685da04bfd54a2502a9">sc_unk</a>
, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97dacf0ce1cb3d478a7f62557c3f8f446e11">sc_type</a>
, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97da0c593cc88b83620bdb34f43f9e5dda31">sc_ext</a>
, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97da551b28b82cb4482f30efa4ebe9b4e473">sc_stat</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97da962c56792f11d705f2feba400d5a7d09">sc_reg</a>
, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97da172b8da8be19c3ba9754022815316154">sc_auto</a>
, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97da5e33945d971e16746389317965a7ac10">sc_friend</a>
, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97da9a8553f5d79dbbec9b4c5d572a2e3489">sc_virt</a>
<br />
 }</td></tr>
<tr class="memdesc:a9c9a05934a8418932a82a2d39476d97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; storage class  <a href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">More...</a><br /></td></tr>
<tr class="separator:a9c9a05934a8418932a82a2d39476d97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2c98771820db5f78f2e754c97c0aaa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaa">tinfo_code_t</a> { <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaaaf1e302c7895bfa27324ea87b2613f934">TERR_OK</a> = 0
, <a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaaab5040c8d0d7d40aaec3229056feeb441">TERR_SAVE</a> = -1
, <a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaaa8d887bee845b2f1ef5f2b91509a7d8a7">TERR_SERIALIZE</a> = -2
, <a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaaaed75b318f4c08674eb57ba88cdd7c420">TERR_WRONGNAME</a> = -3
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaaad5b485a8aea98a39638a33b0fdf3aece">TERR_BADSYNC</a> = -4
<br />
 }</td></tr>
<tr class="memdesc:a4b2c98771820db5f78f2e754c97c0aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for save_tinfo functions:  <a href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaa">More...</a><br /></td></tr>
<tr class="separator:a4b2c98771820db5f78f2e754c97c0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5cba82dd91a1d49c2e0cdd8f5d5211"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211">stock_type_id_t</a> { <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211ad2201926ec41b27053183ae1156551d2">STI_PCHAR</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211ad8ed5a69facf5f0d115305508d4360c0">STI_PUCHAR</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a47647669a95737a405ea759a47ebe6d4">STI_PCCHAR</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a6b69598b89a319945d2378755bceda3b">STI_PCUCHAR</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211af1c5fab58b7522abba89c3e8ea011585">STI_PBYTE</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a0294096331b11299a1725d47b0ec48aa">STI_PINT</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a4ce84ce1b31df9af7da92ed166efc855">STI_PUINT</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211ab91aef96c15480ad770574620493a5b5">STI_PVOID</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211ac38dccd05b2c93cae2e8ea71a52d9548">STI_PPVOID</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a0f808184209169009a1de95bc6ed64eb">STI_PCVOID</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a3b3eef78afdcd967b0314486de96f371">STI_ACHAR</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a2cd9c8e886dddfe900bd01e68c1a46bc">STI_AUCHAR</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a69a9601f852e149baf5c28ac900bd91d">STI_ACCHAR</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211adc44280551009cc2b281ee7f540c8d4a">STI_ACUCHAR</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211ad16bb6ab5bc017c2c424c0b43a4ba8a1">STI_FPURGING</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a95e3539d8614d7c1f78e480397fe785d">STI_FDELOP</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a8512c62f2fdd18bc875a81aab1acfffc">STI_MSGSEND</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a1243182dde00b57ae0fdcd93578f8b91">STI_AEABI_LCMP</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211acfbfbda5305515c6c8bffea0c24a7d59">STI_AEABI_ULCMP</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a43f6e82ab8b5f5927ea126930f42d83d">STI_DONT_USE</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211af6f297c7ffa79618a21fb2ae0205d107">STI_SIZE_T</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a17d3a099be27bc57e7d2ceaecc78cbbb">STI_SSIZE_T</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a7db708741cdccbe41aa9418614365ab4">STI_AEABI_MEMCPY</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a2dae55494874e37f19ea88efdcec3310">STI_AEABI_MEMSET</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211acfde347b9ce367f40c8a54d664e5d67e">STI_AEABI_MEMCLR</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a79e42d641f074eaca76bb67e7e40fc85">STI_RTC_CHECK_2</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a7cab85c891644bed71779929562d3d44">STI_RTC_CHECK_4</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a162e68c27d6d04f6ac4c2d9997866a1c">STI_RTC_CHECK_8</a>
, <br />
&#160;&#160;<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a6fa97a7992d72da3555ef5352368e2e1">STI_COMPLEX64</a>
, <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211a4733b02fc9148c661af9127435afcd7b">STI_COMPLEX128</a>
, <b>STI_LAST</b>
<br />
 }</td></tr>
<tr class="memdesc:a3d5cba82dd91a1d49c2e0cdd8f5d5211"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs for common types.  <a href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211">More...</a><br /></td></tr>
<tr class="separator:a3d5cba82dd91a1d49c2e0cdd8f5d5211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3b7b00fcc1f35943355ff4a59ee27b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a6a3b7b00fcc1f35943355ff4a59ee27b">gtd_udt_t</a> { <a class="el" href="typeinf_8hpp.html#a6a3b7b00fcc1f35943355ff4a59ee27ba1c0801cf7075c0d784cf8d66c608160c">GTD_CALC_LAYOUT</a> = 0
, <a class="el" href="typeinf_8hpp.html#a6a3b7b00fcc1f35943355ff4a59ee27ba5fcc07edfa8f3f3d7a8df7e224ddea59">GTD_NO_LAYOUT</a> = BTM_VOLATILE
, <a class="el" href="typeinf_8hpp.html#a6a3b7b00fcc1f35943355ff4a59ee27badb23c2ea9cfb7587fd7afbeb4fc61f93">GTD_DEL_BITFLDS</a> = BTM_CONST
 }</td></tr>
<tr class="memdesc:a6a3b7b00fcc1f35943355ff4a59ee27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants to be used with get_udt_details()  <a href="typeinf_8hpp.html#a6a3b7b00fcc1f35943355ff4a59ee27b">More...</a><br /></td></tr>
<tr class="separator:a6a3b7b00fcc1f35943355ff4a59ee27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f0a2e39ac376a1f6e903e970e527c9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ab7f0a2e39ac376a1f6e903e970e527c9">gtd_func_t</a> { <a class="el" href="typeinf_8hpp.html#ab7f0a2e39ac376a1f6e903e970e527c9a5bd1413dc6a22cf8e0b2d924da8db70b">GTD_CALC_ARGLOCS</a> = 0
, <a class="el" href="typeinf_8hpp.html#ab7f0a2e39ac376a1f6e903e970e527c9a10a6bd6a4e21f49a406a5d5b81ca0504">GTD_NO_ARGLOCS</a> = BTM_VOLATILE
 }</td></tr>
<tr class="memdesc:ab7f0a2e39ac376a1f6e903e970e527c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants to be used with get_func_details()  <a href="typeinf_8hpp.html#ab7f0a2e39ac376a1f6e903e970e527c9">More...</a><br /></td></tr>
<tr class="separator:ab7f0a2e39ac376a1f6e903e970e527c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f68192de992d505e6ba381993bccc5b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a0f68192de992d505e6ba381993bccc5b">gts_code_t</a> { <a class="el" href="typeinf_8hpp.html#a0f68192de992d505e6ba381993bccc5bace4d40b057bf8f9dd9af50fa4e1bbddb">GTS_NESTED</a> = 0x01
, <a class="el" href="typeinf_8hpp.html#a0f68192de992d505e6ba381993bccc5badf69b340e31e11338120b48af3ec52f5">GTS_BASECLASS</a> = 0x02
 }</td></tr>
<tr class="memdesc:a0f68192de992d505e6ba381993bccc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants to be used with get_size()  <a href="typeinf_8hpp.html#a0f68192de992d505e6ba381993bccc5b">More...</a><br /></td></tr>
<tr class="separator:a0f68192de992d505e6ba381993bccc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb7ef3b5dbe1b8c187a5314d02baaf3"><td class="memItemLeft" align="right" valign="top"><a id="a4fb7ef3b5dbe1b8c187a5314d02baaf3" name="a4fb7ef3b5dbe1b8c187a5314d02baaf3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a4fb7ef3b5dbe1b8c187a5314d02baaf3">format_functype_t</a> { <b>FMTFUNC_PRINTF</b>
, <b>FMTFUNC_SCANF</b>
, <b>FMTFUNC_STRFTIME</b>
, <b>FMTFUNC_STRFMON</b>
 }</td></tr>
<tr class="memdesc:a4fb7ef3b5dbe1b8c187a5314d02baaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function index for the 'format' attribute. <br /></td></tr>
<tr class="separator:a4fb7ef3b5dbe1b8c187a5314d02baaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae46ad265dbaedeab1f06346a4d9f98"><td class="memItemLeft" align="right" valign="top"><a id="a7ae46ad265dbaedeab1f06346a4d9f98" name="a7ae46ad265dbaedeab1f06346a4d9f98"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a7ae46ad265dbaedeab1f06346a4d9f98">update_type_t</a> { <b>UTP_ENUM</b>
, <b>UTP_STRUCT</b>
 }</td></tr>
<tr class="memdesc:a7ae46ad265dbaedeab1f06346a4d9f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#aa417d7c0601ec34392c906300e20107c" title="Mark the beginning of a large update operation on the types.">begin_type_updating()</a> <br /></td></tr>
<tr class="separator:a7ae46ad265dbaedeab1f06346a4d9f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5600637357881b01f287352dc9c2f0c3"><td class="memItemLeft" align="right" valign="top"><a id="a5600637357881b01f287352dc9c2f0c3" name="a5600637357881b01f287352dc9c2f0c3"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_const</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a5600637357881b01f287352dc9c2f0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a9620c6eab27564299c432f6f22c963e0" title="const">BTM_CONST</a>. <br /></td></tr>
<tr class="separator:a5600637357881b01f287352dc9c2f0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde8e08567e4911d1543dffc887f11be"><td class="memItemLeft" align="right" valign="top"><a id="adde8e08567e4911d1543dffc887f11be" name="adde8e08567e4911d1543dffc887f11be"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_volatile</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:adde8e08567e4911d1543dffc887f11be"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a980855dd322c9bc15ac45421c7267d13" title="volatile">BTM_VOLATILE</a>. <br /></td></tr>
<tr class="separator:adde8e08567e4911d1543dffc887f11be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c03bae7fa4ae861b89c9a02f912874"><td class="memItemLeft" align="right" valign="top"><a id="a02c03bae7fa4ae861b89c9a02f912874" name="a02c03bae7fa4ae861b89c9a02f912874"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_base_type</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a02c03bae7fa4ae861b89c9a02f912874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get get basic type bits (<a class="el" href="typeinf_8hpp.html#ae890bf98baf7dcadf121a9b5ee1eed51" title="the low 4 bits define the basic type">TYPE_BASE_MASK</a>) <br /></td></tr>
<tr class="separator:a02c03bae7fa4ae861b89c9a02f912874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01a1ac75916e6d0d660825232bf2617"><td class="memItemLeft" align="right" valign="top"><a id="aa01a1ac75916e6d0d660825232bf2617" name="aa01a1ac75916e6d0d660825232bf2617"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_type_flags</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:aa01a1ac75916e6d0d660825232bf2617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type flags (<a class="el" href="typeinf_8hpp.html#aac5ec5ef511fe0323471b0f2765d85cf" title="type flags - they have different meaning depending on the basic type">TYPE_FLAGS_MASK</a>) <br /></td></tr>
<tr class="separator:aa01a1ac75916e6d0d660825232bf2617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073b3c678f297e564eed971b2122e2d0"><td class="memItemLeft" align="right" valign="top"><a id="a073b3c678f297e564eed971b2122e2d0" name="a073b3c678f297e564eed971b2122e2d0"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_full_type</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a073b3c678f297e564eed971b2122e2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get basic type bits + type flags (<a class="el" href="typeinf_8hpp.html#a0546e0e6a47765f33245d7a9d6b175aa" title="basic type with type flags">TYPE_FULL_MASK</a>) <br /></td></tr>
<tr class="separator:a073b3c678f297e564eed971b2122e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05ad7eaa75d2591180350701c160e5b"><td class="memItemLeft" align="right" valign="top"><a id="ae05ad7eaa75d2591180350701c160e5b" name="ae05ad7eaa75d2591180350701c160e5b"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_typeid_last</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:ae05ad7eaa75d2591180350701c160e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type_t the last byte of type declaration? (there are no additional bytes after a basic type, see <a class="el" href="typeinf_8hpp.html#add35f3c45f5a8e13b0ce6603702c1445" title="the last basic type, all basic types may be followed by [tah-typeattrs]">_BT_LAST_BASIC</a>) <br /></td></tr>
<tr class="separator:ae05ad7eaa75d2591180350701c160e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b6818574b8ccd7a13cbffe1fbc17"><td class="memItemLeft" align="right" valign="top"><a id="a4740b6818574b8ccd7a13cbffe1fbc17" name="a4740b6818574b8ccd7a13cbffe1fbc17"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_partial</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a4740b6818574b8ccd7a13cbffe1fbc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies an unknown or void type with a known size (see <a class="el" href="group__tf__unk.html">Basic type: unknown &amp; void</a>) <br /></td></tr>
<tr class="separator:a4740b6818574b8ccd7a13cbffe1fbc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e700eca7128e0100c9778faa98c944"><td class="memItemLeft" align="right" valign="top"><a id="a78e700eca7128e0100c9778faa98c944" name="a78e700eca7128e0100c9778faa98c944"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_void</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a78e700eca7128e0100c9778faa98c944"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a8e3b664437b42978e3549134abf2ea26" title="void">BTF_VOID</a>. <br /></td></tr>
<tr class="separator:a78e700eca7128e0100c9778faa98c944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d2ab5739b4d2798e0ef0a0113507d4"><td class="memItemLeft" align="right" valign="top"><a id="ab9d2ab5739b4d2798e0ef0a0113507d4" name="ab9d2ab5739b4d2798e0ef0a0113507d4"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_unknown</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:ab9d2ab5739b4d2798e0ef0a0113507d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a15de9552b0654e950d709fd9c165f7aa" title="unknown size - for parameters">BT_UNKNOWN</a>. <br /></td></tr>
<tr class="separator:ab9d2ab5739b4d2798e0ef0a0113507d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d6f93c0f425eeb4bebd31613b136fe"><td class="memItemLeft" align="right" valign="top"><a id="ad1d6f93c0f425eeb4bebd31613b136fe" name="ad1d6f93c0f425eeb4bebd31613b136fe"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_ptr</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:ad1d6f93c0f425eeb4bebd31613b136fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer.">BT_PTR</a>. <br /></td></tr>
<tr class="separator:ad1d6f93c0f425eeb4bebd31613b136fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5c0a9ff8f7a72797e673386816308a"><td class="memItemLeft" align="right" valign="top"><a id="a6c5c0a9ff8f7a72797e673386816308a" name="a6c5c0a9ff8f7a72797e673386816308a"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_complex</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a6c5c0a9ff8f7a72797e673386816308a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a86c5e589737e005ba4741423fd2ca5c6" title="struct/union/enum/typedef.">BT_COMPLEX</a>. <br /></td></tr>
<tr class="separator:a6c5c0a9ff8f7a72797e673386816308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d08b523bb014e791bedcdc95f49877a"><td class="memItemLeft" align="right" valign="top"><a id="a0d08b523bb014e791bedcdc95f49877a" name="a0d08b523bb014e791bedcdc95f49877a"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_func</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a0d08b523bb014e791bedcdc95f49877a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a7b7fee21f21237beb6d91e854410e0fa" title="function.">BT_FUNC</a>. <br /></td></tr>
<tr class="separator:a0d08b523bb014e791bedcdc95f49877a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb6719ddbacfb1990b3370c8f716b7f"><td class="memItemLeft" align="right" valign="top"><a id="a6cb6719ddbacfb1990b3370c8f716b7f" name="a6cb6719ddbacfb1990b3370c8f716b7f"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_array</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a6cb6719ddbacfb1990b3370c8f716b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a8c17124d38e796e7cd8804808e4bb5b3" title="array">BT_ARRAY</a>. <br /></td></tr>
<tr class="separator:a6cb6719ddbacfb1990b3370c8f716b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21130607735a1b00bab3f6a0a2e559ef"><td class="memItemLeft" align="right" valign="top"><a id="a21130607735a1b00bab3f6a0a2e559ef" name="a21130607735a1b00bab3f6a0a2e559ef"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_typedef</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a21130607735a1b00bab3f6a0a2e559ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a64e49eed2f4e754689e7bcc7f6efdd74" title="typedef">BTF_TYPEDEF</a>. <br /></td></tr>
<tr class="separator:a21130607735a1b00bab3f6a0a2e559ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae683f03a9c04f99d6cd408e1c6a8469b"><td class="memItemLeft" align="right" valign="top"><a id="ae683f03a9c04f99d6cd408e1c6a8469b" name="ae683f03a9c04f99d6cd408e1c6a8469b"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_sue</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:ae683f03a9c04f99d6cd408e1c6a8469b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type a struct/union/enum? <br /></td></tr>
<tr class="separator:ae683f03a9c04f99d6cd408e1c6a8469b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f44db5315948a00d037f6ba43adbb8"><td class="memItemLeft" align="right" valign="top"><a id="a18f44db5315948a00d037f6ba43adbb8" name="a18f44db5315948a00d037f6ba43adbb8"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_struct</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a18f44db5315948a00d037f6ba43adbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a861f45bbf58b9d699897e234b0905009" title="struct">BTF_STRUCT</a>. <br /></td></tr>
<tr class="separator:a18f44db5315948a00d037f6ba43adbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39de099aa2205375ac1f8c3f193c8eb9"><td class="memItemLeft" align="right" valign="top"><a id="a39de099aa2205375ac1f8c3f193c8eb9" name="a39de099aa2205375ac1f8c3f193c8eb9"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_union</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a39de099aa2205375ac1f8c3f193c8eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a0a5536b8782826bb2b925fc65c49788c" title="union">BTF_UNION</a>. <br /></td></tr>
<tr class="separator:a39de099aa2205375ac1f8c3f193c8eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919fdffd7f3cc91d8001c89ff495dda2"><td class="memItemLeft" align="right" valign="top"><a id="a919fdffd7f3cc91d8001c89ff495dda2" name="a919fdffd7f3cc91d8001c89ff495dda2"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_struni</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a919fdffd7f3cc91d8001c89ff495dda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type a struct or union? <br /></td></tr>
<tr class="separator:a919fdffd7f3cc91d8001c89ff495dda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa5a8654c3b7a645353b6010b843e43"><td class="memItemLeft" align="right" valign="top"><a id="a6aa5a8654c3b7a645353b6010b843e43" name="a6aa5a8654c3b7a645353b6010b843e43"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_enum</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a6aa5a8654c3b7a645353b6010b843e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a5eee5573060ab34fdee9230f37d8369f" title="enum">BTF_ENUM</a>. <br /></td></tr>
<tr class="separator:a6aa5a8654c3b7a645353b6010b843e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc35245ae4a50b2a11b923d8b0db885"><td class="memItemLeft" align="right" valign="top"><a id="a3bc35245ae4a50b2a11b923d8b0db885" name="a3bc35245ae4a50b2a11b923d8b0db885"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_bitfld</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a3bc35245ae4a50b2a11b923d8b0db885"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a0d1af452c81ac917f9eab9d456f52454" title="bitfield (only in struct) [&#39;bitmasked&#39; enum see below] next byte is dt ((size in bits &lt;&lt; 1) | (unsign...">BT_BITFIELD</a>. <br /></td></tr>
<tr class="separator:a3bc35245ae4a50b2a11b923d8b0db885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5154911973164c300adab0bf2938bdb3"><td class="memItemLeft" align="right" valign="top"><a id="a5154911973164c300adab0bf2938bdb3" name="a5154911973164c300adab0bf2938bdb3"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_int</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> bt)</td></tr>
<tr class="memdesc:a5154911973164c300adab0bf2938bdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the type_t specify one of the basic types in <a class="el" href="group__tf__int.html">Basic type: integer</a>? <br /></td></tr>
<tr class="separator:a5154911973164c300adab0bf2938bdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4313d6e8e35ce13f232ab09db6e05e0"><td class="memItemLeft" align="right" valign="top"><a id="af4313d6e8e35ce13f232ab09db6e05e0" name="af4313d6e8e35ce13f232ab09db6e05e0"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_int128</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:af4313d6e8e35ce13f232ab09db6e05e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the type specify a 128-bit value? (signed or unsigned, see <a class="el" href="group__tf__int.html">Basic type: integer</a>) <br /></td></tr>
<tr class="separator:af4313d6e8e35ce13f232ab09db6e05e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc824eb005d77267941ad1b4a24a3cb"><td class="memItemLeft" align="right" valign="top"><a id="aefc824eb005d77267941ad1b4a24a3cb" name="aefc824eb005d77267941ad1b4a24a3cb"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_int64</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:aefc824eb005d77267941ad1b4a24a3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the type specify a 64-bit value? (signed or unsigned, see <a class="el" href="group__tf__int.html">Basic type: integer</a>) <br /></td></tr>
<tr class="separator:aefc824eb005d77267941ad1b4a24a3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d67917b0bac1d2bc82fe62b3b8ba4c5"><td class="memItemLeft" align="right" valign="top"><a id="a3d67917b0bac1d2bc82fe62b3b8ba4c5" name="a3d67917b0bac1d2bc82fe62b3b8ba4c5"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_int32</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a3d67917b0bac1d2bc82fe62b3b8ba4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the type specify a 32-bit value? (signed or unsigned, see <a class="el" href="group__tf__int.html">Basic type: integer</a>) <br /></td></tr>
<tr class="separator:a3d67917b0bac1d2bc82fe62b3b8ba4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdc90751ea6f751a67862e4ec166b4f"><td class="memItemLeft" align="right" valign="top"><a id="a0bdc90751ea6f751a67862e4ec166b4f" name="a0bdc90751ea6f751a67862e4ec166b4f"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_int16</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a0bdc90751ea6f751a67862e4ec166b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the type specify a 16-bit value? (signed or unsigned, see <a class="el" href="group__tf__int.html">Basic type: integer</a>) <br /></td></tr>
<tr class="separator:a0bdc90751ea6f751a67862e4ec166b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d46944648115d1443b220d590c154f"><td class="memItemLeft" align="right" valign="top"><a id="a18d46944648115d1443b220d590c154f" name="a18d46944648115d1443b220d590c154f"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_char</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a18d46944648115d1443b220d590c154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the type specify a char value? (signed or unsigned, see <a class="el" href="group__tf__int.html">Basic type: integer</a>) <br /></td></tr>
<tr class="separator:a18d46944648115d1443b220d590c154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43c8d9be5b623ba5d70b8b80c438b98"><td class="memItemLeft" align="right" valign="top"><a id="aa43c8d9be5b623ba5d70b8b80c438b98" name="aa43c8d9be5b623ba5d70b8b80c438b98"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_paf</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:aa43c8d9be5b623ba5d70b8b80c438b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type a pointer, array, or function type? <br /></td></tr>
<tr class="separator:aa43c8d9be5b623ba5d70b8b80c438b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28faf30cb1cc755210f3d5003f2da69b"><td class="memItemLeft" align="right" valign="top"><a id="a28faf30cb1cc755210f3d5003f2da69b" name="a28faf30cb1cc755210f3d5003f2da69b"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_ptr_or_array</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a28faf30cb1cc755210f3d5003f2da69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type a pointer or array type? <br /></td></tr>
<tr class="separator:a28faf30cb1cc755210f3d5003f2da69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e60192598d88a85050400ff2fdc1f2"><td class="memItemLeft" align="right" valign="top"><a id="a41e60192598d88a85050400ff2fdc1f2" name="a41e60192598d88a85050400ff2fdc1f2"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_floating</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a41e60192598d88a85050400ff2fdc1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type a floating point type? <br /></td></tr>
<tr class="separator:a41e60192598d88a85050400ff2fdc1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376bbcfe511295ad874cd413ef335d53"><td class="memItemLeft" align="right" valign="top"><a id="a376bbcfe511295ad874cd413ef335d53" name="a376bbcfe511295ad874cd413ef335d53"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_integral</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a376bbcfe511295ad874cd413ef335d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type an integral type (char/short/int/long/bool)? <br /></td></tr>
<tr class="separator:a376bbcfe511295ad874cd413ef335d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a325be0e026ad4a44c1a1e062090e1"><td class="memItemLeft" align="right" valign="top"><a id="a94a325be0e026ad4a44c1a1e062090e1" name="a94a325be0e026ad4a44c1a1e062090e1"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_ext_integral</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a94a325be0e026ad4a44c1a1e062090e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type an extended integral type? (integral or enum) <br /></td></tr>
<tr class="separator:a94a325be0e026ad4a44c1a1e062090e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524514edcfac0b01b270cfba2263fac3"><td class="memItemLeft" align="right" valign="top"><a id="a524514edcfac0b01b270cfba2263fac3" name="a524514edcfac0b01b270cfba2263fac3"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_arithmetic</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a524514edcfac0b01b270cfba2263fac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type an arithmetic type? (floating or integral) <br /></td></tr>
<tr class="separator:a524514edcfac0b01b270cfba2263fac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023942e426aad17e816b4469ad9dfc1b"><td class="memItemLeft" align="right" valign="top"><a id="a023942e426aad17e816b4469ad9dfc1b" name="a023942e426aad17e816b4469ad9dfc1b"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_ext_arithmetic</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a023942e426aad17e816b4469ad9dfc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type an extended arithmetic type? (arithmetic or enum) <br /></td></tr>
<tr class="separator:a023942e426aad17e816b4469ad9dfc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45eef29001c30761de2110fdae05dc7a"><td class="memItemLeft" align="right" valign="top"><a id="a45eef29001c30761de2110fdae05dc7a" name="a45eef29001c30761de2110fdae05dc7a"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_uint</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a45eef29001c30761de2110fdae05dc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a4806703d16672e5666cbd8d183539f0d" title="unsigned int">BTF_UINT</a>. <br /></td></tr>
<tr class="separator:a45eef29001c30761de2110fdae05dc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe426b58e85f7c3aeb7687d64d6f243"><td class="memItemLeft" align="right" valign="top"><a id="a3fe426b58e85f7c3aeb7687d64d6f243" name="a3fe426b58e85f7c3aeb7687d64d6f243"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_uchar</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a3fe426b58e85f7c3aeb7687d64d6f243"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a7133ca0feba2a5aaff3cd2ad9e80ac00" title="unsigned char">BTF_UCHAR</a>. <br /></td></tr>
<tr class="separator:a3fe426b58e85f7c3aeb7687d64d6f243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3214bd58b29238944413a31b11d66099"><td class="memItemLeft" align="right" valign="top"><a id="a3214bd58b29238944413a31b11d66099" name="a3214bd58b29238944413a31b11d66099"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_uint16</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a3214bd58b29238944413a31b11d66099"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a11cd0cd85c8e0bf67add7ecda0c8519c" title="unsigned short">BTF_UINT16</a>. <br /></td></tr>
<tr class="separator:a3214bd58b29238944413a31b11d66099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a6f759ec4f748604894153174dff4"><td class="memItemLeft" align="right" valign="top"><a id="a006a6f759ec4f748604894153174dff4" name="a006a6f759ec4f748604894153174dff4"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_uint32</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a006a6f759ec4f748604894153174dff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a5c66f893953d1b56d97a19fad216b9cd" title="unsigned int">BTF_UINT32</a>. <br /></td></tr>
<tr class="separator:a006a6f759ec4f748604894153174dff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef5964f95636e66f91a4e6b32b8fb3f"><td class="memItemLeft" align="right" valign="top"><a id="a9ef5964f95636e66f91a4e6b32b8fb3f" name="a9ef5964f95636e66f91a4e6b32b8fb3f"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_uint64</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a9ef5964f95636e66f91a4e6b32b8fb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a2aedc026ad655dba0ad0d99349be3987" title="unsigned long">BTF_UINT64</a>. <br /></td></tr>
<tr class="separator:a9ef5964f95636e66f91a4e6b32b8fb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33327282e0c1b1acbc1af071f1a08bc"><td class="memItemLeft" align="right" valign="top"><a id="ab33327282e0c1b1acbc1af071f1a08bc" name="ab33327282e0c1b1acbc1af071f1a08bc"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_uint128</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:ab33327282e0c1b1acbc1af071f1a08bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a1b72aa0e7ce565e0da5cad1d37e20f84" title="unsigned 128-bit value">BTF_UINT128</a>. <br /></td></tr>
<tr class="separator:ab33327282e0c1b1acbc1af071f1a08bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aee950119ac903e5ee4205c6f159699"><td class="memItemLeft" align="right" valign="top"><a id="a7aee950119ac903e5ee4205c6f159699" name="a7aee950119ac903e5ee4205c6f159699"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_ldouble</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a7aee950119ac903e5ee4205c6f159699"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#aa86134b88d5f0c1c33a482ba02e5a314" title="long double">BTF_LDOUBLE</a>. <br /></td></tr>
<tr class="separator:a7aee950119ac903e5ee4205c6f159699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fc48e703859445ccfdd68f98c97549"><td class="memItemLeft" align="right" valign="top"><a id="a20fc48e703859445ccfdd68f98c97549" name="a20fc48e703859445ccfdd68f98c97549"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_double</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a20fc48e703859445ccfdd68f98c97549"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#a14c776e37b0c4461f737a2f14d5401f9" title="double">BTF_DOUBLE</a>. <br /></td></tr>
<tr class="separator:a20fc48e703859445ccfdd68f98c97549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebaafcc39a2e90d181213bbe1fd08f9"><td class="memItemLeft" align="right" valign="top"><a id="acebaafcc39a2e90d181213bbe1fd08f9" name="acebaafcc39a2e90d181213bbe1fd08f9"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_float</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:acebaafcc39a2e90d181213bbe1fd08f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#ae2965fc7a244e1147d99547e97284848" title="float">BTF_FLOAT</a>. <br /></td></tr>
<tr class="separator:acebaafcc39a2e90d181213bbe1fd08f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54ef5e371058262cc75d5644392c8e2"><td class="memItemLeft" align="right" valign="top"><a id="aa54ef5e371058262cc75d5644392c8e2" name="aa54ef5e371058262cc75d5644392c8e2"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_tbyte</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:aa54ef5e371058262cc75d5644392c8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#ae2965fc7a244e1147d99547e97284848" title="float">BTF_FLOAT</a>. <br /></td></tr>
<tr class="separator:aa54ef5e371058262cc75d5644392c8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c68448fa5a9120e6b87b2f3d45af02"><td class="memItemLeft" align="right" valign="top"><a id="a85c68448fa5a9120e6b87b2f3d45af02" name="a85c68448fa5a9120e6b87b2f3d45af02"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_type_bool</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a85c68448fa5a9120e6b87b2f3d45af02"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#aecd76b18e7247eae4cc2ab7b5ce07722" title="boolean">BTF_BOOL</a>. <br /></td></tr>
<tr class="separator:a85c68448fa5a9120e6b87b2f3d45af02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b044ce67e074ad66bb905809f8461aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a3b044ce67e074ad66bb905809f8461aa">is_tah_byte</a> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a3b044ce67e074ad66bb905809f8461aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TAH byte (type attribute header byte) denotes the start of type attributes.  <a href="typeinf_8hpp.html#a3b044ce67e074ad66bb905809f8461aa">More...</a><br /></td></tr>
<tr class="separator:a3b044ce67e074ad66bb905809f8461aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d20f03e4434bdd91c0b012bc847b610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a9d20f03e4434bdd91c0b012bc847b610">is_sdacl_byte</a> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> t)</td></tr>
<tr class="memdesc:a9d20f03e4434bdd91c0b012bc847b610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify an sdacl byte.  <a href="typeinf_8hpp.html#a9d20f03e4434bdd91c0b012bc847b610">More...</a><br /></td></tr>
<tr class="separator:a9d20f03e4434bdd91c0b012bc847b610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb51dca7f479be755b0487951ec0491"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aaeb51dca7f479be755b0487951ec0491">operator&lt;</a> (const <a class="el" href="classbytevec__t.html">bytevec_t</a> &amp;v1, const <a class="el" href="classbytevec__t.html">bytevec_t</a> &amp;v2)</td></tr>
<tr class="memdesc:aaeb51dca7f479be755b0487951ec0491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two bytevecs with '&lt;'.  <a href="typeinf_8hpp.html#aaeb51dca7f479be755b0487951ec0491">More...</a><br /></td></tr>
<tr class="separator:aaeb51dca7f479be755b0487951ec0491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aa328bbcde5b9d3bd290624b199967"><td class="memItemLeft" align="right" valign="top"><a id="ad7aa328bbcde5b9d3bd290624b199967" name="ad7aa328bbcde5b9d3bd290624b199967"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>append_argloc</b> (<a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *out, const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;vloc)</td></tr>
<tr class="memdesc:ad7aa328bbcde5b9d3bd290624b199967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize argument location. <br /></td></tr>
<tr class="separator:ad7aa328bbcde5b9d3bd290624b199967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064da0ed8c78e492feeae9c6db99d3be"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a064da0ed8c78e492feeae9c6db99d3be">extract_argloc</a> (<a class="el" href="classargloc__t.html">argloc_t</a> *vloc, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **ptype, bool forbid_stkoff)</td></tr>
<tr class="memdesc:a064da0ed8c78e492feeae9c6db99d3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an argument location.  <a href="typeinf_8hpp.html#a064da0ed8c78e492feeae9c6db99d3be">More...</a><br /></td></tr>
<tr class="separator:a064da0ed8c78e492feeae9c6db99d3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65a7483a1ec9c7d01f6f51c45e86c1f"><td class="memItemLeft" align="right" valign="top"><a id="af65a7483a1ec9c7d01f6f51c45e86c1f" name="af65a7483a1ec9c7d01f6f51c45e86c1f"></a>
idaman const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>resolve_typedef</b> (const <a class="el" href="structtil__t.html">til_t</a> *til, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="separator:af65a7483a1ec9c7d01f6f51c45e86c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2421768ac6d8f0891017ea68f36c78dd"><td class="memItemLeft" align="right" valign="top"><a id="a2421768ac6d8f0891017ea68f36c78dd" name="a2421768ac6d8f0891017ea68f36c78dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_restype_void</b> (const <a class="el" href="structtil__t.html">til_t</a> *til, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="separator:a2421768ac6d8f0891017ea68f36c78dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1327544b02a64d8f998662976793374"><td class="memItemLeft" align="right" valign="top"><a id="ab1327544b02a64d8f998662976793374" name="ab1327544b02a64d8f998662976793374"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_restype_enum</b> (const <a class="el" href="structtil__t.html">til_t</a> *til, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="separator:ab1327544b02a64d8f998662976793374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59481543f6668ac26f86277278c82a86"><td class="memItemLeft" align="right" valign="top"><a id="a59481543f6668ac26f86277278c82a86" name="a59481543f6668ac26f86277278c82a86"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_restype_struni</b> (const <a class="el" href="structtil__t.html">til_t</a> *til, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="separator:a59481543f6668ac26f86277278c82a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a8bbe759f74bd07c1ed9988c1b1b3c"><td class="memItemLeft" align="right" valign="top"><a id="a99a8bbe759f74bd07c1ed9988c1b1b3c" name="a99a8bbe759f74bd07c1ed9988c1b1b3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_restype_struct</b> (const <a class="el" href="structtil__t.html">til_t</a> *til, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="separator:a99a8bbe759f74bd07c1ed9988c1b1b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aa2b3c49855b156d0c338a780112fe"><td class="memItemLeft" align="right" valign="top"><a id="a29aa2b3c49855b156d0c338a780112fe" name="a29aa2b3c49855b156d0c338a780112fe"></a>
idaman <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_scalar_bt</b> (int size)</td></tr>
<tr class="separator:a29aa2b3c49855b156d0c338a780112fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaa6b9308578fd8a759b5585e2a4ac6"><td class="memItemLeft" align="right" valign="top"><a id="adfaa6b9308578fd8a759b5585e2a4ac6" name="adfaa6b9308578fd8a759b5585e2a4ac6"></a>
idaman <a class="el" href="structtil__t.html">til_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>new_til</b> (const char *name, const char *desc)</td></tr>
<tr class="memdesc:adfaa6b9308578fd8a759b5585e2a4ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a til. <br /></td></tr>
<tr class="separator:adfaa6b9308578fd8a759b5585e2a4ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6edbd7cbdda3ef90191430f3060474"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a5f6edbd7cbdda3ef90191430f3060474">add_base_tils</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf, <a class="el" href="structtil__t.html">til_t</a> *ti, const char *tildir, const char *bases, bool gen_events)</td></tr>
<tr class="memdesc:a5f6edbd7cbdda3ef90191430f3060474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add multiple base tils.  <a href="typeinf_8hpp.html#a5f6edbd7cbdda3ef90191430f3060474">More...</a><br /></td></tr>
<tr class="separator:a5f6edbd7cbdda3ef90191430f3060474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dac6319b660df2fb2f24ffbd7cade88"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="structtil__t.html">til_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a6dac6319b660df2fb2f24ffbd7cade88">load_til</a> (const char *name, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf, const char *tildir=nullptr)</td></tr>
<tr class="memdesc:a6dac6319b660df2fb2f24ffbd7cade88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load til from a file without adding it to the database list (see also <a class="el" href="typeinf_8hpp.html#a6ae3c9ab321e5107e8ba4df22de3fcbf">add_til</a>).  <a href="typeinf_8hpp.html#a6dac6319b660df2fb2f24ffbd7cade88">More...</a><br /></td></tr>
<tr class="separator:a6dac6319b660df2fb2f24ffbd7cade88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec1f9582d33fb9d15bbf2f0102b693c"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aaec1f9582d33fb9d15bbf2f0102b693c">sort_til</a> (<a class="el" href="structtil__t.html">til_t</a> *ti)</td></tr>
<tr class="memdesc:aaec1f9582d33fb9d15bbf2f0102b693c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort til (use after modifying it).  <a href="typeinf_8hpp.html#aaec1f9582d33fb9d15bbf2f0102b693c">More...</a><br /></td></tr>
<tr class="separator:aaec1f9582d33fb9d15bbf2f0102b693c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d12b7291be52278d2d193b82165639"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a85d12b7291be52278d2d193b82165639">compact_til</a> (<a class="el" href="structtil__t.html">til_t</a> *ti)</td></tr>
<tr class="memdesc:a85d12b7291be52278d2d193b82165639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect garbage in til.  <a href="typeinf_8hpp.html#a85d12b7291be52278d2d193b82165639">More...</a><br /></td></tr>
<tr class="separator:a85d12b7291be52278d2d193b82165639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3076c45c4329974096cc8923658f0e"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a8a3076c45c4329974096cc8923658f0e">store_til</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, const char *tildir, const char *name)</td></tr>
<tr class="memdesc:a8a3076c45c4329974096cc8923658f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store til to a file.  <a href="typeinf_8hpp.html#a8a3076c45c4329974096cc8923658f0e">More...</a><br /></td></tr>
<tr class="separator:a8a3076c45c4329974096cc8923658f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc9cf4e476ff8d150c1e77bb0746301"><td class="memItemLeft" align="right" valign="top"><a id="a7fc9cf4e476ff8d150c1e77bb0746301" name="a7fc9cf4e476ff8d150c1e77bb0746301"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>free_til</b> (<a class="el" href="structtil__t.html">til_t</a> *ti)</td></tr>
<tr class="memdesc:a7fc9cf4e476ff8d150c1e77bb0746301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory allocated by til. <br /></td></tr>
<tr class="separator:a7fc9cf4e476ff8d150c1e77bb0746301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a16c7b600ac4c511d9f1b17206ec07"><td class="memItemLeft" align="right" valign="top"><a id="a72a16c7b600ac4c511d9f1b17206ec07" name="a72a16c7b600ac4c511d9f1b17206ec07"></a>
idaman <a class="el" href="structtil__t.html">til_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>load_til_header</b> (const char *tildir, const char *name, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf)</td></tr>
<tr class="memdesc:a72a16c7b600ac4c511d9f1b17206ec07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get human-readable til description. <br /></td></tr>
<tr class="separator:a72a16c7b600ac4c511d9f1b17206ec07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0649e56c68ff049219d68104deab26"><td class="memItemLeft" align="right" valign="top"><a id="a4a0649e56c68ff049219d68104deab26" name="a4a0649e56c68ff049219d68104deab26"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_code_far</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cm)</td></tr>
<tr class="memdesc:a4a0649e56c68ff049219d68104deab26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given model specify far code?. <br /></td></tr>
<tr class="separator:a4a0649e56c68ff049219d68104deab26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514b71d0e58c2de4f8470bb2b2a0b34f"><td class="memItemLeft" align="right" valign="top"><a id="a514b71d0e58c2de4f8470bb2b2a0b34f" name="a514b71d0e58c2de4f8470bb2b2a0b34f"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_data_far</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cm)</td></tr>
<tr class="memdesc:a514b71d0e58c2de4f8470bb2b2a0b34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given model specify far data?. <br /></td></tr>
<tr class="separator:a514b71d0e58c2de4f8470bb2b2a0b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a684d3b5a6369163f377a94585edb77"><td class="memItemLeft" align="right" valign="top"><a id="a4a684d3b5a6369163f377a94585edb77" name="a4a684d3b5a6369163f377a94585edb77"></a>
idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>install_custom_argloc</b> (const <a class="el" href="structcustloc__desc__t.html">custloc_desc_t</a> *custloc)</td></tr>
<tr class="memdesc:a4a684d3b5a6369163f377a94585edb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a custom argloc. <br /></td></tr>
<tr class="separator:a4a684d3b5a6369163f377a94585edb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb953830132811494989955976c4e119"><td class="memItemLeft" align="right" valign="top"><a id="adb953830132811494989955976c4e119" name="adb953830132811494989955976c4e119"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>remove_custom_argloc</b> (int idx)</td></tr>
<tr class="memdesc:adb953830132811494989955976c4e119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the custom argloc at the given index. <br /></td></tr>
<tr class="separator:adb953830132811494989955976c4e119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0e6730d587b886023a26674ce697cf"><td class="memItemLeft" align="right" valign="top"><a id="aad0e6730d587b886023a26674ce697cf" name="aad0e6730d587b886023a26674ce697cf"></a>
idaman const <a class="el" href="structcustloc__desc__t.html">custloc_desc_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>retrieve_custom_argloc</b> (int idx)</td></tr>
<tr class="memdesc:aad0e6730d587b886023a26674ce697cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the custom argloc at the given index. <br /></td></tr>
<tr class="separator:aad0e6730d587b886023a26674ce697cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d82624c71c4f04c749344171cf4978"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a12d82624c71c4f04c749344171cf4978">verify_argloc</a> (const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;vloc, int size, const <a class="el" href="classrangeset__t.html">rangeset_t</a> *gaps)</td></tr>
<tr class="memdesc:a12d82624c71c4f04c749344171cf4978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify <a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a>.  <a href="typeinf_8hpp.html#a12d82624c71c4f04c749344171cf4978">More...</a><br /></td></tr>
<tr class="separator:a12d82624c71c4f04c749344171cf4978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b916c550685f48f02b3fd5c97d3f1f"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ad7b916c550685f48f02b3fd5c97d3f1f">optimize_argloc</a> (<a class="el" href="classargloc__t.html">argloc_t</a> *vloc, int size, const <a class="el" href="classrangeset__t.html">rangeset_t</a> *gaps)</td></tr>
<tr class="memdesc:ad7b916c550685f48f02b3fd5c97d3f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify and optimize scattered argloc into simple form.  <a href="typeinf_8hpp.html#ad7b916c550685f48f02b3fd5c97d3f1f">More...</a><br /></td></tr>
<tr class="separator:ad7b916c550685f48f02b3fd5c97d3f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5504a4c1f4f3d888ed051b1ab90ae4c"><td class="memItemLeft" align="right" valign="top"><a id="ab5504a4c1f4f3d888ed051b1ab90ae4c" name="ab5504a4c1f4f3d888ed051b1ab90ae4c"></a>
idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>print_argloc</b> (char *buf, size_t bufsize, const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;vloc, int size=0, int vflags=0)</td></tr>
<tr class="memdesc:ab5504a4c1f4f3d888ed051b1ab90ae4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an argloc to human readable form. <br /></td></tr>
<tr class="separator:ab5504a4c1f4f3d888ed051b1ab90ae4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c5abb53c08b173798499df9e582fad"><td class="memItemLeft" align="right" valign="top"><a id="ac7c5abb53c08b173798499df9e582fad" name="ac7c5abb53c08b173798499df9e582fad"></a>
idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>for_all_arglocs</b> (<a class="el" href="structaloc__visitor__t.html">aloc_visitor_t</a> &amp;vv, <a class="el" href="classargloc__t.html">argloc_t</a> &amp;vloc, int size, int off=0)</td></tr>
<tr class="memdesc:ac7c5abb53c08b173798499df9e582fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress larger argloc types and initiate the aloc visitor. <br /></td></tr>
<tr class="separator:ac7c5abb53c08b173798499df9e582fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d822a5bc687700adcce53f23f9e7aa"><td class="memItemLeft" align="right" valign="top"><a id="a51d822a5bc687700adcce53f23f9e7aa" name="a51d822a5bc687700adcce53f23f9e7aa"></a>
int idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>for_all_const_arglocs</b> (<a class="el" href="structconst__aloc__visitor__t.html">const_aloc_visitor_t</a> &amp;vv, const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;vloc, int size, int off=0)</td></tr>
<tr class="memdesc:a51d822a5bc687700adcce53f23f9e7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#ac7c5abb53c08b173798499df9e582fad" title="Compress larger argloc types and initiate the aloc visitor.">for_all_arglocs()</a> <br /></td></tr>
<tr class="separator:a51d822a5bc687700adcce53f23f9e7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7c6263a06a6c07c3275783a7e56fe7"><td class="memItemLeft" align="right" valign="top"><a id="a9a7c6263a06a6c07c3275783a7e56fe7" name="a9a7c6263a06a6c07c3275783a7e56fe7"></a>
constexpr <a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_cc</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cm)</td></tr>
<tr class="memdesc:a9a7c6263a06a6c07c3275783a7e56fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the calling convention. <br /></td></tr>
<tr class="separator:a9a7c6263a06a6c07c3275783a7e56fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf87bc5502e9b0ea991dd5cfcfecad1"><td class="memItemLeft" align="right" valign="top"><a id="aaaf87bc5502e9b0ea991dd5cfcfecad1" name="aaaf87bc5502e9b0ea991dd5cfcfecad1"></a>
<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_effective_cc</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cm)</td></tr>
<tr class="memdesc:aaaf87bc5502e9b0ea991dd5cfcfecad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get effective calling convention (with respect to default CC) <br /></td></tr>
<tr class="separator:aaaf87bc5502e9b0ea991dd5cfcfecad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e942ea9058d0e7a54163a846b4a24e"><td class="memItemLeft" align="right" valign="top"><a id="a91e942ea9058d0e7a54163a846b4a24e" name="a91e942ea9058d0e7a54163a846b4a24e"></a>
constexpr <a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_user_cc</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cm)</td></tr>
<tr class="memdesc:a91e942ea9058d0e7a54163a846b4a24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the calling convention specify argument locations explicitly? <br /></td></tr>
<tr class="separator:a91e942ea9058d0e7a54163a846b4a24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219d0c4237c844bd4b826d86449d3e7a"><td class="memItemLeft" align="right" valign="top"><a id="a219d0c4237c844bd4b826d86449d3e7a" name="a219d0c4237c844bd4b826d86449d3e7a"></a>
constexpr <a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_vararg_cc</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cm)</td></tr>
<tr class="memdesc:a219d0c4237c844bd4b826d86449d3e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the calling convention use ellipsis? <br /></td></tr>
<tr class="separator:a219d0c4237c844bd4b826d86449d3e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a79c032d207973a179ca66d4b1061a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ac2a79c032d207973a179ca66d4b1061a">is_purging_cc</a> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cm)</td></tr>
<tr class="memdesc:ac2a79c032d207973a179ca66d4b1061a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the calling convention clean the stack arguments upon return?.  <a href="typeinf_8hpp.html#ac2a79c032d207973a179ca66d4b1061a">More...</a><br /></td></tr>
<tr class="separator:ac2a79c032d207973a179ca66d4b1061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33020c69e2f6b0a4b72f24fd442f965"><td class="memItemLeft" align="right" valign="top"><a id="ae33020c69e2f6b0a4b72f24fd442f965" name="ae33020c69e2f6b0a4b72f24fd442f965"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_golang_cc</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="memdesc:ae33020c69e2f6b0a4b72f24fd442f965"><td class="mdescLeft">&#160;</td><td class="mdescRight">GO language calling convention (return value in stack)? <br /></td></tr>
<tr class="separator:ae33020c69e2f6b0a4b72f24fd442f965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee38a6f103d22cbfcb4bced0882556b9"><td class="memItemLeft" align="right" valign="top"><a id="aee38a6f103d22cbfcb4bced0882556b9" name="aee38a6f103d22cbfcb4bced0882556b9"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_swift_cc</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="memdesc:aee38a6f103d22cbfcb4bced0882556b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swift calling convention (arguments and return values in registers)? <br /></td></tr>
<tr class="separator:aee38a6f103d22cbfcb4bced0882556b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e57a44352ead957bfb35130f120b09"><td class="memItemLeft" align="right" valign="top"><a id="a30e57a44352ead957bfb35130f120b09" name="a30e57a44352ead957bfb35130f120b09"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_comp</b> (<a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a> comp)</td></tr>
<tr class="memdesc:a30e57a44352ead957bfb35130f120b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get compiler bits. <br /></td></tr>
<tr class="separator:a30e57a44352ead957bfb35130f120b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698299149214cdf5cdfedc43acfe1263"><td class="memItemLeft" align="right" valign="top"><a id="a698299149214cdf5cdfedc43acfe1263" name="a698299149214cdf5cdfedc43acfe1263"></a>
idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_compiler_name</b> (<a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a> id)</td></tr>
<tr class="memdesc:a698299149214cdf5cdfedc43acfe1263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full compiler name. <br /></td></tr>
<tr class="separator:a698299149214cdf5cdfedc43acfe1263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd366c63022f4f90dd1a4d41e3883815"><td class="memItemLeft" align="right" valign="top"><a id="afd366c63022f4f90dd1a4d41e3883815" name="afd366c63022f4f90dd1a4d41e3883815"></a>
idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_compiler_abbr</b> (<a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a> id)</td></tr>
<tr class="memdesc:afd366c63022f4f90dd1a4d41e3883815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get abbreviated compiler name. <br /></td></tr>
<tr class="separator:afd366c63022f4f90dd1a4d41e3883815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a99fccffa195ff8572c40f3b4adce85"><td class="memItemLeft" align="right" valign="top"><a id="a0a99fccffa195ff8572c40f3b4adce85" name="a0a99fccffa195ff8572c40f3b4adce85"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_compilers</b> (<a class="el" href="typeinf_8hpp.html#a6d65e448c6e1903b22a2ad528ed9d9d7">compvec_t</a> *ids, <a class="el" href="pro_8h.html#a823b67c620f6cdca97e1d969ea4a9b02">qstrvec_t</a> *names, <a class="el" href="pro_8h.html#a823b67c620f6cdca97e1d969ea4a9b02">qstrvec_t</a> *abbrs)</td></tr>
<tr class="memdesc:a0a99fccffa195ff8572c40f3b4adce85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get names of all built-in compilers. <br /></td></tr>
<tr class="separator:a0a99fccffa195ff8572c40f3b4adce85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e30616c89fad5dfe53c61bb867167a"><td class="memItemLeft" align="right" valign="top"><a id="a66e30616c89fad5dfe53c61bb867167a" name="a66e30616c89fad5dfe53c61bb867167a"></a>
<a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>is_comp_unsure</b> (<a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a> comp)</td></tr>
<tr class="memdesc:a66e30616c89fad5dfe53c61bb867167a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#ae1bdf23b2ef18f213d7b492be498c40e" title="uncertain compiler id">COMP_UNSURE</a>. <br /></td></tr>
<tr class="separator:a66e30616c89fad5dfe53c61bb867167a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c6ee0914c9e229b591dda5bac88abb"><td class="memItemLeft" align="right" valign="top"><a id="a70c6ee0914c9e229b591dda5bac88abb" name="a70c6ee0914c9e229b591dda5bac88abb"></a>
<a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>default_compiler</b> (void)</td></tr>
<tr class="memdesc:a70c6ee0914c9e229b591dda5bac88abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get compiler specified by <a class="el" href="">inf</a>.<a class="el" href="structidainfo.html#afc34ca1c9144e25fd5be9ec6ec13a527">cc</a>. <br /></td></tr>
<tr class="separator:a70c6ee0914c9e229b591dda5bac88abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b0eb16a96e536a92973c27d2b51d04"><td class="memItemLeft" align="right" valign="top"><a id="a33b0eb16a96e536a92973c27d2b51d04" name="a33b0eb16a96e536a92973c27d2b51d04"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_gcc</b> (void)</td></tr>
<tr class="memdesc:a33b0eb16a96e536a92973c27d2b51d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the target compiler <a class="el" href="typeinf_8hpp.html#a8f72af77206ae6e513468b0b2d0d8d7d" title="GNU C++.">COMP_GNU</a>? <br /></td></tr>
<tr class="separator:a33b0eb16a96e536a92973c27d2b51d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5985848fe5433e3906df2a1b9c27634b"><td class="memItemLeft" align="right" valign="top"><a id="a5985848fe5433e3906df2a1b9c27634b" name="a5985848fe5433e3906df2a1b9c27634b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_gcc32</b> (void)</td></tr>
<tr class="memdesc:a5985848fe5433e3906df2a1b9c27634b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the target compiler 32 bit gcc? <br /></td></tr>
<tr class="separator:a5985848fe5433e3906df2a1b9c27634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfe0fce0e36d088e64aba5174bbcf3e"><td class="memItemLeft" align="right" valign="top"><a id="aacfe0fce0e36d088e64aba5174bbcf3e" name="aacfe0fce0e36d088e64aba5174bbcf3e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_gcc64</b> (void)</td></tr>
<tr class="memdesc:aacfe0fce0e36d088e64aba5174bbcf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the target compiler 64 bit gcc? <br /></td></tr>
<tr class="separator:aacfe0fce0e36d088e64aba5174bbcf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba2ea17113115bc15ad1db0134c021a"><td class="memItemLeft" align="right" valign="top"><a id="a3ba2ea17113115bc15ad1db0134c021a" name="a3ba2ea17113115bc15ad1db0134c021a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>gcc_layout</b> (void)</td></tr>
<tr class="memdesc:a3ba2ea17113115bc15ad1db0134c021a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should use the struct/union layout as done by gcc? <br /></td></tr>
<tr class="separator:a3ba2ea17113115bc15ad1db0134c021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f52d4a60168b4f7dab80735397a91"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a405f52d4a60168b4f7dab80735397a91">set_compiler</a> (const <a class="el" href="structcompiler__info__t.html">compiler_info_t</a> &amp;cc, int flags, const char *abiname=nullptr)</td></tr>
<tr class="memdesc:a405f52d4a60168b4f7dab80735397a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change current compiler.  <a href="typeinf_8hpp.html#a405f52d4a60168b4f7dab80735397a91">More...</a><br /></td></tr>
<tr class="separator:a405f52d4a60168b4f7dab80735397a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38861b8baf466c4fa5e67ae3639da30"><td class="memItemLeft" align="right" valign="top"><a id="ae38861b8baf466c4fa5e67ae3639da30" name="ae38861b8baf466c4fa5e67ae3639da30"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>set_compiler_id</b> (<a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a> id, const char *abiname=nullptr)</td></tr>
<tr class="memdesc:ae38861b8baf466c4fa5e67ae3639da30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the compiler id (see <a class="el" href="group___c_o_m_p__.html">Compiler IDs</a>) <br /></td></tr>
<tr class="separator:ae38861b8baf466c4fa5e67ae3639da30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a9e696c4065d281247c57acfccf3c9"><td class="memItemLeft" align="right" valign="top"><a id="a07a9e696c4065d281247c57acfccf3c9" name="a07a9e696c4065d281247c57acfccf3c9"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>set_abi_name</b> (const char *abiname, bool user_level=false)</td></tr>
<tr class="memdesc:a07a9e696c4065d281247c57acfccf3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set abi name (see <a class="el" href="group___c_o_m_p__.html">Compiler IDs</a>) <br /></td></tr>
<tr class="separator:a07a9e696c4065d281247c57acfccf3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574b887360c437eb564122c17a82c4ef"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a574b887360c437eb564122c17a82c4ef">get_abi_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out)</td></tr>
<tr class="memdesc:a574b887360c437eb564122c17a82c4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ABI name.  <a href="typeinf_8hpp.html#a574b887360c437eb564122c17a82c4ef">More...</a><br /></td></tr>
<tr class="separator:a574b887360c437eb564122c17a82c4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac867a63844cbacaf704143a9c52536ee"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ac867a63844cbacaf704143a9c52536ee">append_abi_opts</a> (const char *abi_opts, bool user_level=false)</td></tr>
<tr class="memdesc:ac867a63844cbacaf704143a9c52536ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/remove/check ABI option General form of full abi name: abiname-opt1-opt2-... or -opt1-opt2-...  <a href="typeinf_8hpp.html#ac867a63844cbacaf704143a9c52536ee">More...</a><br /></td></tr>
<tr class="separator:ac867a63844cbacaf704143a9c52536ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdf0af38218418e61b04ec2ee813542"><td class="memItemLeft" align="right" valign="top"><a id="a5cdf0af38218418e61b04ec2ee813542" name="a5cdf0af38218418e61b04ec2ee813542"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>remove_abi_opts</b> (const char *abi_opts, bool user_level=false)</td></tr>
<tr class="separator:a5cdf0af38218418e61b04ec2ee813542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5949346c28023a7823aa3e481f6a72"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a0c5949346c28023a7823aa3e481f6a72">set_compiler_string</a> (const char *compstr, bool user_level)</td></tr>
<tr class="separator:a0c5949346c28023a7823aa3e481f6a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3190b160fe8fec87e9f06c6ca15fe06"><td class="memItemLeft" align="right" valign="top"><a id="ab3190b160fe8fec87e9f06c6ca15fe06" name="ab3190b160fe8fec87e9f06c6ca15fe06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_golang_cc</b> (void)</td></tr>
<tr class="memdesc:ab3190b160fe8fec87e9f06c6ca15fe06"><td class="mdescLeft">&#160;</td><td class="mdescRight">is GOLANG calling convention used by default? <br /></td></tr>
<tr class="separator:ab3190b160fe8fec87e9f06c6ca15fe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4083f2c0935c96d192c5762d4f0c218"><td class="memItemLeft" align="right" valign="top"><a id="af4083f2c0935c96d192c5762d4f0c218" name="af4083f2c0935c96d192c5762d4f0c218"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>switch_to_golang</b> (void)</td></tr>
<tr class="memdesc:af4083f2c0935c96d192c5762d4f0c218"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch to GOLANG calling convention (to be used as default CC) <br /></td></tr>
<tr class="separator:af4083f2c0935c96d192c5762d4f0c218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2c9c8787240c725a87bb5cb5ffc7a4"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a6a2c9c8787240c725a87bb5cb5ffc7a4">h2ti</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, lexer_t *lx, const char *input, int flags=<a class="el" href="typeinf_8hpp.html#a1a2d19a5da522effe48cfe67e14fc479">HTI_HIGH</a>, <a class="el" href="typeinf_8hpp.html#a034013ece7194a003ffd1727075100d2">h2ti_type_cb</a> *type_cb=nullptr, <a class="el" href="typeinf_8hpp.html#a034013ece7194a003ffd1727075100d2">h2ti_type_cb</a> *var_cb=nullptr, <a class="el" href="typeinf_8hpp.html#abcc521f1e3d068d8cdf760885a8f53c4">printer_t</a> *print_cb=nullptr, void *_cb_data=nullptr, <a class="el" href="typeinf_8hpp.html#a784254a39507ac759a9f373a52a75ac1">abs_t</a> _isabs=abs_unk)</td></tr>
<tr class="memdesc:a6a2c9c8787240c725a87bb5cb5ffc7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert declarations to type_t*.  <a href="typeinf_8hpp.html#a6a2c9c8787240c725a87bb5cb5ffc7a4">More...</a><br /></td></tr>
<tr class="separator:a6a2c9c8787240c725a87bb5cb5ffc7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ec4302201c52b95420edc3618b7eb2"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aa3ec4302201c52b95420edc3618b7eb2">parse_decl</a> (<a class="el" href="classtinfo__t.html">tinfo_t</a> *tif, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, <a class="el" href="structtil__t.html">til_t</a> *til, const char *decl, int flags)</td></tr>
<tr class="memdesc:aa3ec4302201c52b95420edc3618b7eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse ONE declaration.  <a href="typeinf_8hpp.html#aa3ec4302201c52b95420edc3618b7eb2">More...</a><br /></td></tr>
<tr class="separator:aa3ec4302201c52b95420edc3618b7eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfe2fcd29fba4ba9fe6da62bbbf4fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aedfe2fcd29fba4ba9fe6da62bbbf4fa5">convert_pt_flags_to_hti</a> (int pt_flags)</td></tr>
<tr class="memdesc:aedfe2fcd29fba4ba9fe6da62bbbf4fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="group___p_t__.html">Type parsing flags</a> to <a class="el" href="group___h_t_i__.html">Type formatting flags</a>.  <a href="typeinf_8hpp.html#aedfe2fcd29fba4ba9fe6da62bbbf4fa5">More...</a><br /></td></tr>
<tr class="separator:aedfe2fcd29fba4ba9fe6da62bbbf4fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cec61d812cfc0acc08453742b729b3"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ae4cec61d812cfc0acc08453742b729b3">parse_decls</a> (<a class="el" href="structtil__t.html">til_t</a> *til, const char *input, <a class="el" href="typeinf_8hpp.html#abcc521f1e3d068d8cdf760885a8f53c4">printer_t</a> *printer, int hti_flags)</td></tr>
<tr class="memdesc:ae4cec61d812cfc0acc08453742b729b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse many declarations and store them in a til.  <a href="typeinf_8hpp.html#ae4cec61d812cfc0acc08453742b729b3">More...</a><br /></td></tr>
<tr class="separator:ae4cec61d812cfc0acc08453742b729b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ef73f0df2c860b554c5fef7ce273f3"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a43ef73f0df2c860b554c5fef7ce273f3">print_type</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int prtype_flags)</td></tr>
<tr class="memdesc:a43ef73f0df2c860b554c5fef7ce273f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type declaration for the specified address.  <a href="typeinf_8hpp.html#a43ef73f0df2c860b554c5fef7ce273f3">More...</a><br /></td></tr>
<tr class="separator:a43ef73f0df2c860b554c5fef7ce273f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a479446982028dbaf97c024d16c1ec"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ac0a479446982028dbaf97c024d16c1ec">get_named_type</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, const char *name, int ntf_flags, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **type=nullptr, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **fields=nullptr, const char **cmt=nullptr, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **fieldcmts=nullptr, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *sclass=nullptr, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *value=nullptr)</td></tr>
<tr class="memdesc:ac0a479446982028dbaf97c024d16c1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get named typeinfo.  <a href="typeinf_8hpp.html#ac0a479446982028dbaf97c024d16c1ec">More...</a><br /></td></tr>
<tr class="separator:ac0a479446982028dbaf97c024d16c1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb5b90319ad6850988d7f7e42b0fa08"><td class="memItemLeft" align="right" valign="top">int idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#abfb5b90319ad6850988d7f7e42b0fa08">get_named_type64</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, const char *name, int ntf_flags, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **type=nullptr, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **fields=nullptr, const char **cmt=nullptr, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **fieldcmts=nullptr, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *sclass=nullptr, uint64 *value=nullptr)</td></tr>
<tr class="memdesc:abfb5b90319ad6850988d7f7e42b0fa08"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="typeinf_8hpp.html#ac0a479446982028dbaf97c024d16c1ec" title="Get named typeinfo.">get_named_type()</a> above.  <a href="typeinf_8hpp.html#abfb5b90319ad6850988d7f7e42b0fa08">More...</a><br /></td></tr>
<tr class="separator:abfb5b90319ad6850988d7f7e42b0fa08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1790476ab86ed2767f5c9c81ec3274ff"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a1790476ab86ed2767f5c9c81ec3274ff">del_named_type</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, const char *name, int ntf_flags)</td></tr>
<tr class="memdesc:a1790476ab86ed2767f5c9c81ec3274ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete information about a symbol.  <a href="typeinf_8hpp.html#a1790476ab86ed2767f5c9c81ec3274ff">More...</a><br /></td></tr>
<tr class="separator:a1790476ab86ed2767f5c9c81ec3274ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ef86a47794fe3a1b765454a0567dc0"><td class="memItemLeft" align="right" valign="top">idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a40ef86a47794fe3a1b765454a0567dc0">first_named_type</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, int ntf_flags)</td></tr>
<tr class="memdesc:a40ef86a47794fe3a1b765454a0567dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate types.  <a href="typeinf_8hpp.html#a40ef86a47794fe3a1b765454a0567dc0">More...</a><br /></td></tr>
<tr class="separator:a40ef86a47794fe3a1b765454a0567dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d283260144ac0abe789384d2c06e10"><td class="memItemLeft" align="right" valign="top">idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a18d283260144ac0abe789384d2c06e10">next_named_type</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, const char *name, int ntf_flags)</td></tr>
<tr class="memdesc:a18d283260144ac0abe789384d2c06e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate types.  <a href="typeinf_8hpp.html#a18d283260144ac0abe789384d2c06e10">More...</a><br /></td></tr>
<tr class="separator:a18d283260144ac0abe789384d2c06e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb8bcab798445a464639d699b6126f"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ad7fb8bcab798445a464639d699b6126f">copy_named_type</a> (<a class="el" href="structtil__t.html">til_t</a> *dsttil, const <a class="el" href="structtil__t.html">til_t</a> *srctil, const char *name)</td></tr>
<tr class="memdesc:ad7fb8bcab798445a464639d699b6126f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a named type from one til to another.  <a href="typeinf_8hpp.html#ad7fb8bcab798445a464639d699b6126f">More...</a><br /></td></tr>
<tr class="separator:ad7fb8bcab798445a464639d699b6126f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefdfe7cb059b39bfd6650f63a83cc44"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aaefdfe7cb059b39bfd6650f63a83cc44">decorate_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const char *name, bool mangle, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc=<a class="el" href="typeinf_8hpp.html#a1d8607c930b67577c7f39ac7a5d24612">CM_CC_UNKNOWN</a>, const <a class="el" href="classtinfo__t.html">tinfo_t</a> *type=nullptr)</td></tr>
<tr class="memdesc:aaefdfe7cb059b39bfd6650f63a83cc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorate/undecorate a C symbol name.  <a href="typeinf_8hpp.html#aaefdfe7cb059b39bfd6650f63a83cc44">More...</a><br /></td></tr>
<tr class="separator:aaefdfe7cb059b39bfd6650f63a83cc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cf1ca0ea27834794b8034bc86a7087"><td class="memItemLeft" align="right" valign="top"><a id="ad6cf1ca0ea27834794b8034bc86a7087" name="ad6cf1ca0ea27834794b8034bc86a7087"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>gen_decorate_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const char *name, bool mangle, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc, const <a class="el" href="classtinfo__t.html">tinfo_t</a> *type)</td></tr>
<tr class="memdesc:ad6cf1ca0ea27834794b8034bc86a7087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic function for <a class="el" href="typeinf_8hpp.html#aaefdfe7cb059b39bfd6650f63a83cc44" title="Decorate/undecorate a C symbol name.">decorate_name()</a> (may be used in IDP modules) <br /></td></tr>
<tr class="separator:ad6cf1ca0ea27834794b8034bc86a7087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059b898c85f397e3aadf4c409ec66c59"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a059b898c85f397e3aadf4c409ec66c59">calc_c_cpp_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const char *name, const <a class="el" href="classtinfo__t.html">tinfo_t</a> *type, int ccn_flags)</td></tr>
<tr class="memdesc:a059b898c85f397e3aadf4c409ec66c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get C or C++ form of the name.  <a href="typeinf_8hpp.html#a059b898c85f397e3aadf4c409ec66c59">More...</a><br /></td></tr>
<tr class="separator:a059b898c85f397e3aadf4c409ec66c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fb33088b41c01ab02e1d7739ae3d67"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ab1fb33088b41c01ab02e1d7739ae3d67">enable_numbered_types</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, bool enable)</td></tr>
<tr class="memdesc:ab1fb33088b41c01ab02e1d7739ae3d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the use of numbered types in til.  <a href="typeinf_8hpp.html#ab1fb33088b41c01ab02e1d7739ae3d67">More...</a><br /></td></tr>
<tr class="separator:ab1fb33088b41c01ab02e1d7739ae3d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad3dddd2ed8e1168905f00512914bb0"><td class="memItemLeft" align="right" valign="top"><a id="a7ad3dddd2ed8e1168905f00512914bb0" name="a7ad3dddd2ed8e1168905f00512914bb0"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_numbered_type</b> (const <a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **type=nullptr, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **fields=nullptr, const char **cmt=nullptr, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **fieldcmts=nullptr, <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *sclass=nullptr)</td></tr>
<tr class="memdesc:a7ad3dddd2ed8e1168905f00512914bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a type by its ordinal number. <br /></td></tr>
<tr class="separator:a7ad3dddd2ed8e1168905f00512914bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7a68bdec901b7fbf1c0bf324ddf126"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a1f7a68bdec901b7fbf1c0bf324ddf126">alloc_type_ordinals</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, int qty)</td></tr>
<tr class="memdesc:a1f7a68bdec901b7fbf1c0bf324ddf126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a range of ordinal numbers for new types.  <a href="typeinf_8hpp.html#a1f7a68bdec901b7fbf1c0bf324ddf126">More...</a><br /></td></tr>
<tr class="separator:a1f7a68bdec901b7fbf1c0bf324ddf126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e79e63d11375aa35947c987ee15931"><td class="memItemLeft" align="right" valign="top"><a id="a42e79e63d11375aa35947c987ee15931" name="a42e79e63d11375aa35947c987ee15931"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_type_ordinal</b> (<a class="el" href="structtil__t.html">til_t</a> *ti)</td></tr>
<tr class="memdesc:a42e79e63d11375aa35947c987ee15931"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a1f7a68bdec901b7fbf1c0bf324ddf126">alloc_type_ordinals</a>(ti, 1) <br /></td></tr>
<tr class="separator:a42e79e63d11375aa35947c987ee15931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac850f1c54d5b4c607d64ddf76691814f"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ac850f1c54d5b4c607d64ddf76691814f">get_ordinal_qty</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti)</td></tr>
<tr class="memdesc:ac850f1c54d5b4c607d64ddf76691814f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of allocated ordinals.  <a href="typeinf_8hpp.html#ac850f1c54d5b4c607d64ddf76691814f">More...</a><br /></td></tr>
<tr class="separator:ac850f1c54d5b4c607d64ddf76691814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a0388e87ce32020d71754d8b63475"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaa">tinfo_code_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ab19a0388e87ce32020d71754d8b63475">set_numbered_type</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal, int ntf_flags, const char *name, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *fields=nullptr, const char *cmt=nullptr, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *fldcmts=nullptr, const <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *sclass=nullptr)</td></tr>
<tr class="memdesc:ab19a0388e87ce32020d71754d8b63475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a type in the til.  <a href="typeinf_8hpp.html#ab19a0388e87ce32020d71754d8b63475">More...</a><br /></td></tr>
<tr class="separator:ab19a0388e87ce32020d71754d8b63475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cf655e113e97c7d0abc8d42e7e98f4"><td class="memItemLeft" align="right" valign="top"><a id="a63cf655e113e97c7d0abc8d42e7e98f4" name="a63cf655e113e97c7d0abc8d42e7e98f4"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>del_numbered_type</b> (<a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal)</td></tr>
<tr class="memdesc:a63cf655e113e97c7d0abc8d42e7e98f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a numbered type. <br /></td></tr>
<tr class="separator:a63cf655e113e97c7d0abc8d42e7e98f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa083016ad05fe5db5b57b25a98cf9d7"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aaa083016ad05fe5db5b57b25a98cf9d7">set_type_alias</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> src_ordinal, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> dst_ordinal)</td></tr>
<tr class="memdesc:aaa083016ad05fe5db5b57b25a98cf9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a type alias.  <a href="typeinf_8hpp.html#aaa083016ad05fe5db5b57b25a98cf9d7">More...</a><br /></td></tr>
<tr class="separator:aaa083016ad05fe5db5b57b25a98cf9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3df2e4834eeaf173579f92c5feb3b88"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aa3df2e4834eeaf173579f92c5feb3b88">get_alias_target</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal)</td></tr>
<tr class="memdesc:aa3df2e4834eeaf173579f92c5feb3b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the final alias destination.  <a href="typeinf_8hpp.html#aa3df2e4834eeaf173579f92c5feb3b88">More...</a><br /></td></tr>
<tr class="separator:aa3df2e4834eeaf173579f92c5feb3b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfef9d7f364161c2e81b5f72dd0acf3"><td class="memItemLeft" align="right" valign="top"><a id="a3cfef9d7f364161c2e81b5f72dd0acf3" name="a3cfef9d7f364161c2e81b5f72dd0acf3"></a>
idaman <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_type_ordinal</b> (const <a class="el" href="structtil__t.html">til_t</a> *ti, const char *name)</td></tr>
<tr class="memdesc:a3cfef9d7f364161c2e81b5f72dd0acf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type ordinal by its name. <br /></td></tr>
<tr class="separator:a3cfef9d7f364161c2e81b5f72dd0acf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb6476f1e89831facd6b8375a3cf9b0"><td class="memItemLeft" align="right" valign="top">idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a5eb6476f1e89831facd6b8375a3cf9b0">get_numbered_type_name</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal)</td></tr>
<tr class="memdesc:a5eb6476f1e89831facd6b8375a3cf9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type name (if exists) by its ordinal.  <a href="typeinf_8hpp.html#a5eb6476f1e89831facd6b8375a3cf9b0">More...</a><br /></td></tr>
<tr class="separator:a5eb6476f1e89831facd6b8375a3cf9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ed1d69ef90da349923a780f84f851a"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ab5ed1d69ef90da349923a780f84f851a">create_numbered_type_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> ord)</td></tr>
<tr class="memdesc:ab5ed1d69ef90da349923a780f84f851a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create anonymous name for numbered type.  <a href="typeinf_8hpp.html#ab5ed1d69ef90da349923a780f84f851a">More...</a><br /></td></tr>
<tr class="separator:ab5ed1d69ef90da349923a780f84f851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002eef2e97e56cb3a2bddaf6fdc70720"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a002eef2e97e56cb3a2bddaf6fdc70720">is_ordinal_name</a> (const char *name, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *ord=nullptr)</td></tr>
<tr class="memdesc:a002eef2e97e56cb3a2bddaf6fdc70720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the name is an ordinal name.  <a href="typeinf_8hpp.html#a002eef2e97e56cb3a2bddaf6fdc70720">More...</a><br /></td></tr>
<tr class="separator:a002eef2e97e56cb3a2bddaf6fdc70720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c7701a03bd988d81f5ed27d2f5bb39"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#af4c7701a03bd988d81f5ed27d2f5bb39">get_ordinal_from_idb_type</a> (const char *name, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="memdesc:af4c7701a03bd988d81f5ed27d2f5bb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ordinal number of an idb type (struct/enum).  <a href="typeinf_8hpp.html#af4c7701a03bd988d81f5ed27d2f5bb39">More...</a><br /></td></tr>
<tr class="separator:af4c7701a03bd988d81f5ed27d2f5bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3437c158380092035b7cae165d7512fd"><td class="memItemLeft" align="right" valign="top"><a id="a3437c158380092035b7cae165d7512fd" name="a3437c158380092035b7cae165d7512fd"></a>
bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>is_autosync</b> (const char *name, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type)</td></tr>
<tr class="memdesc:a3437c158380092035b7cae165d7512fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the specified idb type automatically synchronized? <br /></td></tr>
<tr class="separator:a3437c158380092035b7cae165d7512fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a920a13cb45e4731cd68b7d2556588"><td class="memItemLeft" align="right" valign="top">bool idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a55a920a13cb45e4731cd68b7d2556588">is_autosync</a> (const char *name, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif)</td></tr>
<tr class="memdesc:a55a920a13cb45e4731cd68b7d2556588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the specified idb type automatically synchronized?  <a href="typeinf_8hpp.html#a55a920a13cb45e4731cd68b7d2556588">More...</a><br /></td></tr>
<tr class="separator:a55a920a13cb45e4731cd68b7d2556588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600c885cb0b722c6f392bf83f467442a"><td class="memItemLeft" align="right" valign="top"><a id="a600c885cb0b722c6f392bf83f467442a" name="a600c885cb0b722c6f392bf83f467442a"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>build_anon_type_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *type, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *fields)</td></tr>
<tr class="memdesc:a600c885cb0b722c6f392bf83f467442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a name like $hex_numbers based on the field types and names. <br /></td></tr>
<tr class="separator:a600c885cb0b722c6f392bf83f467442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af305520e0b262734feb77427f981d0b1"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#af305520e0b262734feb77427f981d0b1">compact_numbered_types</a> (<a class="el" href="structtil__t.html">til_t</a> *ti, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> min_ord=0, <a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *p_ordmap=nullptr, int flags=0)</td></tr>
<tr class="memdesc:af305520e0b262734feb77427f981d0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact numbered types to get rid of empty slots.  <a href="typeinf_8hpp.html#af305520e0b262734feb77427f981d0b1">More...</a><br /></td></tr>
<tr class="separator:af305520e0b262734feb77427f981d0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd359fb673ce2e937b4c85940f3b000"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#afcd359fb673ce2e937b4c85940f3b000">get_vftable_ea</a> (<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal)</td></tr>
<tr class="memdesc:afcd359fb673ce2e937b4c85940f3b000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of a virtual function table.  <a href="typeinf_8hpp.html#afcd359fb673ce2e937b4c85940f3b000">More...</a><br /></td></tr>
<tr class="separator:afcd359fb673ce2e937b4c85940f3b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71850d781ec15055dc73866eec6dbd7c"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a71850d781ec15055dc73866eec6dbd7c">get_vftable_ordinal</a> (ea_t vftable_ea)</td></tr>
<tr class="memdesc:a71850d781ec15055dc73866eec6dbd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ordinal number of the virtual function table.  <a href="typeinf_8hpp.html#a71850d781ec15055dc73866eec6dbd7c">More...</a><br /></td></tr>
<tr class="separator:a71850d781ec15055dc73866eec6dbd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc21cee00f0adc8357d5b68cc826db3e"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#afc21cee00f0adc8357d5b68cc826db3e">set_vftable_ea</a> (<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal, ea_t vftable_ea)</td></tr>
<tr class="memdesc:afc21cee00f0adc8357d5b68cc826db3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the address of a vftable instance for a vftable type.  <a href="typeinf_8hpp.html#afc21cee00f0adc8357d5b68cc826db3e">More...</a><br /></td></tr>
<tr class="separator:afc21cee00f0adc8357d5b68cc826db3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182186fb0925ce1dddd7f5756892ae90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a182186fb0925ce1dddd7f5756892ae90">del_vftable_ea</a> (<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal)</td></tr>
<tr class="memdesc:a182186fb0925ce1dddd7f5756892ae90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the address of a vftable instance for a vftable type.  <a href="typeinf_8hpp.html#a182186fb0925ce1dddd7f5756892ae90">More...</a><br /></td></tr>
<tr class="separator:a182186fb0925ce1dddd7f5756892ae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370b5b72b6b9d2935babdd8dbb98bfdf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a370b5b72b6b9d2935babdd8dbb98bfdf">get_default_align</a> (void)</td></tr>
<tr class="memdesc:a370b5b72b6b9d2935babdd8dbb98bfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default alignment for structure fields.  <a href="typeinf_8hpp.html#a370b5b72b6b9d2935babdd8dbb98bfdf">More...</a><br /></td></tr>
<tr class="separator:a370b5b72b6b9d2935babdd8dbb98bfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7ab0213381511f40cc337d22b32e7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a6e7ab0213381511f40cc337d22b32e7f">align_size</a> (size_t &amp;cur_tot_size, size_t elem_size, size_t algn)</td></tr>
<tr class="memdesc:a6e7ab0213381511f40cc337d22b32e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get alignment delta for the a structure field.  <a href="typeinf_8hpp.html#a6e7ab0213381511f40cc337d22b32e7f">More...</a><br /></td></tr>
<tr class="separator:a6e7ab0213381511f40cc337d22b32e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73622568bcc491371a33367403e3e045"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a73622568bcc491371a33367403e3e045">deref_ptr</a> (ea_t *ptr_ea, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, ea_t *closure_obj=nullptr)</td></tr>
<tr class="memdesc:a73622568bcc491371a33367403e3e045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference a pointer.  <a href="typeinf_8hpp.html#a73622568bcc491371a33367403e3e045">More...</a><br /></td></tr>
<tr class="separator:a73622568bcc491371a33367403e3e045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38ec35fd1105a5ff2f5f8f157f41e57"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ab38ec35fd1105a5ff2f5f8f157f41e57">remove_tinfo_pointer</a> (<a class="el" href="classtinfo__t.html">tinfo_t</a> *tif, const char **pname, const <a class="el" href="structtil__t.html">til_t</a> *til=nullptr)</td></tr>
<tr class="memdesc:ab38ec35fd1105a5ff2f5f8f157f41e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove pointer of a type.  <a href="typeinf_8hpp.html#ab38ec35fd1105a5ff2f5f8f157f41e57">More...</a><br /></td></tr>
<tr class="separator:ab38ec35fd1105a5ff2f5f8f157f41e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df9cceb079c76e3c2b7879c763eadea"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a8df9cceb079c76e3c2b7879c763eadea">import_type</a> (const <a class="el" href="structtil__t.html">til_t</a> *til, int idx, const char *name, int flags=0)</td></tr>
<tr class="memdesc:a8df9cceb079c76e3c2b7879c763eadea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a named type from til to idb.  <a href="typeinf_8hpp.html#a8df9cceb079c76e3c2b7879c763eadea">More...</a><br /></td></tr>
<tr class="separator:a8df9cceb079c76e3c2b7879c763eadea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3c9ab321e5107e8ba4df22de3fcbf"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a6ae3c9ab321e5107e8ba4df22de3fcbf">add_til</a> (const char *name, int flags)</td></tr>
<tr class="memdesc:a6ae3c9ab321e5107e8ba4df22de3fcbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a til file and add it the database type libraries list.  <a href="typeinf_8hpp.html#a6ae3c9ab321e5107e8ba4df22de3fcbf">More...</a><br /></td></tr>
<tr class="separator:a6ae3c9ab321e5107e8ba4df22de3fcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa06050d6cd990f851d24585f8b4d6d"><td class="memItemLeft" align="right" valign="top"><a id="a1aa06050d6cd990f851d24585f8b4d6d" name="a1aa06050d6cd990f851d24585f8b4d6d"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>del_til</b> (const char *name)</td></tr>
<tr class="memdesc:a1aa06050d6cd990f851d24585f8b4d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload a til file. <br /></td></tr>
<tr class="separator:a1aa06050d6cd990f851d24585f8b4d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce12846fdd890614f618c553fcebc2"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a07ce12846fdd890614f618c553fcebc2">apply_named_type</a> (ea_t ea, const char *name)</td></tr>
<tr class="memdesc:a07ce12846fdd890614f618c553fcebc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the specified named type to the address.  <a href="typeinf_8hpp.html#a07ce12846fdd890614f618c553fcebc2">More...</a><br /></td></tr>
<tr class="separator:a07ce12846fdd890614f618c553fcebc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2fbecf8fbab5dbd9ea0510d82b7e99"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a5d2fbecf8fbab5dbd9ea0510d82b7e99">apply_tinfo</a> (ea_t ea, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> flags)</td></tr>
<tr class="memdesc:a5d2fbecf8fbab5dbd9ea0510d82b7e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the specified type to the specified address.  <a href="typeinf_8hpp.html#a5d2fbecf8fbab5dbd9ea0510d82b7e99">More...</a><br /></td></tr>
<tr class="separator:a5d2fbecf8fbab5dbd9ea0510d82b7e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546009cb5f00edba6fbbfd876787b9a0"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a546009cb5f00edba6fbbfd876787b9a0">apply_cdecl</a> (<a class="el" href="structtil__t.html">til_t</a> *til, ea_t ea, const char *decl, int flags=0)</td></tr>
<tr class="memdesc:a546009cb5f00edba6fbbfd876787b9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the specified type to the address.  <a href="typeinf_8hpp.html#a546009cb5f00edba6fbbfd876787b9a0">More...</a><br /></td></tr>
<tr class="separator:a546009cb5f00edba6fbbfd876787b9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c3dc99b159f2f1bc3d07d897885ccd"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ad1c3dc99b159f2f1bc3d07d897885ccd">apply_callee_tinfo</a> (ea_t caller, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif)</td></tr>
<tr class="memdesc:ad1c3dc99b159f2f1bc3d07d897885ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the type of the called function to the calling instruction.  <a href="typeinf_8hpp.html#ad1c3dc99b159f2f1bc3d07d897885ccd">More...</a><br /></td></tr>
<tr class="separator:ad1c3dc99b159f2f1bc3d07d897885ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef863a47c0208d367489126c4a8ae6a"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a7ef863a47c0208d367489126c4a8ae6a">get_arg_addrs</a> (<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> *out, ea_t caller)</td></tr>
<tr class="memdesc:a7ef863a47c0208d367489126c4a8ae6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve argument initialization addresses.  <a href="typeinf_8hpp.html#a7ef863a47c0208d367489126c4a8ae6a">More...</a><br /></td></tr>
<tr class="separator:a7ef863a47c0208d367489126c4a8ae6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ae24e34543c7d43021db7907758c89"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ac2ae24e34543c7d43021db7907758c89">apply_once_tinfo_and_name</a> (ea_t dea, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, const char *name)</td></tr>
<tr class="memdesc:ac2ae24e34543c7d43021db7907758c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the specified type and name to the address.  <a href="typeinf_8hpp.html#ac2ae24e34543c7d43021db7907758c89">More...</a><br /></td></tr>
<tr class="separator:ac2ae24e34543c7d43021db7907758c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faae87435a3adfade45003c4df6c62d"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a1faae87435a3adfade45003c4df6c62d">guess_tinfo</a> (<a class="el" href="classtinfo__t.html">tinfo_t</a> *tif, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> id)</td></tr>
<tr class="memdesc:a1faae87435a3adfade45003c4df6c62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a type information about the id from the disassembly.  <a href="typeinf_8hpp.html#a1faae87435a3adfade45003c4df6c62d">More...</a><br /></td></tr>
<tr class="separator:a1faae87435a3adfade45003c4df6c62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f29f873aebcf7aa451a9a295dde236"><td class="memItemLeft" align="right" valign="top"><a id="a23f29f873aebcf7aa451a9a295dde236" name="a23f29f873aebcf7aa451a9a295dde236"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_c_header_path</b> (const char *incdir)</td></tr>
<tr class="memdesc:a23f29f873aebcf7aa451a9a295dde236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set include directory path the target compiler. <br /></td></tr>
<tr class="separator:a23f29f873aebcf7aa451a9a295dde236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225608f4fed360094a2dee5eaf233d14"><td class="memItemLeft" align="right" valign="top"><a id="a225608f4fed360094a2dee5eaf233d14" name="a225608f4fed360094a2dee5eaf233d14"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_c_header_path</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf)</td></tr>
<tr class="memdesc:a225608f4fed360094a2dee5eaf233d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the include directory path of the target compiler. <br /></td></tr>
<tr class="separator:a225608f4fed360094a2dee5eaf233d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab968ece62fa1b6e22edf0caca4de4109"><td class="memItemLeft" align="right" valign="top"><a id="ab968ece62fa1b6e22edf0caca4de4109" name="ab968ece62fa1b6e22edf0caca4de4109"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_c_macros</b> (const char *macros)</td></tr>
<tr class="memdesc:ab968ece62fa1b6e22edf0caca4de4109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set predefined macros for the target compiler. <br /></td></tr>
<tr class="separator:ab968ece62fa1b6e22edf0caca4de4109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f696742665f2c9166b5bd50b27878c6"><td class="memItemLeft" align="right" valign="top"><a id="a6f696742665f2c9166b5bd50b27878c6" name="a6f696742665f2c9166b5bd50b27878c6"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_c_macros</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf)</td></tr>
<tr class="memdesc:a6f696742665f2c9166b5bd50b27878c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get predefined macros for the target compiler. <br /></td></tr>
<tr class="separator:a6f696742665f2c9166b5bd50b27878c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398db0b3716d46018b5792570d31a852"><td class="memItemLeft" align="right" valign="top">idaman const <a class="el" href="structtil__t.html">til_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a398db0b3716d46018b5792570d31a852">get_idati</a> (void)</td></tr>
<tr class="memdesc:a398db0b3716d46018b5792570d31a852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the local type library - this til is private for each IDB file Function that accepts til_t* uses local type library instead of nullptr.  <a href="typeinf_8hpp.html#a398db0b3716d46018b5792570d31a852">More...</a><br /></td></tr>
<tr class="separator:a398db0b3716d46018b5792570d31a852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4a22a1d0d16ee4eede061b00fd700a"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ade4a22a1d0d16ee4eede061b00fd700a">get_idainfo_by_type</a> (size_t *out_size, <a class="el" href="pro_8h.html#a55dd00e03168fb5180830e87ef0a2c57">flags_t</a> *out_flags, <a class="el" href="unionopinfo__t.html">opinfo_t</a> *out_mt, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, size_t *out_alsize=nullptr)</td></tr>
<tr class="memdesc:ade4a22a1d0d16ee4eede061b00fd700a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract information from a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>.  <a href="typeinf_8hpp.html#ade4a22a1d0d16ee4eede061b00fd700a">More...</a><br /></td></tr>
<tr class="separator:ade4a22a1d0d16ee4eede061b00fd700a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfe6d3378d47ae36d78b8d99079e0eb"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a4dfe6d3378d47ae36d78b8d99079e0eb">get_idainfo64_by_type</a> (size_t *out_size, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> *out_flags, <a class="el" href="unionopinfo__t.html">opinfo_t</a> *out_mt, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, size_t *out_alsize=nullptr)</td></tr>
<tr class="memdesc:a4dfe6d3378d47ae36d78b8d99079e0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract information from a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>.  <a href="typeinf_8hpp.html#a4dfe6d3378d47ae36d78b8d99079e0eb">More...</a><br /></td></tr>
<tr class="separator:a4dfe6d3378d47ae36d78b8d99079e0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b3edb11f2772224b157750a2c95f77"><td class="memItemLeft" align="right" valign="top"><a id="a88b3edb11f2772224b157750a2c95f77" name="a88b3edb11f2772224b157750a2c95f77"></a>
idaman <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>guess_func_cc</b> (const <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> &amp;fti, int npurged, int cc_flags)</td></tr>
<tr class="memdesc:a88b3edb11f2772224b157750a2c95f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="structfunc__type__data__t.html#abbe3746b3c724ebff39a901ae4660a5f" title="Guess function calling convention use the following info: argument locations and &#39;stkargs&#39;.">func_type_data_t::guess_cc()</a> <br /></td></tr>
<tr class="separator:a88b3edb11f2772224b157750a2c95f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8b887ecb9fde0f20a2d5595e87ce99"><td class="memItemLeft" align="right" valign="top"><a id="a4c8b887ecb9fde0f20a2d5595e87ce99" name="a4c8b887ecb9fde0f20a2d5595e87ce99"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>dump_func_type_data</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> &amp;fti, int praloc_bits)</td></tr>
<tr class="memdesc:a4c8b887ecb9fde0f20a2d5595e87ce99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="structfunc__type__data__t.html#ae579895c3994102621b42363fd22e3a9" title="Dump information that is not always visible in the function prototype.">func_type_data_t::dump()</a> <br /></td></tr>
<tr class="separator:a4c8b887ecb9fde0f20a2d5595e87ce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f598eaf3c86638d017a02c569ebb18"><td class="memItemLeft" align="right" valign="top"><a id="a46f598eaf3c86638d017a02c569ebb18" name="a46f598eaf3c86638d017a02c569ebb18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>inf_pack_stkargs</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="separator:a46f598eaf3c86638d017a02c569ebb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3365491b829eb0dd3ddbbc7f122ae90d"><td class="memItemLeft" align="right" valign="top"><a id="a3365491b829eb0dd3ddbbc7f122ae90d" name="a3365491b829eb0dd3ddbbc7f122ae90d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>inf_big_arg_align</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="separator:a3365491b829eb0dd3ddbbc7f122ae90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1e68621a8d1bf1d209aa28b2694805"><td class="memItemLeft" align="right" valign="top"><a id="abc1e68621a8d1bf1d209aa28b2694805" name="abc1e68621a8d1bf1d209aa28b2694805"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>inf_huge_arg_align</b> (<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc)</td></tr>
<tr class="separator:abc1e68621a8d1bf1d209aa28b2694805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bdf965e322f0a7c2ca9e9c63d4018a"><td class="memItemLeft" align="right" valign="top"><a id="aa7bdf965e322f0a7c2ca9e9c63d4018a" name="aa7bdf965e322f0a7c2ca9e9c63d4018a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_arg_align</b> (int type_align, int slotsize, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc=<a class="el" href="typeinf_8hpp.html#a1d8607c930b67577c7f39ac7a5d24612">CM_CC_UNKNOWN</a>)</td></tr>
<tr class="separator:aa7bdf965e322f0a7c2ca9e9c63d4018a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ae1f3cdb9bfa0f924a2af47fa37346"><td class="memItemLeft" align="right" valign="top"><a id="a06ae1f3cdb9bfa0f924a2af47fa37346" name="a06ae1f3cdb9bfa0f924a2af47fa37346"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_arg_align</b> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, int slotsize, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc=<a class="el" href="typeinf_8hpp.html#a1d8607c930b67577c7f39ac7a5d24612">CM_CC_UNKNOWN</a>)</td></tr>
<tr class="separator:a06ae1f3cdb9bfa0f924a2af47fa37346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f69d6c26ab4d44a060c297152e3b55f"><td class="memItemLeft" align="right" valign="top"><a id="a3f69d6c26ab4d44a060c297152e3b55f" name="a3f69d6c26ab4d44a060c297152e3b55f"></a>
<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>align_stkarg_up</b> (<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> spoff, int type_align, int slotsize, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc=<a class="el" href="typeinf_8hpp.html#a1d8607c930b67577c7f39ac7a5d24612">CM_CC_UNKNOWN</a>)</td></tr>
<tr class="separator:a3f69d6c26ab4d44a060c297152e3b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed20433595bd80ad285298deb5cf6e4c"><td class="memItemLeft" align="right" valign="top"><a id="aed20433595bd80ad285298deb5cf6e4c" name="aed20433595bd80ad285298deb5cf6e4c"></a>
<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>align_stkarg_up</b> (<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> spoff, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, int slotsize, <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> cc=<a class="el" href="typeinf_8hpp.html#a1d8607c930b67577c7f39ac7a5d24612">CM_CC_UNKNOWN</a>)</td></tr>
<tr class="separator:aed20433595bd80ad285298deb5cf6e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a197fc9ead77f71f0286b2be85e29fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a4a197fc9ead77f71f0286b2be85e29fa">remove_pointer</a> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif)</td></tr>
<tr class="memdesc:a4a197fc9ead77f71f0286b2be85e29fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer.">BT_PTR</a>: If the current type is a pointer, return the pointed object.  <a href="typeinf_8hpp.html#a4a197fc9ead77f71f0286b2be85e29fa">More...</a><br /></td></tr>
<tr class="separator:a4a197fc9ead77f71f0286b2be85e29fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af504617c1e963028d77c7fdb6ee99aa2"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#af504617c1e963028d77c7fdb6ee99aa2">unpack_idcobj_from_idb</a> (<a class="el" href="classidc__value__t.html">idc_value_t</a> *obj, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, ea_t ea, const <a class="el" href="classbytevec__t.html">bytevec_t</a> *off0, int pio_flags=0)</td></tr>
<tr class="memdesc:af504617c1e963028d77c7fdb6ee99aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of register objects.  <a href="typeinf_8hpp.html#af504617c1e963028d77c7fdb6ee99aa2">More...</a><br /></td></tr>
<tr class="separator:af504617c1e963028d77c7fdb6ee99aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffe0e62534103fb7b607fc36abe7bf6"><td class="memItemLeft" align="right" valign="top"><a id="a0ffe0e62534103fb7b607fc36abe7bf6" name="a0ffe0e62534103fb7b607fc36abe7bf6"></a>
idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>unpack_idcobj_from_bv</b> (<a class="el" href="classidc__value__t.html">idc_value_t</a> *obj, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, const <a class="el" href="classbytevec__t.html">bytevec_t</a> &amp;bytes, int pio_flags=0)</td></tr>
<tr class="memdesc:a0ffe0e62534103fb7b607fc36abe7bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a typed idc object from the byte vector. <br /></td></tr>
<tr class="separator:a0ffe0e62534103fb7b607fc36abe7bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e28933e48837792744ebdd30acd68b4"><td class="memItemLeft" align="right" valign="top"><a id="a0e28933e48837792744ebdd30acd68b4" name="a0e28933e48837792744ebdd30acd68b4"></a>
idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>pack_idcobj_to_idb</b> (const <a class="el" href="classidc__value__t.html">idc_value_t</a> *obj, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, ea_t ea, int pio_flags=0)</td></tr>
<tr class="memdesc:a0e28933e48837792744ebdd30acd68b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a typed idc object to the database. <br /></td></tr>
<tr class="separator:a0e28933e48837792744ebdd30acd68b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce985da43933ab09dfc7c9e4106d518"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a3ce985da43933ab09dfc7c9e4106d518">pack_idcobj_to_bv</a> (const <a class="el" href="classidc__value__t.html">idc_value_t</a> *obj, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, <a class="el" href="structrelobj__t.html">relobj_t</a> *bytes, void *objoff, int pio_flags=0)</td></tr>
<tr class="memdesc:a3ce985da43933ab09dfc7c9e4106d518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a typed idc object to the byte vector.  <a href="typeinf_8hpp.html#a3ce985da43933ab09dfc7c9e4106d518">More...</a><br /></td></tr>
<tr class="separator:a3ce985da43933ab09dfc7c9e4106d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2396d17985c39350c17886ce373b53"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a4f2396d17985c39350c17886ce373b53">apply_tinfo_to_stkarg</a> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, const <a class="el" href="classop__t.html">op_t</a> &amp;x, <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> v, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, const char *name)</td></tr>
<tr class="memdesc:a4f2396d17985c39350c17886ce373b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for the processor modules.  <a href="typeinf_8hpp.html#a4f2396d17985c39350c17886ce373b53">More...</a><br /></td></tr>
<tr class="separator:a4f2396d17985c39350c17886ce373b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff0623cf6691e0313ad358c9f71bb0"><td class="memItemLeft" align="right" valign="top"><a id="a57ff0623cf6691e0313ad358c9f71bb0" name="a57ff0623cf6691e0313ad358c9f71bb0"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>gen_use_arg_tinfos2</b> (struct <a class="el" href="structargtinfo__helper__t.html">argtinfo_helper_t</a> *_this, ea_t caller, <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti, <a class="el" href="typeinf_8hpp.html#a6b5faeba43c9a59ec3aae166657ff78a">funcargvec_t</a> *rargs)</td></tr>
<tr class="memdesc:a57ff0623cf6691e0313ad358c9f71bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not call this function directly, use <a class="el" href="structargtinfo__helper__t.html">argtinfo_helper_t</a>. <br /></td></tr>
<tr class="separator:a57ff0623cf6691e0313ad358c9f71bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5514519fbf80ceba7f301dde17ff16"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a2b5514519fbf80ceba7f301dde17ff16">func_has_stkframe_hole</a> (ea_t ea, const <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> &amp;fti)</td></tr>
<tr class="memdesc:a2b5514519fbf80ceba7f301dde17ff16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for a hole at the beginning of the stack arguments.  <a href="typeinf_8hpp.html#a2b5514519fbf80ceba7f301dde17ff16">More...</a><br /></td></tr>
<tr class="separator:a2b5514519fbf80ceba7f301dde17ff16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309e15239853f62a34bd81661b2438a0"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a309e15239853f62a34bd81661b2438a0">lower_type</a> (<a class="el" href="structtil__t.html">til_t</a> *til, <a class="el" href="classtinfo__t.html">tinfo_t</a> *tif, const char *name=nullptr, <a class="el" href="classlowertype__helper__t.html">lowertype_helper_t</a> *_helper=nullptr)</td></tr>
<tr class="memdesc:a309e15239853f62a34bd81661b2438a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower type.  <a href="typeinf_8hpp.html#a309e15239853f62a34bd81661b2438a0">More...</a><br /></td></tr>
<tr class="separator:a309e15239853f62a34bd81661b2438a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43f876ba9da3260d61d62789a0234e7"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ad43f876ba9da3260d61d62789a0234e7">replace_ordinal_typerefs</a> (<a class="el" href="structtil__t.html">til_t</a> *til, <a class="el" href="classtinfo__t.html">tinfo_t</a> *tif)</td></tr>
<tr class="memdesc:ad43f876ba9da3260d61d62789a0234e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace references to ordinal types by name references.  <a href="typeinf_8hpp.html#ad43f876ba9da3260d61d62789a0234e7">More...</a><br /></td></tr>
<tr class="separator:ad43f876ba9da3260d61d62789a0234e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa417d7c0601ec34392c906300e20107c"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aa417d7c0601ec34392c906300e20107c">begin_type_updating</a> (<a class="el" href="typeinf_8hpp.html#a7ae46ad265dbaedeab1f06346a4d9f98">update_type_t</a> utp)</td></tr>
<tr class="memdesc:aa417d7c0601ec34392c906300e20107c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the beginning of a large update operation on the types.  <a href="typeinf_8hpp.html#aa417d7c0601ec34392c906300e20107c">More...</a><br /></td></tr>
<tr class="separator:aa417d7c0601ec34392c906300e20107c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6ae8f80de9c5b0941701216296264e"><td class="memItemLeft" align="right" valign="top"><a id="abd6ae8f80de9c5b0941701216296264e" name="abd6ae8f80de9c5b0941701216296264e"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>end_type_updating</b> (<a class="el" href="typeinf_8hpp.html#a7ae46ad265dbaedeab1f06346a4d9f98">update_type_t</a> utp)</td></tr>
<tr class="memdesc:abd6ae8f80de9c5b0941701216296264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the end of a large update operation on the types (see <a class="el" href="typeinf_8hpp.html#aa417d7c0601ec34392c906300e20107c" title="Mark the beginning of a large update operation on the types.">begin_type_updating()</a>) <br /></td></tr>
<tr class="separator:abd6ae8f80de9c5b0941701216296264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2724af804f94383fa884c10d8774425"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ae2724af804f94383fa884c10d8774425">format_cdata</a> (<a class="el" href="pro_8h.html#a823b67c620f6cdca97e1d969ea4a9b02">qstrvec_t</a> *outvec, const <a class="el" href="classidc__value__t.html">idc_value_t</a> &amp;idc_value, const <a class="el" href="classtinfo__t.html">tinfo_t</a> *tif, <a class="el" href="classvalstr__t.html">valstr_t</a> *vtree=nullptr, const <a class="el" href="structformat__data__info__t.html">format_data_info_t</a> *fdi=nullptr)</td></tr>
<tr class="memdesc:ae2724af804f94383fa884c10d8774425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a data value as a C initializer.  <a href="typeinf_8hpp.html#ae2724af804f94383fa884c10d8774425">More...</a><br /></td></tr>
<tr class="separator:ae2724af804f94383fa884c10d8774425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad306e87a0242d5b900d848ca23b6d04e"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ad306e87a0242d5b900d848ca23b6d04e">print_cdata</a> (<a class="el" href="structtext__sink__t.html">text_sink_t</a> &amp;printer, const <a class="el" href="classidc__value__t.html">idc_value_t</a> &amp;idc_value, const <a class="el" href="classtinfo__t.html">tinfo_t</a> *tif, const <a class="el" href="structformat__data__info__t.html">format_data_info_t</a> *fdi=nullptr)</td></tr>
<tr class="memdesc:ad306e87a0242d5b900d848ca23b6d04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="typeinf_8hpp.html#ae2724af804f94383fa884c10d8774425" title="Format a data value as a C initializer.">format_cdata()</a>, but instead of returning the answer in a vector, print it.  <a href="typeinf_8hpp.html#ad306e87a0242d5b900d848ca23b6d04e">More...</a><br /></td></tr>
<tr class="separator:ad306e87a0242d5b900d848ca23b6d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae693627c85f4a9d02c34adb1b5055570"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#ae693627c85f4a9d02c34adb1b5055570">print_decls</a> (<a class="el" href="structtext__sink__t.html">text_sink_t</a> &amp;printer, <a class="el" href="structtil__t.html">til_t</a> *til, const <a class="el" href="classqvector.html">ordvec_t</a> *ordinals, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> pdf_flags)</td></tr>
<tr class="memdesc:ae693627c85f4a9d02c34adb1b5055570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print types (and possibly their dependencies) in a format suitable for using in a header file.  <a href="typeinf_8hpp.html#ae693627c85f4a9d02c34adb1b5055570">More...</a><br /></td></tr>
<tr class="separator:ae693627c85f4a9d02c34adb1b5055570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054f399b8040e3504a6a0288e85ca4d6"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a054f399b8040e3504a6a0288e85ca4d6">calc_number_of_children</a> (const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;loc, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, bool dont_deref_ptr=false)</td></tr>
<tr class="memdesc:a054f399b8040e3504a6a0288e85ca4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate max number of lines of a formatted c data, when expanded (<a class="el" href="typeinf_8hpp.html#a3961c67927e9f622c548d492555ecda7" title="print only top level on separate lines; max_length applies to separate lines; margin is ignored">PTV_EXPAND</a>).  <a href="typeinf_8hpp.html#a054f399b8040e3504a6a0288e85ca4d6">More...</a><br /></td></tr>
<tr class="separator:a054f399b8040e3504a6a0288e85ca4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba339494aea0462baa7558b05480e17"><td class="memItemLeft" align="right" valign="top">idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a9ba339494aea0462baa7558b05480e17">format_c_number</a> (char *buf, size_t bufsize, uint128 value, int size, int pcn=0)</td></tr>
<tr class="memdesc:a9ba339494aea0462baa7558b05480e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a C number.  <a href="typeinf_8hpp.html#a9ba339494aea0462baa7558b05480e17">More...</a><br /></td></tr>
<tr class="separator:a9ba339494aea0462baa7558b05480e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7779b7d833a30bcbeb313ae4be6b3547"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a7779b7d833a30bcbeb313ae4be6b3547">get_enum_member_expr</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, int serial, uint64 value)</td></tr>
<tr class="memdesc:a7779b7d833a30bcbeb313ae4be6b3547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a C expression that can be used to represent an enum member.  <a href="typeinf_8hpp.html#a7779b7d833a30bcbeb313ae4be6b3547">More...</a><br /></td></tr>
<tr class="separator:a7779b7d833a30bcbeb313ae4be6b3547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f7cfb48f3f391a78f8fea18e3e51ea"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a52f7cfb48f3f391a78f8fea18e3e51ea">choose_named_type</a> (<a class="el" href="structtil__symbol__t.html">til_symbol_t</a> *out_sym, const <a class="el" href="structtil__t.html">til_t</a> *root_til, const char *title, int ntf_flags, <a class="el" href="structpredicate__t.html">predicate_t</a> *predicate=nullptr)</td></tr>
<tr class="memdesc:a52f7cfb48f3f391a78f8fea18e3e51ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose a type from a type library.  <a href="typeinf_8hpp.html#a52f7cfb48f3f391a78f8fea18e3e51ea">More...</a><br /></td></tr>
<tr class="separator:a52f7cfb48f3f391a78f8fea18e3e51ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a77b1660621bf2ea16dbd401c80a39a"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a9a77b1660621bf2ea16dbd401c80a39a">choose_local_tinfo</a> (const <a class="el" href="structtil__t.html">til_t</a> *ti, const char *title, <a class="el" href="typeinf_8hpp.html#ab50d6548ef1add1a4a33341539d9f737">local_tinfo_predicate_t</a> *func=nullptr, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> def_ord=0, void *ud=nullptr)</td></tr>
<tr class="memdesc:a9a77b1660621bf2ea16dbd401c80a39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose a type from the local type library.  <a href="typeinf_8hpp.html#a9a77b1660621bf2ea16dbd401c80a39a">More...</a><br /></td></tr>
<tr class="separator:a9a77b1660621bf2ea16dbd401c80a39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e044dce82ece0cb92f29a176fe7b828"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a4e044dce82ece0cb92f29a176fe7b828">choose_local_tinfo_and_delta</a> (<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> *delta, const <a class="el" href="structtil__t.html">til_t</a> *ti, const char *title, <a class="el" href="typeinf_8hpp.html#ab50d6548ef1add1a4a33341539d9f737">local_tinfo_predicate_t</a> *func=nullptr, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> def_ord=0, void *ud=nullptr)</td></tr>
<tr class="memdesc:a4e044dce82ece0cb92f29a176fe7b828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose a type from the local type library and specify the pointer shift value.  <a href="typeinf_8hpp.html#a4e044dce82ece0cb92f29a176fe7b828">More...</a><br /></td></tr>
<tr class="separator:a4e044dce82ece0cb92f29a176fe7b828"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae890bf98baf7dcadf121a9b5ee1eed51"><td class="memItemLeft" align="right" valign="top"><a id="ae890bf98baf7dcadf121a9b5ee1eed51" name="ae890bf98baf7dcadf121a9b5ee1eed51"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TYPE_BASE_MASK</b> = 0x0F</td></tr>
<tr class="memdesc:ae890bf98baf7dcadf121a9b5ee1eed51"><td class="mdescLeft">&#160;</td><td class="mdescRight">the low 4 bits define the basic type <br /></td></tr>
<tr class="separator:ae890bf98baf7dcadf121a9b5ee1eed51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5ec5ef511fe0323471b0f2765d85cf"><td class="memItemLeft" align="right" valign="top"><a id="aac5ec5ef511fe0323471b0f2765d85cf" name="aac5ec5ef511fe0323471b0f2765d85cf"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TYPE_FLAGS_MASK</b> = 0x30</td></tr>
<tr class="memdesc:aac5ec5ef511fe0323471b0f2765d85cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">type flags - they have different meaning depending on the basic type <br /></td></tr>
<tr class="separator:aac5ec5ef511fe0323471b0f2765d85cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba446d2cb3b761e1af374cd209a911e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#afba446d2cb3b761e1af374cd209a911e">TYPE_MODIF_MASK</a> = 0xC0</td></tr>
<tr class="memdesc:afba446d2cb3b761e1af374cd209a911e"><td class="mdescLeft">&#160;</td><td class="mdescRight">modifiers.  <a href="typeinf_8hpp.html#afba446d2cb3b761e1af374cd209a911e">More...</a><br /></td></tr>
<tr class="separator:afba446d2cb3b761e1af374cd209a911e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0546e0e6a47765f33245d7a9d6b175aa"><td class="memItemLeft" align="right" valign="top"><a id="a0546e0e6a47765f33245d7a9d6b175aa" name="a0546e0e6a47765f33245d7a9d6b175aa"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TYPE_FULL_MASK</b> = (<a class="el" href="typeinf_8hpp.html#ae890bf98baf7dcadf121a9b5ee1eed51">TYPE_BASE_MASK</a> | <a class="el" href="typeinf_8hpp.html#aac5ec5ef511fe0323471b0f2765d85cf">TYPE_FLAGS_MASK</a>)</td></tr>
<tr class="memdesc:a0546e0e6a47765f33245d7a9d6b175aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic type with type flags <br /></td></tr>
<tr class="separator:a0546e0e6a47765f33245d7a9d6b175aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2f460ca1ce121f26cf35a2fd56435c"><td class="memItemLeft" align="right" valign="top"><a id="a9c2f460ca1ce121f26cf35a2fd56435c" name="a9c2f460ca1ce121f26cf35a2fd56435c"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_UNK</b> = 0x00</td></tr>
<tr class="memdesc:a9c2f460ca1ce121f26cf35a2fd56435c"><td class="mdescLeft">&#160;</td><td class="mdescRight">unknown <br /></td></tr>
<tr class="separator:a9c2f460ca1ce121f26cf35a2fd56435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99e9832d21e1b090117fc2feab1c2b5"><td class="memItemLeft" align="right" valign="top"><a id="af99e9832d21e1b090117fc2feab1c2b5" name="af99e9832d21e1b090117fc2feab1c2b5"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_VOID</b> = 0x01</td></tr>
<tr class="memdesc:af99e9832d21e1b090117fc2feab1c2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <br /></td></tr>
<tr class="separator:af99e9832d21e1b090117fc2feab1c2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57d28bf34d646a18be655f3a3e75cad"><td class="memItemLeft" align="right" valign="top"><a id="ae57d28bf34d646a18be655f3a3e75cad" name="ae57d28bf34d646a18be655f3a3e75cad"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_SIZE0</b> = 0x00</td></tr>
<tr class="memdesc:ae57d28bf34d646a18be655f3a3e75cad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5" title="void">BT_VOID</a> - normal void; <a class="el" href="typeinf_8hpp.html#a9c2f460ca1ce121f26cf35a2fd56435c" title="unknown">BT_UNK</a> - don't use <br /></td></tr>
<tr class="separator:ae57d28bf34d646a18be655f3a3e75cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ce5c51a92ecb3d1b44ffc6d08a5e05"><td class="memItemLeft" align="right" valign="top"><a id="a90ce5c51a92ecb3d1b44ffc6d08a5e05" name="a90ce5c51a92ecb3d1b44ffc6d08a5e05"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_SIZE12</b> = 0x10</td></tr>
<tr class="memdesc:a90ce5c51a92ecb3d1b44ffc6d08a5e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">size = 1 byte if <a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5" title="void">BT_VOID</a>; 2 if <a class="el" href="typeinf_8hpp.html#a9c2f460ca1ce121f26cf35a2fd56435c" title="unknown">BT_UNK</a> <br /></td></tr>
<tr class="separator:a90ce5c51a92ecb3d1b44ffc6d08a5e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed1420856f2a445e0f0977f576d6bf5"><td class="memItemLeft" align="right" valign="top"><a id="a9ed1420856f2a445e0f0977f576d6bf5" name="a9ed1420856f2a445e0f0977f576d6bf5"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_SIZE48</b> = 0x20</td></tr>
<tr class="memdesc:a9ed1420856f2a445e0f0977f576d6bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">size = 4 bytes if <a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5" title="void">BT_VOID</a>; 8 if <a class="el" href="typeinf_8hpp.html#a9c2f460ca1ce121f26cf35a2fd56435c" title="unknown">BT_UNK</a> <br /></td></tr>
<tr class="separator:a9ed1420856f2a445e0f0977f576d6bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae249f36ee88b26f66602b505aacb62d6"><td class="memItemLeft" align="right" valign="top"><a id="ae249f36ee88b26f66602b505aacb62d6" name="ae249f36ee88b26f66602b505aacb62d6"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_SIZE128</b> = 0x30</td></tr>
<tr class="memdesc:ae249f36ee88b26f66602b505aacb62d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">size = 16 bytes if <a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5" title="void">BT_VOID</a>; unknown if <a class="el" href="typeinf_8hpp.html#a9c2f460ca1ce121f26cf35a2fd56435c" title="unknown">BT_UNK</a> (IN struct alignment - see below) <br /></td></tr>
<tr class="separator:ae249f36ee88b26f66602b505aacb62d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44635e5f36e3ff87017e674a0ba1e96"><td class="memItemLeft" align="right" valign="top"><a id="ad44635e5f36e3ff87017e674a0ba1e96" name="ad44635e5f36e3ff87017e674a0ba1e96"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_INT8</b> = 0x02</td></tr>
<tr class="memdesc:ad44635e5f36e3ff87017e674a0ba1e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int8 <br /></td></tr>
<tr class="separator:ad44635e5f36e3ff87017e674a0ba1e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111f1b71efa2a45245d7ba9469ceb18f"><td class="memItemLeft" align="right" valign="top"><a id="a111f1b71efa2a45245d7ba9469ceb18f" name="a111f1b71efa2a45245d7ba9469ceb18f"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_INT16</b> = 0x03</td></tr>
<tr class="memdesc:a111f1b71efa2a45245d7ba9469ceb18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int16 <br /></td></tr>
<tr class="separator:a111f1b71efa2a45245d7ba9469ceb18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8a1235fb794ee0e5bfab074d2dfc7d"><td class="memItemLeft" align="right" valign="top"><a id="a6e8a1235fb794ee0e5bfab074d2dfc7d" name="a6e8a1235fb794ee0e5bfab074d2dfc7d"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_INT32</b> = 0x04</td></tr>
<tr class="memdesc:a6e8a1235fb794ee0e5bfab074d2dfc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int32 <br /></td></tr>
<tr class="separator:a6e8a1235fb794ee0e5bfab074d2dfc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245e5fd5f4a2eac20183c1e3e6c81837"><td class="memItemLeft" align="right" valign="top"><a id="a245e5fd5f4a2eac20183c1e3e6c81837" name="a245e5fd5f4a2eac20183c1e3e6c81837"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_INT64</b> = 0x05</td></tr>
<tr class="memdesc:a245e5fd5f4a2eac20183c1e3e6c81837"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int64 <br /></td></tr>
<tr class="separator:a245e5fd5f4a2eac20183c1e3e6c81837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248c7431d9792b1a4d48f422368bb77b"><td class="memItemLeft" align="right" valign="top"><a id="a248c7431d9792b1a4d48f422368bb77b" name="a248c7431d9792b1a4d48f422368bb77b"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_INT128</b> = 0x06</td></tr>
<tr class="memdesc:a248c7431d9792b1a4d48f422368bb77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int128 (for alpha &amp; future use) <br /></td></tr>
<tr class="separator:a248c7431d9792b1a4d48f422368bb77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0247bd6d30b0ca1725ec2cf6cbccdc83"><td class="memItemLeft" align="right" valign="top"><a id="a0247bd6d30b0ca1725ec2cf6cbccdc83" name="a0247bd6d30b0ca1725ec2cf6cbccdc83"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_INT</b> = 0x07</td></tr>
<tr class="memdesc:a0247bd6d30b0ca1725ec2cf6cbccdc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">natural int. (size provided by idp module) <br /></td></tr>
<tr class="separator:a0247bd6d30b0ca1725ec2cf6cbccdc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d0f4299a2a72b0c39bf42def60559f"><td class="memItemLeft" align="right" valign="top"><a id="a12d0f4299a2a72b0c39bf42def60559f" name="a12d0f4299a2a72b0c39bf42def60559f"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_UNKSIGN</b> = 0x00</td></tr>
<tr class="memdesc:a12d0f4299a2a72b0c39bf42def60559f"><td class="mdescLeft">&#160;</td><td class="mdescRight">unknown signedness <br /></td></tr>
<tr class="separator:a12d0f4299a2a72b0c39bf42def60559f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed538a73e5a21b72509b0dd0edf6574c"><td class="memItemLeft" align="right" valign="top"><a id="aed538a73e5a21b72509b0dd0edf6574c" name="aed538a73e5a21b72509b0dd0edf6574c"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_SIGNED</b> = 0x10</td></tr>
<tr class="memdesc:aed538a73e5a21b72509b0dd0edf6574c"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed <br /></td></tr>
<tr class="separator:aed538a73e5a21b72509b0dd0edf6574c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae657884ce0de31e6bc235c3bd6dea235"><td class="memItemLeft" align="right" valign="top"><a id="ae657884ce0de31e6bc235c3bd6dea235" name="ae657884ce0de31e6bc235c3bd6dea235"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_USIGNED</b> = 0x20</td></tr>
<tr class="memdesc:ae657884ce0de31e6bc235c3bd6dea235"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned <br /></td></tr>
<tr class="separator:ae657884ce0de31e6bc235c3bd6dea235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9f1f16dab55f10effb4ca9ecc1cf57"><td class="memItemLeft" align="right" valign="top"><a id="abb9f1f16dab55f10effb4ca9ecc1cf57" name="abb9f1f16dab55f10effb4ca9ecc1cf57"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_UNSIGNED</b> = <a class="el" href="typeinf_8hpp.html#ae657884ce0de31e6bc235c3bd6dea235">BTMT_USIGNED</a></td></tr>
<tr class="separator:abb9f1f16dab55f10effb4ca9ecc1cf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc0128b8f9f51961efa661bd6c36523"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a2fc0128b8f9f51961efa661bd6c36523">BTMT_CHAR</a> = 0x30</td></tr>
<tr class="memdesc:a2fc0128b8f9f51961efa661bd6c36523"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify char or segment register  <a href="typeinf_8hpp.html#a2fc0128b8f9f51961efa661bd6c36523">More...</a><br /></td></tr>
<tr class="separator:a2fc0128b8f9f51961efa661bd6c36523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356f8955bf9845e4dba1316fc2b29b80"><td class="memItemLeft" align="right" valign="top"><a id="a356f8955bf9845e4dba1316fc2b29b80" name="a356f8955bf9845e4dba1316fc2b29b80"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_BOOL</b> = 0x08</td></tr>
<tr class="memdesc:a356f8955bf9845e4dba1316fc2b29b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool <br /></td></tr>
<tr class="separator:a356f8955bf9845e4dba1316fc2b29b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea57d16afee0d49d86834c3deb3352b4"><td class="memItemLeft" align="right" valign="top"><a id="aea57d16afee0d49d86834c3deb3352b4" name="aea57d16afee0d49d86834c3deb3352b4"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_DEFBOOL</b> = 0x00</td></tr>
<tr class="memdesc:aea57d16afee0d49d86834c3deb3352b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">size is model specific or unknown(?) <br /></td></tr>
<tr class="separator:aea57d16afee0d49d86834c3deb3352b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16d1493a800576d13e42832260e49a6"><td class="memItemLeft" align="right" valign="top"><a id="af16d1493a800576d13e42832260e49a6" name="af16d1493a800576d13e42832260e49a6"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_BOOL1</b> = 0x10</td></tr>
<tr class="memdesc:af16d1493a800576d13e42832260e49a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">size 1byte <br /></td></tr>
<tr class="separator:af16d1493a800576d13e42832260e49a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c47f90c1908d79b293a1907c9095159"><td class="memItemLeft" align="right" valign="top"><a id="a8c47f90c1908d79b293a1907c9095159" name="a8c47f90c1908d79b293a1907c9095159"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_BOOL2</b> = 0x20</td></tr>
<tr class="memdesc:a8c47f90c1908d79b293a1907c9095159"><td class="mdescLeft">&#160;</td><td class="mdescRight">size 2bytes - !inf_is_64bit() <br /></td></tr>
<tr class="separator:a8c47f90c1908d79b293a1907c9095159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fd807e7569cda6d67b2170e24b5053"><td class="memItemLeft" align="right" valign="top"><a id="a58fd807e7569cda6d67b2170e24b5053" name="a58fd807e7569cda6d67b2170e24b5053"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_BOOL8</b> = 0x20</td></tr>
<tr class="memdesc:a58fd807e7569cda6d67b2170e24b5053"><td class="mdescLeft">&#160;</td><td class="mdescRight">size 8bytes - inf_is_64bit() <br /></td></tr>
<tr class="separator:a58fd807e7569cda6d67b2170e24b5053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a24de12bf3ca6dccf07cb87c398cd8"><td class="memItemLeft" align="right" valign="top"><a id="ab3a24de12bf3ca6dccf07cb87c398cd8" name="ab3a24de12bf3ca6dccf07cb87c398cd8"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_BOOL4</b> = 0x30</td></tr>
<tr class="memdesc:ab3a24de12bf3ca6dccf07cb87c398cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">size 4bytes <br /></td></tr>
<tr class="separator:ab3a24de12bf3ca6dccf07cb87c398cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a226ec408b8610feafdd4c32267a82"><td class="memItemLeft" align="right" valign="top"><a id="a59a226ec408b8610feafdd4c32267a82" name="a59a226ec408b8610feafdd4c32267a82"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_FLOAT</b> = 0x09</td></tr>
<tr class="memdesc:a59a226ec408b8610feafdd4c32267a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">float <br /></td></tr>
<tr class="separator:a59a226ec408b8610feafdd4c32267a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebc0abbf7692bfdf20dff86e9bf588f"><td class="memItemLeft" align="right" valign="top"><a id="acebc0abbf7692bfdf20dff86e9bf588f" name="acebc0abbf7692bfdf20dff86e9bf588f"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_FLOAT</b> = 0x00</td></tr>
<tr class="memdesc:acebc0abbf7692bfdf20dff86e9bf588f"><td class="mdescLeft">&#160;</td><td class="mdescRight">float (4 bytes) <br /></td></tr>
<tr class="separator:acebc0abbf7692bfdf20dff86e9bf588f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53977235765c0dd13fcbdfd21150cea"><td class="memItemLeft" align="right" valign="top"><a id="ad53977235765c0dd13fcbdfd21150cea" name="ad53977235765c0dd13fcbdfd21150cea"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_DOUBLE</b> = 0x10</td></tr>
<tr class="memdesc:ad53977235765c0dd13fcbdfd21150cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">double (8 bytes) <br /></td></tr>
<tr class="separator:ad53977235765c0dd13fcbdfd21150cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4c3be08ef760f80e6123e5f43ada38"><td class="memItemLeft" align="right" valign="top"><a id="a3f4c3be08ef760f80e6123e5f43ada38" name="a3f4c3be08ef760f80e6123e5f43ada38"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_LNGDBL</b> = 0x20</td></tr>
<tr class="memdesc:a3f4c3be08ef760f80e6123e5f43ada38"><td class="mdescLeft">&#160;</td><td class="mdescRight">long double (compiler specific) <br /></td></tr>
<tr class="separator:a3f4c3be08ef760f80e6123e5f43ada38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f394b71c9b27c46560178e0054f79b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a34f394b71c9b27c46560178e0054f79b">BTMT_SPECFLT</a> = 0x30</td></tr>
<tr class="memdesc:a34f394b71c9b27c46560178e0054f79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">float (variable size).  <a href="typeinf_8hpp.html#a34f394b71c9b27c46560178e0054f79b">More...</a><br /></td></tr>
<tr class="separator:a34f394b71c9b27c46560178e0054f79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add35f3c45f5a8e13b0ce6603702c1445"><td class="memItemLeft" align="right" valign="top"><a id="add35f3c45f5a8e13b0ce6603702c1445" name="add35f3c45f5a8e13b0ce6603702c1445"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_BT_LAST_BASIC</b> = <a class="el" href="typeinf_8hpp.html#a59a226ec408b8610feafdd4c32267a82">BT_FLOAT</a></td></tr>
<tr class="memdesc:add35f3c45f5a8e13b0ce6603702c1445"><td class="mdescLeft">&#160;</td><td class="mdescRight">the last basic type, all basic types may be followed by [tah-typeattrs] <br /></td></tr>
<tr class="separator:add35f3c45f5a8e13b0ce6603702c1445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea9ae22535f9fb09b2c74f6e7526d4e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a1ea9ae22535f9fb09b2c74f6e7526d4e">BT_PTR</a> = 0x0A</td></tr>
<tr class="memdesc:a1ea9ae22535f9fb09b2c74f6e7526d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer.  <a href="typeinf_8hpp.html#a1ea9ae22535f9fb09b2c74f6e7526d4e">More...</a><br /></td></tr>
<tr class="separator:a1ea9ae22535f9fb09b2c74f6e7526d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c44b2a54003ba7ba132a52e84b64d8e"><td class="memItemLeft" align="right" valign="top"><a id="a3c44b2a54003ba7ba132a52e84b64d8e" name="a3c44b2a54003ba7ba132a52e84b64d8e"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_DEFPTR</b> = 0x00</td></tr>
<tr class="memdesc:a3c44b2a54003ba7ba132a52e84b64d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">default for model <br /></td></tr>
<tr class="separator:a3c44b2a54003ba7ba132a52e84b64d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fd022fe6b8de3ed2f0ab1eb3b52d88"><td class="memItemLeft" align="right" valign="top"><a id="a24fd022fe6b8de3ed2f0ab1eb3b52d88" name="a24fd022fe6b8de3ed2f0ab1eb3b52d88"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_NEAR</b> = 0x10</td></tr>
<tr class="memdesc:a24fd022fe6b8de3ed2f0ab1eb3b52d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">near <br /></td></tr>
<tr class="separator:a24fd022fe6b8de3ed2f0ab1eb3b52d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0f144fc969457fd435987e0ca8295b"><td class="memItemLeft" align="right" valign="top"><a id="a3d0f144fc969457fd435987e0ca8295b" name="a3d0f144fc969457fd435987e0ca8295b"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_FAR</b> = 0x20</td></tr>
<tr class="memdesc:a3d0f144fc969457fd435987e0ca8295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">far <br /></td></tr>
<tr class="separator:a3d0f144fc969457fd435987e0ca8295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a80f306cfd595df0d7bd2f5a9ddc64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a17a80f306cfd595df0d7bd2f5a9ddc64">BTMT_CLOSURE</a> = 0x30</td></tr>
<tr class="memdesc:a17a80f306cfd595df0d7bd2f5a9ddc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">closure.  <a href="typeinf_8hpp.html#a17a80f306cfd595df0d7bd2f5a9ddc64">More...</a><br /></td></tr>
<tr class="separator:a17a80f306cfd595df0d7bd2f5a9ddc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c17124d38e796e7cd8804808e4bb5b3"><td class="memItemLeft" align="right" valign="top"><a id="a8c17124d38e796e7cd8804808e4bb5b3" name="a8c17124d38e796e7cd8804808e4bb5b3"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_ARRAY</b> = 0x0B</td></tr>
<tr class="memdesc:a8c17124d38e796e7cd8804808e4bb5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">array <br /></td></tr>
<tr class="separator:a8c17124d38e796e7cd8804808e4bb5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0590f6ba2edff6c58152908be5137f6c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a0590f6ba2edff6c58152908be5137f6c">BTMT_NONBASED</a> = 0x10</td></tr>
<tr class="separator:a0590f6ba2edff6c58152908be5137f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7433356ef536da1289e2633ab4e5d052"><td class="memItemLeft" align="right" valign="top"><a id="a7433356ef536da1289e2633ab4e5d052" name="a7433356ef536da1289e2633ab4e5d052"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_ARRESERV</b> = 0x20</td></tr>
<tr class="memdesc:a7433356ef536da1289e2633ab4e5d052"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved bit <br /></td></tr>
<tr class="separator:a7433356ef536da1289e2633ab4e5d052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7fee21f21237beb6d91e854410e0fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a7b7fee21f21237beb6d91e854410e0fa">BT_FUNC</a> = 0x0C</td></tr>
<tr class="memdesc:a7b7fee21f21237beb6d91e854410e0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">function.  <a href="typeinf_8hpp.html#a7b7fee21f21237beb6d91e854410e0fa">More...</a><br /></td></tr>
<tr class="separator:a7b7fee21f21237beb6d91e854410e0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5147e087dec7232a85eac3899ba2f4b9"><td class="memItemLeft" align="right" valign="top"><a id="a5147e087dec7232a85eac3899ba2f4b9" name="a5147e087dec7232a85eac3899ba2f4b9"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_DEFCALL</b> = 0x00</td></tr>
<tr class="memdesc:a5147e087dec7232a85eac3899ba2f4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">call method - default for model or unknown <br /></td></tr>
<tr class="separator:a5147e087dec7232a85eac3899ba2f4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ede61600f614010e42d95f261c4114"><td class="memItemLeft" align="right" valign="top"><a id="a85ede61600f614010e42d95f261c4114" name="a85ede61600f614010e42d95f261c4114"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_NEARCALL</b> = 0x10</td></tr>
<tr class="memdesc:a85ede61600f614010e42d95f261c4114"><td class="mdescLeft">&#160;</td><td class="mdescRight">function returns by retn <br /></td></tr>
<tr class="separator:a85ede61600f614010e42d95f261c4114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c5f0228b87ce9cfb16925be2d41ea3"><td class="memItemLeft" align="right" valign="top"><a id="a45c5f0228b87ce9cfb16925be2d41ea3" name="a45c5f0228b87ce9cfb16925be2d41ea3"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_FARCALL</b> = 0x20</td></tr>
<tr class="memdesc:a45c5f0228b87ce9cfb16925be2d41ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function returns by retf <br /></td></tr>
<tr class="separator:a45c5f0228b87ce9cfb16925be2d41ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a3fbfc64a1aea9f98765619e1628fc"><td class="memItemLeft" align="right" valign="top"><a id="af9a3fbfc64a1aea9f98765619e1628fc" name="af9a3fbfc64a1aea9f98765619e1628fc"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_INTCALL</b> = 0x30</td></tr>
<tr class="memdesc:af9a3fbfc64a1aea9f98765619e1628fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">function returns by iret in this case cc MUST be 'unknown' <br /></td></tr>
<tr class="separator:af9a3fbfc64a1aea9f98765619e1628fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c5e589737e005ba4741423fd2ca5c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a86c5e589737e005ba4741423fd2ca5c6">BT_COMPLEX</a> = 0x0D</td></tr>
<tr class="memdesc:a86c5e589737e005ba4741423fd2ca5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct/union/enum/typedef.  <a href="typeinf_8hpp.html#a86c5e589737e005ba4741423fd2ca5c6">More...</a><br /></td></tr>
<tr class="separator:a86c5e589737e005ba4741423fd2ca5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf095fd2f25df783b0f5a321d91c6adc"><td class="memItemLeft" align="right" valign="top"><a id="acf095fd2f25df783b0f5a321d91c6adc" name="acf095fd2f25df783b0f5a321d91c6adc"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_STRUCT</b> = 0x00</td></tr>
<tr class="memdesc:acf095fd2f25df783b0f5a321d91c6adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct: MCNT records: type_t; [sdacl-typeattrs]; <br /></td></tr>
<tr class="separator:acf095fd2f25df783b0f5a321d91c6adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af117f7735078132037de2553d7ea393a"><td class="memItemLeft" align="right" valign="top"><a id="af117f7735078132037de2553d7ea393a" name="af117f7735078132037de2553d7ea393a"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_UNION</b> = 0x10</td></tr>
<tr class="memdesc:af117f7735078132037de2553d7ea393a"><td class="mdescLeft">&#160;</td><td class="mdescRight">union: MCNT records: type_t... <br /></td></tr>
<tr class="separator:af117f7735078132037de2553d7ea393a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa364f5b01c60e09fd5b216162817037c"><td class="memItemLeft" align="right" valign="top"><a id="aa364f5b01c60e09fd5b216162817037c" name="aa364f5b01c60e09fd5b216162817037c"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_ENUM</b> = 0x20</td></tr>
<tr class="memdesc:aa364f5b01c60e09fd5b216162817037c"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum: next byte bte_t (see below) N records: de delta(s) OR blocks (see below) <br /></td></tr>
<tr class="separator:aa364f5b01c60e09fd5b216162817037c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e0907e07d1538053682550c2117290"><td class="memItemLeft" align="right" valign="top"><a id="aa4e0907e07d1538053682550c2117290" name="aa4e0907e07d1538053682550c2117290"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_TYPEDEF</b> = 0x30</td></tr>
<tr class="memdesc:aa4e0907e07d1538053682550c2117290"><td class="mdescLeft">&#160;</td><td class="mdescRight">named reference always p_string name <br /></td></tr>
<tr class="separator:aa4e0907e07d1538053682550c2117290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1af452c81ac917f9eab9d456f52454"><td class="memItemLeft" align="right" valign="top"><a id="a0d1af452c81ac917f9eab9d456f52454" name="a0d1af452c81ac917f9eab9d456f52454"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_BITFIELD</b> = 0x0E</td></tr>
<tr class="memdesc:a0d1af452c81ac917f9eab9d456f52454"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitfield (only in struct) ['bitmasked' enum see below] next byte is dt ((size in bits &lt;&lt; 1) | (unsigned ? 1 : 0)) <br /></td></tr>
<tr class="separator:a0d1af452c81ac917f9eab9d456f52454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc19d1408e022d7ff9e2fc1ffc5a4484"><td class="memItemLeft" align="right" valign="top"><a id="acc19d1408e022d7ff9e2fc1ffc5a4484" name="acc19d1408e022d7ff9e2fc1ffc5a4484"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_BFLDI8</b> = 0x00</td></tr>
<tr class="memdesc:acc19d1408e022d7ff9e2fc1ffc5a4484"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int8 <br /></td></tr>
<tr class="separator:acc19d1408e022d7ff9e2fc1ffc5a4484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c7dad369abd97a935635f71ec96d13"><td class="memItemLeft" align="right" valign="top"><a id="a07c7dad369abd97a935635f71ec96d13" name="a07c7dad369abd97a935635f71ec96d13"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_BFLDI16</b> = 0x10</td></tr>
<tr class="memdesc:a07c7dad369abd97a935635f71ec96d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int16 <br /></td></tr>
<tr class="separator:a07c7dad369abd97a935635f71ec96d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c2a5454a1c362bf1a7afb07562bb7d"><td class="memItemLeft" align="right" valign="top"><a id="a49c2a5454a1c362bf1a7afb07562bb7d" name="a49c2a5454a1c362bf1a7afb07562bb7d"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_BFLDI32</b> = 0x20</td></tr>
<tr class="memdesc:a49c2a5454a1c362bf1a7afb07562bb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int32 <br /></td></tr>
<tr class="separator:a49c2a5454a1c362bf1a7afb07562bb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7677d88a97c48e5bf103e78eee7286df"><td class="memItemLeft" align="right" valign="top"><a id="a7677d88a97c48e5bf103e78eee7286df" name="a7677d88a97c48e5bf103e78eee7286df"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTMT_BFLDI64</b> = 0x30</td></tr>
<tr class="memdesc:a7677d88a97c48e5bf103e78eee7286df"><td class="mdescLeft">&#160;</td><td class="mdescRight">__int64 <br /></td></tr>
<tr class="separator:a7677d88a97c48e5bf103e78eee7286df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eeb3ad9c7649364d76cdd6b18d616fe"><td class="memItemLeft" align="right" valign="top"><a id="a0eeb3ad9c7649364d76cdd6b18d616fe" name="a0eeb3ad9c7649364d76cdd6b18d616fe"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_RESERVED</b> = 0x0F</td></tr>
<tr class="memdesc:a0eeb3ad9c7649364d76cdd6b18d616fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">RESERVED. <br /></td></tr>
<tr class="separator:a0eeb3ad9c7649364d76cdd6b18d616fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9620c6eab27564299c432f6f22c963e0"><td class="memItemLeft" align="right" valign="top"><a id="a9620c6eab27564299c432f6f22c963e0" name="a9620c6eab27564299c432f6f22c963e0"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTM_CONST</b> = 0x40</td></tr>
<tr class="memdesc:a9620c6eab27564299c432f6f22c963e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">const <br /></td></tr>
<tr class="separator:a9620c6eab27564299c432f6f22c963e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980855dd322c9bc15ac45421c7267d13"><td class="memItemLeft" align="right" valign="top"><a id="a980855dd322c9bc15ac45421c7267d13" name="a980855dd322c9bc15ac45421c7267d13"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTM_VOLATILE</b> = 0x80</td></tr>
<tr class="memdesc:a980855dd322c9bc15ac45421c7267d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">volatile <br /></td></tr>
<tr class="separator:a980855dd322c9bc15ac45421c7267d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec042ce7c6f887be34b76ae5f404e482"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#aec042ce7c6f887be34b76ae5f404e482">BTE_SIZE_MASK</a> = 0x07</td></tr>
<tr class="memdesc:aec042ce7c6f887be34b76ae5f404e482"><td class="mdescLeft">&#160;</td><td class="mdescRight">storage size.  <a href="typeinf_8hpp.html#aec042ce7c6f887be34b76ae5f404e482">More...</a><br /></td></tr>
<tr class="separator:aec042ce7c6f887be34b76ae5f404e482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957cc71b55104bf133afcb87c473c9ff"><td class="memItemLeft" align="right" valign="top"><a id="a957cc71b55104bf133afcb87c473c9ff" name="a957cc71b55104bf133afcb87c473c9ff"></a>
const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTE_RESERVED</b> = 0x08</td></tr>
<tr class="memdesc:a957cc71b55104bf133afcb87c473c9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">must be 0, in order to distinguish from a tah-byte <br /></td></tr>
<tr class="separator:a957cc71b55104bf133afcb87c473c9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11628b413da4de1841d54d3684fbbf4f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a11628b413da4de1841d54d3684fbbf4f">BTE_BITFIELD</a> = 0x10</td></tr>
<tr class="memdesc:a11628b413da4de1841d54d3684fbbf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">'subarrays'.  <a href="typeinf_8hpp.html#a11628b413da4de1841d54d3684fbbf4f">More...</a><br /></td></tr>
<tr class="separator:a11628b413da4de1841d54d3684fbbf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b0baf37318155a69ccfe296b1fbd52"><td class="memItemLeft" align="right" valign="top"><a id="af4b0baf37318155a69ccfe296b1fbd52" name="af4b0baf37318155a69ccfe296b1fbd52"></a>
const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTE_OUT_MASK</b> = 0x60</td></tr>
<tr class="memdesc:af4b0baf37318155a69ccfe296b1fbd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">output style mask <br /></td></tr>
<tr class="separator:af4b0baf37318155a69ccfe296b1fbd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de0de21213c2c200fd54aeb9c0605e6"><td class="memItemLeft" align="right" valign="top"><a id="a3de0de21213c2c200fd54aeb9c0605e6" name="a3de0de21213c2c200fd54aeb9c0605e6"></a>
const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTE_HEX</b> = 0x00</td></tr>
<tr class="memdesc:a3de0de21213c2c200fd54aeb9c0605e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">hex <br /></td></tr>
<tr class="separator:a3de0de21213c2c200fd54aeb9c0605e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71103d2d6504f0edd910fc56550edcf"><td class="memItemLeft" align="right" valign="top"><a id="ab71103d2d6504f0edd910fc56550edcf" name="ab71103d2d6504f0edd910fc56550edcf"></a>
const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTE_CHAR</b> = 0x20</td></tr>
<tr class="memdesc:ab71103d2d6504f0edd910fc56550edcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">char or hex <br /></td></tr>
<tr class="separator:ab71103d2d6504f0edd910fc56550edcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92e3e234e6950c3639bc876773a2086"><td class="memItemLeft" align="right" valign="top"><a id="ac92e3e234e6950c3639bc876773a2086" name="ac92e3e234e6950c3639bc876773a2086"></a>
const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTE_SDEC</b> = 0x40</td></tr>
<tr class="memdesc:ac92e3e234e6950c3639bc876773a2086"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed decimal <br /></td></tr>
<tr class="separator:ac92e3e234e6950c3639bc876773a2086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bf216f79e79290a36155daf2383076"><td class="memItemLeft" align="right" valign="top"><a id="a66bf216f79e79290a36155daf2383076" name="a66bf216f79e79290a36155daf2383076"></a>
const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTE_UDEC</b> = 0x60</td></tr>
<tr class="memdesc:a66bf216f79e79290a36155daf2383076"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned decimal <br /></td></tr>
<tr class="separator:a66bf216f79e79290a36155daf2383076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84679a3c7bef0696668437e12448fa0"><td class="memItemLeft" align="right" valign="top"><a id="ad84679a3c7bef0696668437e12448fa0" name="ad84679a3c7bef0696668437e12448fa0"></a>
const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTE_ALWAYS</b> = 0x80</td></tr>
<tr class="memdesc:ad84679a3c7bef0696668437e12448fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">this bit MUST be present <br /></td></tr>
<tr class="separator:ad84679a3c7bef0696668437e12448fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549d73cebdc532cb21dee4ae31fe79a3"><td class="memItemLeft" align="right" valign="top"><a id="a549d73cebdc532cb21dee4ae31fe79a3" name="a549d73cebdc532cb21dee4ae31fe79a3"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_SEGREG</b> = (<a class="el" href="typeinf_8hpp.html#a0247bd6d30b0ca1725ec2cf6cbccdc83">BT_INT</a> | <a class="el" href="typeinf_8hpp.html#a2fc0128b8f9f51961efa661bd6c36523">BTMT_CHAR</a>)</td></tr>
<tr class="memdesc:a549d73cebdc532cb21dee4ae31fe79a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">segment register <br /></td></tr>
<tr class="separator:a549d73cebdc532cb21dee4ae31fe79a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cbdc29ec5e3a236ed7386f405e1000"><td class="memItemLeft" align="right" valign="top"><a id="a32cbdc29ec5e3a236ed7386f405e1000" name="a32cbdc29ec5e3a236ed7386f405e1000"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_UNK_BYTE</b> = (<a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5">BT_VOID</a> | <a class="el" href="typeinf_8hpp.html#a90ce5c51a92ecb3d1b44ffc6d08a5e05">BTMT_SIZE12</a>)</td></tr>
<tr class="memdesc:a32cbdc29ec5e3a236ed7386f405e1000"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 byte <br /></td></tr>
<tr class="separator:a32cbdc29ec5e3a236ed7386f405e1000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0a5933fa90878f5ffd4126fd648672"><td class="memItemLeft" align="right" valign="top"><a id="adf0a5933fa90878f5ffd4126fd648672" name="adf0a5933fa90878f5ffd4126fd648672"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_UNK_WORD</b> = (<a class="el" href="typeinf_8hpp.html#a9c2f460ca1ce121f26cf35a2fd56435c">BT_UNK</a> | <a class="el" href="typeinf_8hpp.html#a90ce5c51a92ecb3d1b44ffc6d08a5e05">BTMT_SIZE12</a>)</td></tr>
<tr class="memdesc:adf0a5933fa90878f5ffd4126fd648672"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 bytes <br /></td></tr>
<tr class="separator:adf0a5933fa90878f5ffd4126fd648672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9a53ec936f70a19f148da72cb63a86"><td class="memItemLeft" align="right" valign="top"><a id="a0d9a53ec936f70a19f148da72cb63a86" name="a0d9a53ec936f70a19f148da72cb63a86"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_UNK_DWORD</b> = (<a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5">BT_VOID</a> | <a class="el" href="typeinf_8hpp.html#a9ed1420856f2a445e0f0977f576d6bf5">BTMT_SIZE48</a>)</td></tr>
<tr class="memdesc:a0d9a53ec936f70a19f148da72cb63a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 bytes <br /></td></tr>
<tr class="separator:a0d9a53ec936f70a19f148da72cb63a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926d9ea4bad748875f526cb874c5cf05"><td class="memItemLeft" align="right" valign="top"><a id="a926d9ea4bad748875f526cb874c5cf05" name="a926d9ea4bad748875f526cb874c5cf05"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_UNK_QWORD</b> = (<a class="el" href="typeinf_8hpp.html#a9c2f460ca1ce121f26cf35a2fd56435c">BT_UNK</a> | <a class="el" href="typeinf_8hpp.html#a9ed1420856f2a445e0f0977f576d6bf5">BTMT_SIZE48</a>)</td></tr>
<tr class="memdesc:a926d9ea4bad748875f526cb874c5cf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes <br /></td></tr>
<tr class="separator:a926d9ea4bad748875f526cb874c5cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad042887c6328b4fe30da2e6d359f78d6"><td class="memItemLeft" align="right" valign="top"><a id="ad042887c6328b4fe30da2e6d359f78d6" name="ad042887c6328b4fe30da2e6d359f78d6"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_UNK_OWORD</b> = (<a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5">BT_VOID</a> | <a class="el" href="typeinf_8hpp.html#ae249f36ee88b26f66602b505aacb62d6">BTMT_SIZE128</a>)</td></tr>
<tr class="memdesc:ad042887c6328b4fe30da2e6d359f78d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">16 bytes <br /></td></tr>
<tr class="separator:ad042887c6328b4fe30da2e6d359f78d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15de9552b0654e950d709fd9c165f7aa"><td class="memItemLeft" align="right" valign="top"><a id="a15de9552b0654e950d709fd9c165f7aa" name="a15de9552b0654e950d709fd9c165f7aa"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BT_UNKNOWN</b> = (<a class="el" href="typeinf_8hpp.html#a9c2f460ca1ce121f26cf35a2fd56435c">BT_UNK</a> | <a class="el" href="typeinf_8hpp.html#ae249f36ee88b26f66602b505aacb62d6">BTMT_SIZE128</a>)</td></tr>
<tr class="memdesc:a15de9552b0654e950d709fd9c165f7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">unknown size - for parameters <br /></td></tr>
<tr class="separator:a15de9552b0654e950d709fd9c165f7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443b50fef52ac60e2c4d5017243b522e"><td class="memItemLeft" align="right" valign="top"><a id="a443b50fef52ac60e2c4d5017243b522e" name="a443b50fef52ac60e2c4d5017243b522e"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_BYTE</b> = <a class="el" href="typeinf_8hpp.html#a32cbdc29ec5e3a236ed7386f405e1000">BT_UNK_BYTE</a></td></tr>
<tr class="memdesc:a443b50fef52ac60e2c4d5017243b522e"><td class="mdescLeft">&#160;</td><td class="mdescRight">byte <br /></td></tr>
<tr class="separator:a443b50fef52ac60e2c4d5017243b522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15315b0907cec492e3533f5fdb48510d"><td class="memItemLeft" align="right" valign="top"><a id="a15315b0907cec492e3533f5fdb48510d" name="a15315b0907cec492e3533f5fdb48510d"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UNK</b> = <a class="el" href="typeinf_8hpp.html#a15de9552b0654e950d709fd9c165f7aa">BT_UNKNOWN</a></td></tr>
<tr class="memdesc:a15315b0907cec492e3533f5fdb48510d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unknown <br /></td></tr>
<tr class="separator:a15315b0907cec492e3533f5fdb48510d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3b664437b42978e3549134abf2ea26"><td class="memItemLeft" align="right" valign="top"><a id="a8e3b664437b42978e3549134abf2ea26" name="a8e3b664437b42978e3549134abf2ea26"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_VOID</b> = <a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5">BT_VOID</a> | <a class="el" href="typeinf_8hpp.html#ae57d28bf34d646a18be655f3a3e75cad">BTMT_SIZE0</a></td></tr>
<tr class="memdesc:a8e3b664437b42978e3549134abf2ea26"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <br /></td></tr>
<tr class="separator:a8e3b664437b42978e3549134abf2ea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab212446be82a416e3f8c109265cff94c"><td class="memItemLeft" align="right" valign="top"><a id="ab212446be82a416e3f8c109265cff94c" name="ab212446be82a416e3f8c109265cff94c"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_INT8</b> = <a class="el" href="typeinf_8hpp.html#ad44635e5f36e3ff87017e674a0ba1e96">BT_INT8</a> | <a class="el" href="typeinf_8hpp.html#aed538a73e5a21b72509b0dd0edf6574c">BTMT_SIGNED</a></td></tr>
<tr class="memdesc:ab212446be82a416e3f8c109265cff94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed byte <br /></td></tr>
<tr class="separator:ab212446be82a416e3f8c109265cff94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f698f8ece0ae90a9b49c9c1335620e8"><td class="memItemLeft" align="right" valign="top"><a id="a8f698f8ece0ae90a9b49c9c1335620e8" name="a8f698f8ece0ae90a9b49c9c1335620e8"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_CHAR</b> = <a class="el" href="typeinf_8hpp.html#ad44635e5f36e3ff87017e674a0ba1e96">BT_INT8</a> | <a class="el" href="typeinf_8hpp.html#a2fc0128b8f9f51961efa661bd6c36523">BTMT_CHAR</a></td></tr>
<tr class="memdesc:a8f698f8ece0ae90a9b49c9c1335620e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed char <br /></td></tr>
<tr class="separator:a8f698f8ece0ae90a9b49c9c1335620e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7133ca0feba2a5aaff3cd2ad9e80ac00"><td class="memItemLeft" align="right" valign="top"><a id="a7133ca0feba2a5aaff3cd2ad9e80ac00" name="a7133ca0feba2a5aaff3cd2ad9e80ac00"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UCHAR</b> = <a class="el" href="typeinf_8hpp.html#ad44635e5f36e3ff87017e674a0ba1e96">BT_INT8</a> | <a class="el" href="typeinf_8hpp.html#ae657884ce0de31e6bc235c3bd6dea235">BTMT_USIGNED</a></td></tr>
<tr class="memdesc:a7133ca0feba2a5aaff3cd2ad9e80ac00"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned char <br /></td></tr>
<tr class="separator:a7133ca0feba2a5aaff3cd2ad9e80ac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ac263530b33759a569808ddc8c8838"><td class="memItemLeft" align="right" valign="top"><a id="ae2ac263530b33759a569808ddc8c8838" name="ae2ac263530b33759a569808ddc8c8838"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UINT8</b> = <a class="el" href="typeinf_8hpp.html#ad44635e5f36e3ff87017e674a0ba1e96">BT_INT8</a> | <a class="el" href="typeinf_8hpp.html#ae657884ce0de31e6bc235c3bd6dea235">BTMT_USIGNED</a></td></tr>
<tr class="memdesc:ae2ac263530b33759a569808ddc8c8838"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned byte <br /></td></tr>
<tr class="separator:ae2ac263530b33759a569808ddc8c8838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24323887798e85234cf23638dbae9607"><td class="memItemLeft" align="right" valign="top"><a id="a24323887798e85234cf23638dbae9607" name="a24323887798e85234cf23638dbae9607"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_INT16</b> = <a class="el" href="typeinf_8hpp.html#a111f1b71efa2a45245d7ba9469ceb18f">BT_INT16</a> | <a class="el" href="typeinf_8hpp.html#aed538a73e5a21b72509b0dd0edf6574c">BTMT_SIGNED</a></td></tr>
<tr class="memdesc:a24323887798e85234cf23638dbae9607"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed short <br /></td></tr>
<tr class="separator:a24323887798e85234cf23638dbae9607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cd0cd85c8e0bf67add7ecda0c8519c"><td class="memItemLeft" align="right" valign="top"><a id="a11cd0cd85c8e0bf67add7ecda0c8519c" name="a11cd0cd85c8e0bf67add7ecda0c8519c"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UINT16</b> = <a class="el" href="typeinf_8hpp.html#a111f1b71efa2a45245d7ba9469ceb18f">BT_INT16</a> | <a class="el" href="typeinf_8hpp.html#ae657884ce0de31e6bc235c3bd6dea235">BTMT_USIGNED</a></td></tr>
<tr class="memdesc:a11cd0cd85c8e0bf67add7ecda0c8519c"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned short <br /></td></tr>
<tr class="separator:a11cd0cd85c8e0bf67add7ecda0c8519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76905baf63ca3ef00306cff010075ae"><td class="memItemLeft" align="right" valign="top"><a id="ad76905baf63ca3ef00306cff010075ae" name="ad76905baf63ca3ef00306cff010075ae"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_INT32</b> = <a class="el" href="typeinf_8hpp.html#a6e8a1235fb794ee0e5bfab074d2dfc7d">BT_INT32</a> | <a class="el" href="typeinf_8hpp.html#aed538a73e5a21b72509b0dd0edf6574c">BTMT_SIGNED</a></td></tr>
<tr class="memdesc:ad76905baf63ca3ef00306cff010075ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed int <br /></td></tr>
<tr class="separator:ad76905baf63ca3ef00306cff010075ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c66f893953d1b56d97a19fad216b9cd"><td class="memItemLeft" align="right" valign="top"><a id="a5c66f893953d1b56d97a19fad216b9cd" name="a5c66f893953d1b56d97a19fad216b9cd"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UINT32</b> = <a class="el" href="typeinf_8hpp.html#a6e8a1235fb794ee0e5bfab074d2dfc7d">BT_INT32</a> | <a class="el" href="typeinf_8hpp.html#ae657884ce0de31e6bc235c3bd6dea235">BTMT_USIGNED</a></td></tr>
<tr class="memdesc:a5c66f893953d1b56d97a19fad216b9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned int <br /></td></tr>
<tr class="separator:a5c66f893953d1b56d97a19fad216b9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e667dddebe3b599a1a22d43adc279b"><td class="memItemLeft" align="right" valign="top"><a id="a09e667dddebe3b599a1a22d43adc279b" name="a09e667dddebe3b599a1a22d43adc279b"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_INT64</b> = <a class="el" href="typeinf_8hpp.html#a245e5fd5f4a2eac20183c1e3e6c81837">BT_INT64</a> | <a class="el" href="typeinf_8hpp.html#aed538a73e5a21b72509b0dd0edf6574c">BTMT_SIGNED</a></td></tr>
<tr class="memdesc:a09e667dddebe3b599a1a22d43adc279b"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed long <br /></td></tr>
<tr class="separator:a09e667dddebe3b599a1a22d43adc279b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aedc026ad655dba0ad0d99349be3987"><td class="memItemLeft" align="right" valign="top"><a id="a2aedc026ad655dba0ad0d99349be3987" name="a2aedc026ad655dba0ad0d99349be3987"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UINT64</b> = <a class="el" href="typeinf_8hpp.html#a245e5fd5f4a2eac20183c1e3e6c81837">BT_INT64</a> | <a class="el" href="typeinf_8hpp.html#ae657884ce0de31e6bc235c3bd6dea235">BTMT_USIGNED</a></td></tr>
<tr class="memdesc:a2aedc026ad655dba0ad0d99349be3987"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned long <br /></td></tr>
<tr class="separator:a2aedc026ad655dba0ad0d99349be3987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac322889131d82624af938508a3bae29b"><td class="memItemLeft" align="right" valign="top"><a id="ac322889131d82624af938508a3bae29b" name="ac322889131d82624af938508a3bae29b"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_INT128</b> = <a class="el" href="typeinf_8hpp.html#a248c7431d9792b1a4d48f422368bb77b">BT_INT128</a> | <a class="el" href="typeinf_8hpp.html#aed538a73e5a21b72509b0dd0edf6574c">BTMT_SIGNED</a></td></tr>
<tr class="memdesc:ac322889131d82624af938508a3bae29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed 128-bit value <br /></td></tr>
<tr class="separator:ac322889131d82624af938508a3bae29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b72aa0e7ce565e0da5cad1d37e20f84"><td class="memItemLeft" align="right" valign="top"><a id="a1b72aa0e7ce565e0da5cad1d37e20f84" name="a1b72aa0e7ce565e0da5cad1d37e20f84"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UINT128</b> = <a class="el" href="typeinf_8hpp.html#a248c7431d9792b1a4d48f422368bb77b">BT_INT128</a> | <a class="el" href="typeinf_8hpp.html#ae657884ce0de31e6bc235c3bd6dea235">BTMT_USIGNED</a></td></tr>
<tr class="memdesc:a1b72aa0e7ce565e0da5cad1d37e20f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned 128-bit value <br /></td></tr>
<tr class="separator:a1b72aa0e7ce565e0da5cad1d37e20f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e7706701efe77af085823db0102f9"><td class="memItemLeft" align="right" valign="top"><a id="ac08e7706701efe77af085823db0102f9" name="ac08e7706701efe77af085823db0102f9"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_INT</b> = <a class="el" href="typeinf_8hpp.html#a0247bd6d30b0ca1725ec2cf6cbccdc83">BT_INT</a> | <a class="el" href="typeinf_8hpp.html#a12d0f4299a2a72b0c39bf42def60559f">BTMT_UNKSIGN</a></td></tr>
<tr class="memdesc:ac08e7706701efe77af085823db0102f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">int, unknown signedness <br /></td></tr>
<tr class="separator:ac08e7706701efe77af085823db0102f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4806703d16672e5666cbd8d183539f0d"><td class="memItemLeft" align="right" valign="top"><a id="a4806703d16672e5666cbd8d183539f0d" name="a4806703d16672e5666cbd8d183539f0d"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UINT</b> = <a class="el" href="typeinf_8hpp.html#a0247bd6d30b0ca1725ec2cf6cbccdc83">BT_INT</a> | <a class="el" href="typeinf_8hpp.html#ae657884ce0de31e6bc235c3bd6dea235">BTMT_USIGNED</a></td></tr>
<tr class="memdesc:a4806703d16672e5666cbd8d183539f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned int <br /></td></tr>
<tr class="separator:a4806703d16672e5666cbd8d183539f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8349cd42fa6fc5ed0d43ce09cd2b015"><td class="memItemLeft" align="right" valign="top"><a id="ae8349cd42fa6fc5ed0d43ce09cd2b015" name="ae8349cd42fa6fc5ed0d43ce09cd2b015"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_SINT</b> = <a class="el" href="typeinf_8hpp.html#a0247bd6d30b0ca1725ec2cf6cbccdc83">BT_INT</a> | <a class="el" href="typeinf_8hpp.html#aed538a73e5a21b72509b0dd0edf6574c">BTMT_SIGNED</a></td></tr>
<tr class="memdesc:ae8349cd42fa6fc5ed0d43ce09cd2b015"><td class="mdescLeft">&#160;</td><td class="mdescRight">singed int <br /></td></tr>
<tr class="separator:ae8349cd42fa6fc5ed0d43ce09cd2b015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd76b18e7247eae4cc2ab7b5ce07722"><td class="memItemLeft" align="right" valign="top"><a id="aecd76b18e7247eae4cc2ab7b5ce07722" name="aecd76b18e7247eae4cc2ab7b5ce07722"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_BOOL</b> = <a class="el" href="typeinf_8hpp.html#a356f8955bf9845e4dba1316fc2b29b80">BT_BOOL</a></td></tr>
<tr class="memdesc:aecd76b18e7247eae4cc2ab7b5ce07722"><td class="mdescLeft">&#160;</td><td class="mdescRight">boolean <br /></td></tr>
<tr class="separator:aecd76b18e7247eae4cc2ab7b5ce07722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2965fc7a244e1147d99547e97284848"><td class="memItemLeft" align="right" valign="top"><a id="ae2965fc7a244e1147d99547e97284848" name="ae2965fc7a244e1147d99547e97284848"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_FLOAT</b> = <a class="el" href="typeinf_8hpp.html#a59a226ec408b8610feafdd4c32267a82">BT_FLOAT</a> | <a class="el" href="typeinf_8hpp.html#acebc0abbf7692bfdf20dff86e9bf588f">BTMT_FLOAT</a></td></tr>
<tr class="memdesc:ae2965fc7a244e1147d99547e97284848"><td class="mdescLeft">&#160;</td><td class="mdescRight">float <br /></td></tr>
<tr class="separator:ae2965fc7a244e1147d99547e97284848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c776e37b0c4461f737a2f14d5401f9"><td class="memItemLeft" align="right" valign="top"><a id="a14c776e37b0c4461f737a2f14d5401f9" name="a14c776e37b0c4461f737a2f14d5401f9"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_DOUBLE</b> = <a class="el" href="typeinf_8hpp.html#a59a226ec408b8610feafdd4c32267a82">BT_FLOAT</a> | <a class="el" href="typeinf_8hpp.html#ad53977235765c0dd13fcbdfd21150cea">BTMT_DOUBLE</a></td></tr>
<tr class="memdesc:a14c776e37b0c4461f737a2f14d5401f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">double <br /></td></tr>
<tr class="separator:a14c776e37b0c4461f737a2f14d5401f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86134b88d5f0c1c33a482ba02e5a314"><td class="memItemLeft" align="right" valign="top"><a id="aa86134b88d5f0c1c33a482ba02e5a314" name="aa86134b88d5f0c1c33a482ba02e5a314"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_LDOUBLE</b> = <a class="el" href="typeinf_8hpp.html#a59a226ec408b8610feafdd4c32267a82">BT_FLOAT</a> | <a class="el" href="typeinf_8hpp.html#a3f4c3be08ef760f80e6123e5f43ada38">BTMT_LNGDBL</a></td></tr>
<tr class="memdesc:aa86134b88d5f0c1c33a482ba02e5a314"><td class="mdescLeft">&#160;</td><td class="mdescRight">long double <br /></td></tr>
<tr class="separator:aa86134b88d5f0c1c33a482ba02e5a314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d2b6cae3e1bc50dac609db191e33bc"><td class="memItemLeft" align="right" valign="top"><a id="ab1d2b6cae3e1bc50dac609db191e33bc" name="ab1d2b6cae3e1bc50dac609db191e33bc"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_TBYTE</b> = <a class="el" href="typeinf_8hpp.html#a59a226ec408b8610feafdd4c32267a82">BT_FLOAT</a> | <a class="el" href="typeinf_8hpp.html#a34f394b71c9b27c46560178e0054f79b">BTMT_SPECFLT</a></td></tr>
<tr class="memdesc:ab1d2b6cae3e1bc50dac609db191e33bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="typeinf_8hpp.html#a34f394b71c9b27c46560178e0054f79b" title="float (variable size).">BTMT_SPECFLT</a> <br /></td></tr>
<tr class="separator:ab1d2b6cae3e1bc50dac609db191e33bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861f45bbf58b9d699897e234b0905009"><td class="memItemLeft" align="right" valign="top"><a id="a861f45bbf58b9d699897e234b0905009" name="a861f45bbf58b9d699897e234b0905009"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_STRUCT</b> = <a class="el" href="typeinf_8hpp.html#a86c5e589737e005ba4741423fd2ca5c6">BT_COMPLEX</a> | <a class="el" href="typeinf_8hpp.html#acf095fd2f25df783b0f5a321d91c6adc">BTMT_STRUCT</a></td></tr>
<tr class="memdesc:a861f45bbf58b9d699897e234b0905009"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct <br /></td></tr>
<tr class="separator:a861f45bbf58b9d699897e234b0905009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5536b8782826bb2b925fc65c49788c"><td class="memItemLeft" align="right" valign="top"><a id="a0a5536b8782826bb2b925fc65c49788c" name="a0a5536b8782826bb2b925fc65c49788c"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_UNION</b> = <a class="el" href="typeinf_8hpp.html#a86c5e589737e005ba4741423fd2ca5c6">BT_COMPLEX</a> | <a class="el" href="typeinf_8hpp.html#af117f7735078132037de2553d7ea393a">BTMT_UNION</a></td></tr>
<tr class="memdesc:a0a5536b8782826bb2b925fc65c49788c"><td class="mdescLeft">&#160;</td><td class="mdescRight">union <br /></td></tr>
<tr class="separator:a0a5536b8782826bb2b925fc65c49788c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eee5573060ab34fdee9230f37d8369f"><td class="memItemLeft" align="right" valign="top"><a id="a5eee5573060ab34fdee9230f37d8369f" name="a5eee5573060ab34fdee9230f37d8369f"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_ENUM</b> = <a class="el" href="typeinf_8hpp.html#a86c5e589737e005ba4741423fd2ca5c6">BT_COMPLEX</a> | <a class="el" href="typeinf_8hpp.html#aa364f5b01c60e09fd5b216162817037c">BTMT_ENUM</a></td></tr>
<tr class="memdesc:a5eee5573060ab34fdee9230f37d8369f"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum <br /></td></tr>
<tr class="separator:a5eee5573060ab34fdee9230f37d8369f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e49eed2f4e754689e7bcc7f6efdd74"><td class="memItemLeft" align="right" valign="top"><a id="a64e49eed2f4e754689e7bcc7f6efdd74" name="a64e49eed2f4e754689e7bcc7f6efdd74"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BTF_TYPEDEF</b> = <a class="el" href="typeinf_8hpp.html#a86c5e589737e005ba4741423fd2ca5c6">BT_COMPLEX</a> | <a class="el" href="typeinf_8hpp.html#aa4e0907e07d1538053682550c2117290">BTMT_TYPEDEF</a></td></tr>
<tr class="memdesc:a64e49eed2f4e754689e7bcc7f6efdd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef <br /></td></tr>
<tr class="separator:a64e49eed2f4e754689e7bcc7f6efdd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2774527d973c5dd40e9f7e579c7af36"><td class="memItemLeft" align="right" valign="top"><a id="ab2774527d973c5dd40e9f7e579c7af36" name="ab2774527d973c5dd40e9f7e579c7af36"></a>
const <a class="el" href="typeinf_8hpp.html#a91970b0d779fe968b3b22572526048a0">type_sign_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>no_sign</b> = 0</td></tr>
<tr class="memdesc:ab2774527d973c5dd40e9f7e579c7af36"><td class="mdescLeft">&#160;</td><td class="mdescRight">no sign, or unknown <br /></td></tr>
<tr class="separator:ab2774527d973c5dd40e9f7e579c7af36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45de3aa578ef02a11d2bf2b17359862"><td class="memItemLeft" align="right" valign="top"><a id="af45de3aa578ef02a11d2bf2b17359862" name="af45de3aa578ef02a11d2bf2b17359862"></a>
const <a class="el" href="typeinf_8hpp.html#a91970b0d779fe968b3b22572526048a0">type_sign_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>type_signed</b> = 1</td></tr>
<tr class="memdesc:af45de3aa578ef02a11d2bf2b17359862"><td class="mdescLeft">&#160;</td><td class="mdescRight">signed type <br /></td></tr>
<tr class="separator:af45de3aa578ef02a11d2bf2b17359862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de8496252de025e429aec933c9c8aa3"><td class="memItemLeft" align="right" valign="top"><a id="a1de8496252de025e429aec933c9c8aa3" name="a1de8496252de025e429aec933c9c8aa3"></a>
const <a class="el" href="typeinf_8hpp.html#a91970b0d779fe968b3b22572526048a0">type_sign_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>type_unsigned</b> = 2</td></tr>
<tr class="memdesc:a1de8496252de025e429aec933c9c8aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">unsigned type <br /></td></tr>
<tr class="separator:a1de8496252de025e429aec933c9c8aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26159e027c25ac6883ebe5a4da05740"><td class="memItemLeft" align="right" valign="top"><a id="ac26159e027c25ac6883ebe5a4da05740" name="ac26159e027c25ac6883ebe5a4da05740"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_MASK</b> = 0x03</td></tr>
<tr class="separator:ac26159e027c25ac6883ebe5a4da05740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771c3366e1b6919acfe35a80c54290c3"><td class="memItemLeft" align="right" valign="top"><a id="a771c3366e1b6919acfe35a80c54290c3" name="a771c3366e1b6919acfe35a80c54290c3"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_UNKNOWN</b> = 0x00</td></tr>
<tr class="memdesc:a771c3366e1b6919acfe35a80c54290c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">unknown <br /></td></tr>
<tr class="separator:a771c3366e1b6919acfe35a80c54290c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9206003f6cc49fbd8d3d06d0e6f439ce"><td class="memItemLeft" align="right" valign="top"><a id="a9206003f6cc49fbd8d3d06d0e6f439ce" name="a9206003f6cc49fbd8d3d06d0e6f439ce"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_N8_F16</b> = 0x01</td></tr>
<tr class="memdesc:a9206003f6cc49fbd8d3d06d0e6f439ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">if sizeof(int)&lt;=2: near 1 byte, far 2 bytes <br /></td></tr>
<tr class="separator:a9206003f6cc49fbd8d3d06d0e6f439ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a7ae79db16213bffc6e707fb3421e3"><td class="memItemLeft" align="right" valign="top"><a id="ac8a7ae79db16213bffc6e707fb3421e3" name="ac8a7ae79db16213bffc6e707fb3421e3"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_N64</b> = 0x01</td></tr>
<tr class="memdesc:ac8a7ae79db16213bffc6e707fb3421e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">if sizeof(int)&gt;2: near 8 bytes, far 8 bytes <br /></td></tr>
<tr class="separator:ac8a7ae79db16213bffc6e707fb3421e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab29a6197838fd27762bfa444d02869"><td class="memItemLeft" align="right" valign="top"><a id="a1ab29a6197838fd27762bfa444d02869" name="a1ab29a6197838fd27762bfa444d02869"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_N16_F32</b> = 0x02</td></tr>
<tr class="memdesc:a1ab29a6197838fd27762bfa444d02869"><td class="mdescLeft">&#160;</td><td class="mdescRight">near 2 bytes, far 4 bytes <br /></td></tr>
<tr class="separator:a1ab29a6197838fd27762bfa444d02869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9b0b738a1057a74b1be34d526d745"><td class="memItemLeft" align="right" valign="top"><a id="a13e9b0b738a1057a74b1be34d526d745" name="a13e9b0b738a1057a74b1be34d526d745"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_N32_F48</b> = 0x03</td></tr>
<tr class="memdesc:a13e9b0b738a1057a74b1be34d526d745"><td class="mdescLeft">&#160;</td><td class="mdescRight">near 4 bytes, far 6 bytes <br /></td></tr>
<tr class="separator:a13e9b0b738a1057a74b1be34d526d745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2922449d0afbf620fd4fffc6ea1118a5"><td class="memItemLeft" align="right" valign="top"><a id="a2922449d0afbf620fd4fffc6ea1118a5" name="a2922449d0afbf620fd4fffc6ea1118a5"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_M_MASK</b> = 0x0C</td></tr>
<tr class="separator:a2922449d0afbf620fd4fffc6ea1118a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61152e81d5d4984da816ff4eea5e38e1"><td class="memItemLeft" align="right" valign="top"><a id="a61152e81d5d4984da816ff4eea5e38e1" name="a61152e81d5d4984da816ff4eea5e38e1"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_M_NN</b> = 0x00</td></tr>
<tr class="memdesc:a61152e81d5d4984da816ff4eea5e38e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">small: code=near, data=near (or unknown if CM_UNKNOWN) <br /></td></tr>
<tr class="separator:a61152e81d5d4984da816ff4eea5e38e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcc3b1abcde2c94f9351342fd1fb126"><td class="memItemLeft" align="right" valign="top"><a id="abbcc3b1abcde2c94f9351342fd1fb126" name="abbcc3b1abcde2c94f9351342fd1fb126"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_M_FF</b> = 0x04</td></tr>
<tr class="memdesc:abbcc3b1abcde2c94f9351342fd1fb126"><td class="mdescLeft">&#160;</td><td class="mdescRight">large: code=far, data=far <br /></td></tr>
<tr class="separator:abbcc3b1abcde2c94f9351342fd1fb126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1ac661734fbd809f3c1e4c749b85cf"><td class="memItemLeft" align="right" valign="top"><a id="aec1ac661734fbd809f3c1e4c749b85cf" name="aec1ac661734fbd809f3c1e4c749b85cf"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_M_NF</b> = 0x08</td></tr>
<tr class="memdesc:aec1ac661734fbd809f3c1e4c749b85cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">compact: code=near, data=far <br /></td></tr>
<tr class="separator:aec1ac661734fbd809f3c1e4c749b85cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87afd41e475f92f6b6f1e1dbb61ed659"><td class="memItemLeft" align="right" valign="top"><a id="a87afd41e475f92f6b6f1e1dbb61ed659" name="a87afd41e475f92f6b6f1e1dbb61ed659"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_M_FN</b> = 0x0C</td></tr>
<tr class="memdesc:a87afd41e475f92f6b6f1e1dbb61ed659"><td class="mdescLeft">&#160;</td><td class="mdescRight">medium: code=far, data=near <br /></td></tr>
<tr class="separator:a87afd41e475f92f6b6f1e1dbb61ed659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624b5fdba452b1a35e3e37a665aa25da"><td class="memItemLeft" align="right" valign="top"><a id="a624b5fdba452b1a35e3e37a665aa25da" name="a624b5fdba452b1a35e3e37a665aa25da"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_MASK</b> = 0xF0</td></tr>
<tr class="separator:a624b5fdba452b1a35e3e37a665aa25da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9fb8e1b23900c01e00c80be3a57ea5"><td class="memItemLeft" align="right" valign="top"><a id="a1f9fb8e1b23900c01e00c80be3a57ea5" name="a1f9fb8e1b23900c01e00c80be3a57ea5"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_INVALID</b> = 0x00</td></tr>
<tr class="memdesc:a1f9fb8e1b23900c01e00c80be3a57ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">this value is invalid <br /></td></tr>
<tr class="separator:a1f9fb8e1b23900c01e00c80be3a57ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8607c930b67577c7f39ac7a5d24612"><td class="memItemLeft" align="right" valign="top"><a id="a1d8607c930b67577c7f39ac7a5d24612" name="a1d8607c930b67577c7f39ac7a5d24612"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_UNKNOWN</b> = 0x10</td></tr>
<tr class="memdesc:a1d8607c930b67577c7f39ac7a5d24612"><td class="mdescLeft">&#160;</td><td class="mdescRight">unknown calling convention <br /></td></tr>
<tr class="separator:a1d8607c930b67577c7f39ac7a5d24612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecea308116df480106f38d080f73ab8e"><td class="memItemLeft" align="right" valign="top"><a id="aecea308116df480106f38d080f73ab8e" name="aecea308116df480106f38d080f73ab8e"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_VOIDARG</b> = 0x20</td></tr>
<tr class="memdesc:aecea308116df480106f38d080f73ab8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function without arguments if has other cc and argnum == 0, represent as f() - unknown list <br /></td></tr>
<tr class="separator:aecea308116df480106f38d080f73ab8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b8d9fb7c859971c035e23efe3cda0e"><td class="memItemLeft" align="right" valign="top"><a id="a11b8d9fb7c859971c035e23efe3cda0e" name="a11b8d9fb7c859971c035e23efe3cda0e"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_CDECL</b> = 0x30</td></tr>
<tr class="memdesc:a11b8d9fb7c859971c035e23efe3cda0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack <br /></td></tr>
<tr class="separator:a11b8d9fb7c859971c035e23efe3cda0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4d072bec04a20754290978b8b141be"><td class="memItemLeft" align="right" valign="top"><a id="a8e4d072bec04a20754290978b8b141be" name="a8e4d072bec04a20754290978b8b141be"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_ELLIPSIS</b> = 0x40</td></tr>
<tr class="memdesc:a8e4d072bec04a20754290978b8b141be"><td class="mdescLeft">&#160;</td><td class="mdescRight">cdecl + ellipsis <br /></td></tr>
<tr class="separator:a8e4d072bec04a20754290978b8b141be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d547c299b4716ea45c11fe81a7dbbbc"><td class="memItemLeft" align="right" valign="top"><a id="a1d547c299b4716ea45c11fe81a7dbbbc" name="a1d547c299b4716ea45c11fe81a7dbbbc"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_STDCALL</b> = 0x50</td></tr>
<tr class="memdesc:a1d547c299b4716ea45c11fe81a7dbbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack, purged <br /></td></tr>
<tr class="separator:a1d547c299b4716ea45c11fe81a7dbbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad53854e65b7d43e106739ce74f8f0f9"><td class="memItemLeft" align="right" valign="top"><a id="aad53854e65b7d43e106739ce74f8f0f9" name="aad53854e65b7d43e106739ce74f8f0f9"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_PASCAL</b> = 0x60</td></tr>
<tr class="memdesc:aad53854e65b7d43e106739ce74f8f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack, purged, reverse order of args <br /></td></tr>
<tr class="separator:aad53854e65b7d43e106739ce74f8f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb6a32c8e2932de0b3dc51a7fe4c42e"><td class="memItemLeft" align="right" valign="top"><a id="acdb6a32c8e2932de0b3dc51a7fe4c42e" name="acdb6a32c8e2932de0b3dc51a7fe4c42e"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_FASTCALL</b> = 0x70</td></tr>
<tr class="memdesc:acdb6a32c8e2932de0b3dc51a7fe4c42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack, purged (x86), first args are in regs (compiler-dependent) <br /></td></tr>
<tr class="separator:acdb6a32c8e2932de0b3dc51a7fe4c42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab857ab54b65bc64f6dbcafc03f1c7e6c"><td class="memItemLeft" align="right" valign="top"><a id="ab857ab54b65bc64f6dbcafc03f1c7e6c" name="ab857ab54b65bc64f6dbcafc03f1c7e6c"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_THISCALL</b> = 0x80</td></tr>
<tr class="memdesc:ab857ab54b65bc64f6dbcafc03f1c7e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack, purged (x86), first arg is in reg (compiler-dependent) <br /></td></tr>
<tr class="separator:ab857ab54b65bc64f6dbcafc03f1c7e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e442de3f0b1d2ff3ba9d55a0033d615"><td class="memItemLeft" align="right" valign="top"><a id="a6e442de3f0b1d2ff3ba9d55a0033d615" name="a6e442de3f0b1d2ff3ba9d55a0033d615"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_SWIFT</b> = 0x90</td></tr>
<tr class="memdesc:a6e442de3f0b1d2ff3ba9d55a0033d615"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Swift) arguments and return values in registers (compiler-dependent) <br /></td></tr>
<tr class="separator:a6e442de3f0b1d2ff3ba9d55a0033d615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fe26502529dff431e52823a24db36b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="typeinf_8hpp.html#a81fe26502529dff431e52823a24db36b">CM_CC_SPOILED</a> = 0xA0</td></tr>
<tr class="memdesc:a81fe26502529dff431e52823a24db36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is NOT a cc! Mark of __spoil record the low nibble is count and after n {spoilreg_t} present real cm_t byte.  <a href="typeinf_8hpp.html#a81fe26502529dff431e52823a24db36b">More...</a><br /></td></tr>
<tr class="separator:a81fe26502529dff431e52823a24db36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5963e5724f1a87ebb93f9cfbb1841816"><td class="memItemLeft" align="right" valign="top"><a id="a5963e5724f1a87ebb93f9cfbb1841816" name="a5963e5724f1a87ebb93f9cfbb1841816"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_GOLANG</b> = 0xB0</td></tr>
<tr class="memdesc:a5963e5724f1a87ebb93f9cfbb1841816"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Go) arguments and return value in stack <br /></td></tr>
<tr class="separator:a5963e5724f1a87ebb93f9cfbb1841816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b54fd88189de0df1945653a40c52d9"><td class="memItemLeft" align="right" valign="top"><a id="ac3b54fd88189de0df1945653a40c52d9" name="ac3b54fd88189de0df1945653a40c52d9"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_RESERVE3</b> = 0xC0</td></tr>
<tr class="separator:ac3b54fd88189de0df1945653a40c52d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c042d42c6daf03444d06907a8498b06"><td class="memItemLeft" align="right" valign="top"><a id="a6c042d42c6daf03444d06907a8498b06" name="a6c042d42c6daf03444d06907a8498b06"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_SPECIALE</b> = 0xD0</td></tr>
<tr class="memdesc:a6c042d42c6daf03444d06907a8498b06"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a377054c414ac35be6e5e9bf6c550b390" title="usercall: locations of all arguments and the return value are explicitly specified">CM_CC_SPECIAL</a> with ellipsis <br /></td></tr>
<tr class="separator:a6c042d42c6daf03444d06907a8498b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb1e9290d190ce7234dd016344f9ecd"><td class="memItemLeft" align="right" valign="top"><a id="a1eb1e9290d190ce7234dd016344f9ecd" name="a1eb1e9290d190ce7234dd016344f9ecd"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_SPECIALP</b> = 0xE0</td></tr>
<tr class="memdesc:a1eb1e9290d190ce7234dd016344f9ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal to <a class="el" href="typeinf_8hpp.html#a377054c414ac35be6e5e9bf6c550b390" title="usercall: locations of all arguments and the return value are explicitly specified">CM_CC_SPECIAL</a>, but with purged stack. <br /></td></tr>
<tr class="separator:a1eb1e9290d190ce7234dd016344f9ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377054c414ac35be6e5e9bf6c550b390"><td class="memItemLeft" align="right" valign="top"><a id="a377054c414ac35be6e5e9bf6c550b390" name="a377054c414ac35be6e5e9bf6c550b390"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CM_CC_SPECIAL</b> = 0xF0</td></tr>
<tr class="memdesc:a377054c414ac35be6e5e9bf6c550b390"><td class="mdescLeft">&#160;</td><td class="mdescRight">usercall: locations of all arguments and the return value are explicitly specified <br /></td></tr>
<tr class="separator:a377054c414ac35be6e5e9bf6c550b390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4f09353c2f3f849f1c6250145f613e"><td class="memItemLeft" align="right" valign="top"><a id="a3e4f09353c2f3f849f1c6250145f613e" name="a3e4f09353c2f3f849f1c6250145f613e"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BFA_NORET</b> = 0x01</td></tr>
<tr class="memdesc:a3e4f09353c2f3f849f1c6250145f613e"><td class="mdescLeft">&#160;</td><td class="mdescRight">__noreturn <br /></td></tr>
<tr class="separator:a3e4f09353c2f3f849f1c6250145f613e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaa327b8d82c192ac8efd26706c47a5"><td class="memItemLeft" align="right" valign="top"><a id="adbaa327b8d82c192ac8efd26706c47a5" name="adbaa327b8d82c192ac8efd26706c47a5"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BFA_PURE</b> = 0x02</td></tr>
<tr class="memdesc:adbaa327b8d82c192ac8efd26706c47a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">__pure <br /></td></tr>
<tr class="separator:adbaa327b8d82c192ac8efd26706c47a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba64992f3e9d281bd429c91a40f93825"><td class="memItemLeft" align="right" valign="top"><a id="aba64992f3e9d281bd429c91a40f93825" name="aba64992f3e9d281bd429c91a40f93825"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BFA_HIGH</b> = 0x04</td></tr>
<tr class="memdesc:aba64992f3e9d281bd429c91a40f93825"><td class="mdescLeft">&#160;</td><td class="mdescRight">high level prototype (with possibly hidden args) <br /></td></tr>
<tr class="separator:aba64992f3e9d281bd429c91a40f93825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17307c5ad75c6bfc26d3225481ad713d"><td class="memItemLeft" align="right" valign="top"><a id="a17307c5ad75c6bfc26d3225481ad713d" name="a17307c5ad75c6bfc26d3225481ad713d"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BFA_STATIC</b> = 0x08</td></tr>
<tr class="memdesc:a17307c5ad75c6bfc26d3225481ad713d"><td class="mdescLeft">&#160;</td><td class="mdescRight">static <br /></td></tr>
<tr class="separator:a17307c5ad75c6bfc26d3225481ad713d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cbb6e31f044cb533ff5fd95ba37d28"><td class="memItemLeft" align="right" valign="top"><a id="a99cbb6e31f044cb533ff5fd95ba37d28" name="a99cbb6e31f044cb533ff5fd95ba37d28"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BFA_VIRTUAL</b> = 0x10</td></tr>
<tr class="memdesc:a99cbb6e31f044cb533ff5fd95ba37d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <br /></td></tr>
<tr class="separator:a99cbb6e31f044cb533ff5fd95ba37d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8716ed0df6a2fc6816b449e08f0de444"><td class="memItemLeft" align="right" valign="top"><a id="a8716ed0df6a2fc6816b449e08f0de444" name="a8716ed0df6a2fc6816b449e08f0de444"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BFA_FUNC_MARKER</b> = 0x0F</td></tr>
<tr class="memdesc:a8716ed0df6a2fc6816b449e08f0de444"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is NOT a cc! (used internally as a marker) <br /></td></tr>
<tr class="separator:a8716ed0df6a2fc6816b449e08f0de444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c0f302579faa1d7bee1af5debc9d2e"><td class="memItemLeft" align="right" valign="top"><a id="a27c0f302579faa1d7bee1af5debc9d2e" name="a27c0f302579faa1d7bee1af5debc9d2e"></a>
const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BFA_FUNC_EXT_FORMAT</b> = 0x80</td></tr>
<tr class="memdesc:a27c0f302579faa1d7bee1af5debc9d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is NOT a real attribute (used internally as marker for extended format) <br /></td></tr>
<tr class="separator:a27c0f302579faa1d7bee1af5debc9d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5981f9b45ff7e81a6cb884107e73ffe7"><td class="memItemLeft" align="right" valign="top"><a id="a5981f9b45ff7e81a6cb884107e73ffe7" name="a5981f9b45ff7e81a6cb884107e73ffe7"></a>
const <a class="el" href="typeinf_8hpp.html#afaa486b80f279565c5e29558d6694afd">argloc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALOC_NONE</b> = 0</td></tr>
<tr class="memdesc:a5981f9b45ff7e81a6cb884107e73ffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">none <br /></td></tr>
<tr class="separator:a5981f9b45ff7e81a6cb884107e73ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade41123f7b84aadd16552c2d52943842"><td class="memItemLeft" align="right" valign="top"><a id="ade41123f7b84aadd16552c2d52943842" name="ade41123f7b84aadd16552c2d52943842"></a>
const <a class="el" href="typeinf_8hpp.html#afaa486b80f279565c5e29558d6694afd">argloc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALOC_STACK</b> = 1</td></tr>
<tr class="memdesc:ade41123f7b84aadd16552c2d52943842"><td class="mdescLeft">&#160;</td><td class="mdescRight">stack offset <br /></td></tr>
<tr class="separator:ade41123f7b84aadd16552c2d52943842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ee658648b8a9f916838508ab40fb5a"><td class="memItemLeft" align="right" valign="top"><a id="a77ee658648b8a9f916838508ab40fb5a" name="a77ee658648b8a9f916838508ab40fb5a"></a>
const <a class="el" href="typeinf_8hpp.html#afaa486b80f279565c5e29558d6694afd">argloc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALOC_DIST</b> = 2</td></tr>
<tr class="memdesc:a77ee658648b8a9f916838508ab40fb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">distributed (scattered) <br /></td></tr>
<tr class="separator:a77ee658648b8a9f916838508ab40fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0445d0ad6d0681841a3ff71c1d2305"><td class="memItemLeft" align="right" valign="top"><a id="aac0445d0ad6d0681841a3ff71c1d2305" name="aac0445d0ad6d0681841a3ff71c1d2305"></a>
const <a class="el" href="typeinf_8hpp.html#afaa486b80f279565c5e29558d6694afd">argloc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALOC_REG1</b> = 3</td></tr>
<tr class="memdesc:aac0445d0ad6d0681841a3ff71c1d2305"><td class="mdescLeft">&#160;</td><td class="mdescRight">one register (and offset within it) <br /></td></tr>
<tr class="separator:aac0445d0ad6d0681841a3ff71c1d2305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d78615d7e58de9c53e5036c09c7f558"><td class="memItemLeft" align="right" valign="top"><a id="a7d78615d7e58de9c53e5036c09c7f558" name="a7d78615d7e58de9c53e5036c09c7f558"></a>
const <a class="el" href="typeinf_8hpp.html#afaa486b80f279565c5e29558d6694afd">argloc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALOC_REG2</b> = 4</td></tr>
<tr class="memdesc:a7d78615d7e58de9c53e5036c09c7f558"><td class="mdescLeft">&#160;</td><td class="mdescRight">register pair <br /></td></tr>
<tr class="separator:a7d78615d7e58de9c53e5036c09c7f558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72931cfa80f89bd8e4c6bf512391d695"><td class="memItemLeft" align="right" valign="top"><a id="a72931cfa80f89bd8e4c6bf512391d695" name="a72931cfa80f89bd8e4c6bf512391d695"></a>
const <a class="el" href="typeinf_8hpp.html#afaa486b80f279565c5e29558d6694afd">argloc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALOC_RREL</b> = 5</td></tr>
<tr class="memdesc:a72931cfa80f89bd8e4c6bf512391d695"><td class="mdescLeft">&#160;</td><td class="mdescRight">register relative <br /></td></tr>
<tr class="separator:a72931cfa80f89bd8e4c6bf512391d695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9342b6c4b8dcb9c10ee69c2a5251f3dc"><td class="memItemLeft" align="right" valign="top"><a id="a9342b6c4b8dcb9c10ee69c2a5251f3dc" name="a9342b6c4b8dcb9c10ee69c2a5251f3dc"></a>
const <a class="el" href="typeinf_8hpp.html#afaa486b80f279565c5e29558d6694afd">argloc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALOC_STATIC</b> = 6</td></tr>
<tr class="memdesc:a9342b6c4b8dcb9c10ee69c2a5251f3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">global address <br /></td></tr>
<tr class="separator:a9342b6c4b8dcb9c10ee69c2a5251f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be7eb6681fc4a4396bfd4ba9b28af95"><td class="memItemLeft" align="right" valign="top"><a id="a6be7eb6681fc4a4396bfd4ba9b28af95" name="a6be7eb6681fc4a4396bfd4ba9b28af95"></a>
const <a class="el" href="typeinf_8hpp.html#afaa486b80f279565c5e29558d6694afd">argloc_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ALOC_CUSTOM</b> = 7</td></tr>
<tr class="memdesc:a6be7eb6681fc4a4396bfd4ba9b28af95"><td class="mdescLeft">&#160;</td><td class="mdescRight">custom argloc (7 or higher) <br /></td></tr>
<tr class="separator:a6be7eb6681fc4a4396bfd4ba9b28af95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703ec61bdd676dec86e178dc1ab255c0"><td class="memItemLeft" align="right" valign="top"><a id="a703ec61bdd676dec86e178dc1ab255c0" name="a703ec61bdd676dec86e178dc1ab255c0"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>C_PC_TINY</b> = (<a class="el" href="typeinf_8hpp.html#a1ab29a6197838fd27762bfa444d02869">CM_N16_F32</a> | <a class="el" href="typeinf_8hpp.html#a61152e81d5d4984da816ff4eea5e38e1">CM_M_NN</a>)</td></tr>
<tr class="separator:a703ec61bdd676dec86e178dc1ab255c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ca0f5efb2f441cd9512d91011521d3"><td class="memItemLeft" align="right" valign="top"><a id="a38ca0f5efb2f441cd9512d91011521d3" name="a38ca0f5efb2f441cd9512d91011521d3"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>C_PC_SMALL</b> = (<a class="el" href="typeinf_8hpp.html#a1ab29a6197838fd27762bfa444d02869">CM_N16_F32</a> | <a class="el" href="typeinf_8hpp.html#a61152e81d5d4984da816ff4eea5e38e1">CM_M_NN</a>)</td></tr>
<tr class="separator:a38ca0f5efb2f441cd9512d91011521d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbda27c9e20233632dd8581a325533e"><td class="memItemLeft" align="right" valign="top"><a id="aabbda27c9e20233632dd8581a325533e" name="aabbda27c9e20233632dd8581a325533e"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>C_PC_COMPACT</b> = (<a class="el" href="typeinf_8hpp.html#a1ab29a6197838fd27762bfa444d02869">CM_N16_F32</a> | <a class="el" href="typeinf_8hpp.html#aec1ac661734fbd809f3c1e4c749b85cf">CM_M_NF</a>)</td></tr>
<tr class="separator:aabbda27c9e20233632dd8581a325533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5310ac65e3ba84567e76cf0cb41ddc8a"><td class="memItemLeft" align="right" valign="top"><a id="a5310ac65e3ba84567e76cf0cb41ddc8a" name="a5310ac65e3ba84567e76cf0cb41ddc8a"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>C_PC_MEDIUM</b> = (<a class="el" href="typeinf_8hpp.html#a1ab29a6197838fd27762bfa444d02869">CM_N16_F32</a> | <a class="el" href="typeinf_8hpp.html#a87afd41e475f92f6b6f1e1dbb61ed659">CM_M_FN</a>)</td></tr>
<tr class="separator:a5310ac65e3ba84567e76cf0cb41ddc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6bfe8be98dcc8fa524f116c7232eef"><td class="memItemLeft" align="right" valign="top"><a id="a5e6bfe8be98dcc8fa524f116c7232eef" name="a5e6bfe8be98dcc8fa524f116c7232eef"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>C_PC_LARGE</b> = (<a class="el" href="typeinf_8hpp.html#a1ab29a6197838fd27762bfa444d02869">CM_N16_F32</a> | <a class="el" href="typeinf_8hpp.html#abbcc3b1abcde2c94f9351342fd1fb126">CM_M_FF</a>)</td></tr>
<tr class="separator:a5e6bfe8be98dcc8fa524f116c7232eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe0a366ce567586f794ed1e06df1fa2"><td class="memItemLeft" align="right" valign="top"><a id="a8fe0a366ce567586f794ed1e06df1fa2" name="a8fe0a366ce567586f794ed1e06df1fa2"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>C_PC_HUGE</b> = (<a class="el" href="typeinf_8hpp.html#a1ab29a6197838fd27762bfa444d02869">CM_N16_F32</a> | <a class="el" href="typeinf_8hpp.html#abbcc3b1abcde2c94f9351342fd1fb126">CM_M_FF</a>)</td></tr>
<tr class="separator:a8fe0a366ce567586f794ed1e06df1fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dd6b7917cae74db81257c8b3eb8744"><td class="memItemLeft" align="right" valign="top"><a id="a20dd6b7917cae74db81257c8b3eb8744" name="a20dd6b7917cae74db81257c8b3eb8744"></a>
const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>C_PC_FLAT</b> = (<a class="el" href="typeinf_8hpp.html#a13e9b0b738a1057a74b1be34d526d745">CM_N32_F48</a> | <a class="el" href="typeinf_8hpp.html#a61152e81d5d4984da816ff4eea5e38e1">CM_M_NN</a>)</td></tr>
<tr class="separator:a20dd6b7917cae74db81257c8b3eb8744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c611a8605bf67f12b8dbf02227074"><td class="memItemLeft" align="right" valign="top"><a id="a3c5c611a8605bf67f12b8dbf02227074" name="a3c5c611a8605bf67f12b8dbf02227074"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_MASK</b> = 0x0F</td></tr>
<tr class="separator:a3c5c611a8605bf67f12b8dbf02227074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a92f388d41e4a0996e66763eb09092b"><td class="memItemLeft" align="right" valign="top"><a id="a5a92f388d41e4a0996e66763eb09092b" name="a5a92f388d41e4a0996e66763eb09092b"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_UNK</b> = 0x00</td></tr>
<tr class="memdesc:a5a92f388d41e4a0996e66763eb09092b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unknown. <br /></td></tr>
<tr class="separator:a5a92f388d41e4a0996e66763eb09092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad876a67415a612fa2148b9290eb202cf"><td class="memItemLeft" align="right" valign="top"><a id="ad876a67415a612fa2148b9290eb202cf" name="ad876a67415a612fa2148b9290eb202cf"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_MS</b> = 0x01</td></tr>
<tr class="memdesc:ad876a67415a612fa2148b9290eb202cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visual C++. <br /></td></tr>
<tr class="separator:ad876a67415a612fa2148b9290eb202cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8451a3a255400096698c33f576aa3a27"><td class="memItemLeft" align="right" valign="top"><a id="a8451a3a255400096698c33f576aa3a27" name="a8451a3a255400096698c33f576aa3a27"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_BC</b> = 0x02</td></tr>
<tr class="memdesc:a8451a3a255400096698c33f576aa3a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borland C++. <br /></td></tr>
<tr class="separator:a8451a3a255400096698c33f576aa3a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a36a8eeecb37fdf4bfd38967b3abc42"><td class="memItemLeft" align="right" valign="top"><a id="a0a36a8eeecb37fdf4bfd38967b3abc42" name="a0a36a8eeecb37fdf4bfd38967b3abc42"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_WATCOM</b> = 0x03</td></tr>
<tr class="memdesc:a0a36a8eeecb37fdf4bfd38967b3abc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watcom C++. <br /></td></tr>
<tr class="separator:a0a36a8eeecb37fdf4bfd38967b3abc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f72af77206ae6e513468b0b2d0d8d7d"><td class="memItemLeft" align="right" valign="top"><a id="a8f72af77206ae6e513468b0b2d0d8d7d" name="a8f72af77206ae6e513468b0b2d0d8d7d"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_GNU</b> = 0x06</td></tr>
<tr class="memdesc:a8f72af77206ae6e513468b0b2d0d8d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GNU C++. <br /></td></tr>
<tr class="separator:a8f72af77206ae6e513468b0b2d0d8d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1030f9c3d3971db56005d7f6709078"><td class="memItemLeft" align="right" valign="top"><a id="afc1030f9c3d3971db56005d7f6709078" name="afc1030f9c3d3971db56005d7f6709078"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_VISAGE</b> = 0x07</td></tr>
<tr class="memdesc:afc1030f9c3d3971db56005d7f6709078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visual Age C++. <br /></td></tr>
<tr class="separator:afc1030f9c3d3971db56005d7f6709078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09579faa922db2326a2d339ee77f4d39"><td class="memItemLeft" align="right" valign="top"><a id="a09579faa922db2326a2d339ee77f4d39" name="a09579faa922db2326a2d339ee77f4d39"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_BP</b> = 0x08</td></tr>
<tr class="memdesc:a09579faa922db2326a2d339ee77f4d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delphi. <br /></td></tr>
<tr class="separator:a09579faa922db2326a2d339ee77f4d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bdf23b2ef18f213d7b492be498c40e"><td class="memItemLeft" align="right" valign="top"><a id="ae1bdf23b2ef18f213d7b492be498c40e" name="ae1bdf23b2ef18f213d7b492be498c40e"></a>
const <a class="el" href="ida_8hpp.html#ae36605f575cb0bd001d6b89877734fa2">comp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>COMP_UNSURE</b> = 0x80</td></tr>
<tr class="memdesc:ae1bdf23b2ef18f213d7b492be498c40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">uncertain compiler id <br /></td></tr>
<tr class="separator:ae1bdf23b2ef18f213d7b492be498c40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfbf55f283e8e1deaf195dc2576f63d"><td class="memItemLeft" align="right" valign="top"><a id="a8dfbf55f283e8e1deaf195dc2576f63d" name="a8dfbf55f283e8e1deaf195dc2576f63d"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>BADSIZE</b> = size_t(-1)</td></tr>
<tr class="memdesc:a8dfbf55f283e8e1deaf195dc2576f63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">bad type size <br /></td></tr>
<tr class="separator:a8dfbf55f283e8e1deaf195dc2576f63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad447f7a11c27974f14c5b6d303ed4213"><td class="memItemLeft" align="right" valign="top"><a id="ad447f7a11c27974f14c5b6d303ed4213" name="ad447f7a11c27974f14c5b6d303ed4213"></a>
const <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>BADORD</b> = <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>(-1)</td></tr>
<tr class="memdesc:ad447f7a11c27974f14c5b6d303ed4213"><td class="mdescLeft">&#160;</td><td class="mdescRight">invalid type ordinal <br /></td></tr>
<tr class="separator:ad447f7a11c27974f14c5b6d303ed4213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41407e17da4d0e535fb1384b498ebb43"><td class="memItemLeft" align="right" valign="top"><a id="a41407e17da4d0e535fb1384b498ebb43" name="a41407e17da4d0e535fb1384b498ebb43"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>FIRST_NONTRIVIAL_TYPID</b> = 0x100</td></tr>
<tr class="memdesc:a41407e17da4d0e535fb1384b498ebb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the first bit describing a nontrivial type. <br /></td></tr>
<tr class="separator:a41407e17da4d0e535fb1384b498ebb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d99d30a296a37f01b39f6d84986ebf"><td class="memItemLeft" align="right" valign="top"><a id="a54d99d30a296a37f01b39f6d84986ebf" name="a54d99d30a296a37f01b39f6d84986ebf"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>TYPID_ISREF</b> = 0x100</td></tr>
<tr class="memdesc:a54d99d30a296a37f01b39f6d84986ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies that a type that is a typeref. <br /></td></tr>
<tr class="separator:a54d99d30a296a37f01b39f6d84986ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa59fbf8ebded3aa6b709cd8c0d782"><td class="memItemLeft" align="right" valign="top"><a id="a21aa59fbf8ebded3aa6b709cd8c0d782" name="a21aa59fbf8ebded3aa6b709cd8c0d782"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>TYPID_SHIFT</b> = 9</td></tr>
<tr class="memdesc:a21aa59fbf8ebded3aa6b709cd8c0d782"><td class="mdescLeft">&#160;</td><td class="mdescRight">First type detail bit. <br /></td></tr>
<tr class="separator:a21aa59fbf8ebded3aa6b709cd8c0d782"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Describes the type information records in IDA. </p>
<p >The recommended way of using type info is to use the <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a> class. The type information is internally kept as an array of bytes terminated by 0.</p>
<p >Items in brackets [] are optional and sometimes are omitted. <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733" title="byte sequence used to describe a type in IDA (see Type flags)">type_t</a>... means a sequence of <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733" title="byte sequence used to describe a type in IDA (see Type flags)">type_t</a> bytes which defines a type.</p>
<dl class="section note"><dt>Note</dt><dd>to work with the types of instructions or data in the database, use get_tinfo()/set_tinfo() and similar functions. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1065a51e16a3c2c241ab10e9d2b87b07" name="a1065a51e16a3c2c241ab10e9d2b87b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1065a51e16a3c2c241ab10e9d2b87b07">&#9670;&nbsp;</a></span>ARGLOC_HELPER_DEFINITIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ARGLOC_HELPER_DEFINITIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">decl</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">decl <span class="keywordtype">void</span> ida_export copy_argloc(<a class="code hl_class" href="classargloc__t.html">argloc_t</a> *dst, <span class="keyword">const</span> <a class="code hl_class" href="classargloc__t.html">argloc_t</a> *src); \</div>
<div class="line">decl <span class="keywordtype">void</span> ida_export cleanup_argloc(<a class="code hl_class" href="classargloc__t.html">argloc_t</a> *vloc);\</div>
<div class="line">decl <span class="keywordtype">int</span> ida_export compare_arglocs(<span class="keyword">const</span> <a class="code hl_class" href="classargloc__t.html">argloc_t</a> &amp;a, <span class="keyword">const</span> <a class="code hl_class" href="classargloc__t.html">argloc_t</a> &amp;b);</div>
<div class="ttc" id="aclassargloc__t_html"><div class="ttname"><a href="classargloc__t.html">argloc_t</a></div><div class="ttdoc">Describes an argument location.</div><div class="ttdef"><b>Definition:</b> typeinf.hpp:971</div></div>
</div><!-- fragment -->
<p>Helper to declare common <a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> related functions. </p>

</div>
</div>
<a id="a01db4a44ee642c8b9cb2fc022c9ee615" name="a01db4a44ee642c8b9cb2fc022c9ee615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01db4a44ee642c8b9cb2fc022c9ee615">&#9670;&nbsp;</a></span>HTI_PAK_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HTI_PAK_SHIFT&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shift for <a class="el" href="typeinf_8hpp.html#adf2bfd701e01e14726882db806328b93" title="explicit structure pack value (#pragma pack)">HTI_PAK</a>. </p>
<p >This field should be used if you want to remember an explicit pack value for each structure/union type. See <a class="el" href="typeinf_8hpp.html#adf2bfd701e01e14726882db806328b93" title="explicit structure pack value (#pragma pack)">HTI_PAK</a>... definitions </p>

</div>
</div>
<a id="aced117327d7b21c347311a28a8676fe2" name="aced117327d7b21c347311a28a8676fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced117327d7b21c347311a28a8676fe2">&#9670;&nbsp;</a></span>IMPTYPE_LOCAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IMPTYPE_LOCAL&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the type is local, the struct/enum won't be marked as til type. </p>
<p >there is no need to specify this bit if til==idati, the kernel will set it automatically </p>

</div>
</div>
<a id="aa2d5efeca5c98ebbe16208d506df4231" name="aa2d5efeca5c98ebbe16208d506df4231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d5efeca5c98ebbe16208d506df4231">&#9670;&nbsp;</a></span>SUDT_UNEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SUDT_UNEX&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>references to nonexistent member types are acceptable; in this case it is better to set the corresponding <a class="el" href="structudt__member__t.html#aa2531c429ae5d76784c359fd1ef07105" title="field alignment (shift amount)">udt_member_t::fda</a> field to the type alignment. </p>
<p >If this field is not set, ida will try to guess the alignment. </p>

</div>
</div>
<a id="afc7e55c621c65b2a81792e39a67d75b2" name="afc7e55c621c65b2a81792e39a67d75b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7e55c621c65b2a81792e39a67d75b2">&#9670;&nbsp;</a></span>STRMEM_OFFSET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRMEM_OFFSET&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get member by offset </p>
<ul>
<li>in: udm-&gt;offset - is a member offset in bits </li>
</ul>

</div>
</div>
<a id="aad91f2151cfd8e41e7f937287bf18f56" name="aad91f2151cfd8e41e7f937287bf18f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad91f2151cfd8e41e7f937287bf18f56">&#9670;&nbsp;</a></span>STRMEM_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRMEM_INDEX&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get member by number </p>
<ul>
<li>in: udm-&gt;offset - is a member number </li>
</ul>

</div>
</div>
<a id="a0b5ba39c4308bbc445aaa8bfc5315bfd" name="a0b5ba39c4308bbc445aaa8bfc5315bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5ba39c4308bbc445aaa8bfc5315bfd">&#9670;&nbsp;</a></span>STRMEM_AUTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRMEM_AUTO&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get member by offset if struct, or get member by index if union </p>
<ul>
<li>nb: union: index is stored in the udm-&gt;offset field!</li>
<li>nb: struct: offset is in bytes (not in bits)! </li>
</ul>

</div>
</div>
<a id="a8c04aa29f158d3544957d5bf9513115a" name="a8c04aa29f158d3544957d5bf9513115a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c04aa29f158d3544957d5bf9513115a">&#9670;&nbsp;</a></span>STRMEM_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRMEM_NAME&#160;&#160;&#160;0x0003</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get member by name </p>
<ul>
<li>in: udm-&gt;name - the desired member name. </li>
</ul>

</div>
</div>
<a id="a62e2d52ab4b1acb0ed5571b7135ee6dd" name="a62e2d52ab4b1acb0ed5571b7135ee6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e2d52ab4b1acb0ed5571b7135ee6dd">&#9670;&nbsp;</a></span>STRMEM_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRMEM_TYPE&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get member by type. </p>
<ul>
<li>in: udm-&gt;type - the desired member type. member types are compared with tinfo_t::equals_to() </li>
</ul>

</div>
</div>
<a id="a0e3a31e8de28a5b68b31fd42d8465048" name="a0e3a31e8de28a5b68b31fd42d8465048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3a31e8de28a5b68b31fd42d8465048">&#9670;&nbsp;</a></span>STRMEM_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRMEM_SIZE&#160;&#160;&#160;0x0005</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get member by size. </p>
<ul>
<li>in: udm-&gt;size - the desired member size. </li>
</ul>

</div>
</div>
<a id="af9ab6d5aeb400abaec8c64d4849d049d" name="af9ab6d5aeb400abaec8c64d4849d049d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ab6d5aeb400abaec8c64d4849d049d">&#9670;&nbsp;</a></span>STRMEM_SKIP_EMPTY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRMEM_SKIP_EMPTY&#160;&#160;&#160;0x20000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>can be combined with <a class="el" href="typeinf_8hpp.html#afc7e55c621c65b2a81792e39a67d75b2" title="get member by offset">STRMEM_OFFSET</a>, <a class="el" href="typeinf_8hpp.html#a0b5ba39c4308bbc445aaa8bfc5315bfd" title="get member by offset if struct, or get member by index if union">STRMEM_AUTO</a> skip empty members (i.e. </p>
<p >having zero size) only last empty member can be returned </p>

</div>
</div>
<a id="ae70e5a781439aef62e61cdfe061f7170" name="ae70e5a781439aef62e61cdfe061f7170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70e5a781439aef62e61cdfe061f7170">&#9670;&nbsp;</a></span>STRMEM_ANON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRMEM_ANON&#160;&#160;&#160;0x80000000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>can be combined with <a class="el" href="typeinf_8hpp.html#a8c04aa29f158d3544957d5bf9513115a" title="get member by name">STRMEM_NAME</a>: look inside anonymous members too. </p>

</div>
</div>
<a id="afce293d4927b47b87edd19fea49b50ae" name="afce293d4927b47b87edd19fea49b50ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce293d4927b47b87edd19fea49b50ae">&#9670;&nbsp;</a></span>TA_FORMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TA_FORMAT&#160;&#160;&#160;&quot;format&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>info about the 'format' argument. </p>
<p >3 times pack_dd: <a class="el" href="typeinf_8hpp.html#a4fb7ef3b5dbe1b8c187a5314d02baaf3">format_functype_t</a>, argument number of 'format', argument number of '...' </p>

</div>
</div>
<a id="ac2cd3059626ab4ab40a530fdfcc99abb" name="ac2cd3059626ab4ab40a530fdfcc99abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cd3059626ab4ab40a530fdfcc99abb">&#9670;&nbsp;</a></span>PTV_DEREF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PTV_DEREF&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>take value to print from the debugged process. </p>
<p ><a class="el" href="expr_8hpp.html#a9366c439f83b49166170067f8ee071fc" title="Integer (see idc_value_t::num)">VT_LONG</a>: the address is specified by <a class="el" href="classidc__value__t.html#aa09e4449f34001012e2f53248eb349fb" title="VT_LONG">idc_value_t::num</a> <a class="el" href="expr_8hpp.html#a73ee8713be7855fc5fece9efd07517c0" title="void *">VT_PVOID</a>: <a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> is pointed by <a class="el" href="classidc__value__t.html#af712265fb1474ef495db2cf84d6ec6cc" title="VT_PVOID">idc_value_t::pvoid</a> </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a034013ece7194a003ffd1727075100d2" name="a034013ece7194a003ffd1727075100d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034013ece7194a003ffd1727075100d2">&#9670;&nbsp;</a></span>h2ti_type_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int idaapi h2ti_type_cb(const char *name, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, const char *cmt, const uint64 *value, void *cb_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This callback will be called for each type/variable declaration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>var/func/type name </td></tr>
    <tr><td class="paramname">tif</td><td>type info </td></tr>
    <tr><td class="paramname">cmt</td><td>main comment </td></tr>
    <tr><td class="paramname">value</td><td>symbol value </td></tr>
    <tr><td class="paramname">cb_data</td><td>data passed to callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">T_CBBRKDEF</td><td>the type declaration won't be saved in the til </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcc521f1e3d068d8cdf760885a8f53c4" name="abcc521f1e3d068d8cdf760885a8f53c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc521f1e3d068d8cdf760885a8f53c4">&#9670;&nbsp;</a></span>printer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int printer_t(const char *format,...)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a printing callback when parsing types. </p>
<p >See <a class="el" href="typeinf_8hpp.html#a6a2c9c8787240c725a87bb5cb5ffc7a4" title="Convert declarations to type_t*.">h2ti()</a> and <a class="el" href="typeinf_8hpp.html#ae4cec61d812cfc0acc08453742b729b3" title="Parse many declarations and store them in a til.">parse_decls()</a>. </p>

</div>
</div>
<a id="ab50d6548ef1add1a4a33341539d9f737" name="ab50d6548ef1add1a4a33341539d9f737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50d6548ef1add1a4a33341539d9f737">&#9670;&nbsp;</a></span>local_tinfo_predicate_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int idaapi local_tinfo_predicate_t(<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ord, const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;type, void *ud)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls which types are displayed/selected when choosing local types. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>skip type </td></tr>
    <tr><td class="paramname">1</td><td>include </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1213616e618bb2e2eeef3789c5a3066a" name="a1213616e618bb2e2eeef3789c5a3066a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1213616e618bb2e2eeef3789c5a3066a">&#9670;&nbsp;</a></span>argreg_policy_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="typeinf_8hpp.html#a1213616e618bb2e2eeef3789c5a3066a">argreg_policy_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function argument passing: how GP &amp; FP registers cooperate with each other. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1213616e618bb2e2eeef3789c5a3066aa78b105fc74836db7dfc4892af9e69c06" name="a1213616e618bb2e2eeef3789c5a3066aa78b105fc74836db7dfc4892af9e69c06"></a>ARGREGS_GP_ONLY&#160;</td><td class="fielddoc"><p >GP registers used for all arguments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1213616e618bb2e2eeef3789c5a3066aaed785e829f5e0b1f404dc2b512cb0698" name="a1213616e618bb2e2eeef3789c5a3066aaed785e829f5e0b1f404dc2b512cb0698"></a>ARGREGS_INDEPENDENT&#160;</td><td class="fielddoc"><p >FP/GP registers used separately (like gcc64) </p>
</td></tr>
<tr><td class="fieldname"><a id="a1213616e618bb2e2eeef3789c5a3066aae440e0d293e7994fec765a045ec0b7de" name="a1213616e618bb2e2eeef3789c5a3066aae440e0d293e7994fec765a045ec0b7de"></a>ARGREGS_BY_SLOTS&#160;</td><td class="fielddoc"><p >fixed FP/GP register per each slot (like vc64) </p>
</td></tr>
<tr><td class="fieldname"><a id="a1213616e618bb2e2eeef3789c5a3066aaa5cdf7a88dcb45b3f820bb4a854229d6" name="a1213616e618bb2e2eeef3789c5a3066aaa5cdf7a88dcb45b3f820bb4a854229d6"></a>ARGREGS_FP_CONSUME_GP&#160;</td><td class="fielddoc"><p >FP register also consumes one or more GP regs but not vice versa (aix ppc ABI) </p>
</td></tr>
<tr><td class="fieldname"><a id="a1213616e618bb2e2eeef3789c5a3066aaea1dbb58dd762e078ac9b45b2e19975e" name="a1213616e618bb2e2eeef3789c5a3066aaea1dbb58dd762e078ac9b45b2e19975e"></a>ARGREGS_MIPS_O32&#160;</td><td class="fielddoc"><p >MIPS ABI o32. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9c9a05934a8418932a82a2d39476d97d" name="a9c9a05934a8418932a82a2d39476d97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9a05934a8418932a82a2d39476d97d">&#9670;&nbsp;</a></span>sclass_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; storage class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9c9a05934a8418932a82a2d39476d97da89e3586b675e0685da04bfd54a2502a9" name="a9c9a05934a8418932a82a2d39476d97da89e3586b675e0685da04bfd54a2502a9"></a>sc_unk&#160;</td><td class="fielddoc"><p >unknown </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9a05934a8418932a82a2d39476d97dacf0ce1cb3d478a7f62557c3f8f446e11" name="a9c9a05934a8418932a82a2d39476d97dacf0ce1cb3d478a7f62557c3f8f446e11"></a>sc_type&#160;</td><td class="fielddoc"><p >typedef </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9a05934a8418932a82a2d39476d97da0c593cc88b83620bdb34f43f9e5dda31" name="a9c9a05934a8418932a82a2d39476d97da0c593cc88b83620bdb34f43f9e5dda31"></a>sc_ext&#160;</td><td class="fielddoc"><p >extern </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9a05934a8418932a82a2d39476d97da551b28b82cb4482f30efa4ebe9b4e473" name="a9c9a05934a8418932a82a2d39476d97da551b28b82cb4482f30efa4ebe9b4e473"></a>sc_stat&#160;</td><td class="fielddoc"><p >static </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9a05934a8418932a82a2d39476d97da962c56792f11d705f2feba400d5a7d09" name="a9c9a05934a8418932a82a2d39476d97da962c56792f11d705f2feba400d5a7d09"></a>sc_reg&#160;</td><td class="fielddoc"><p >register </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9a05934a8418932a82a2d39476d97da172b8da8be19c3ba9754022815316154" name="a9c9a05934a8418932a82a2d39476d97da172b8da8be19c3ba9754022815316154"></a>sc_auto&#160;</td><td class="fielddoc"><p >auto </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9a05934a8418932a82a2d39476d97da5e33945d971e16746389317965a7ac10" name="a9c9a05934a8418932a82a2d39476d97da5e33945d971e16746389317965a7ac10"></a>sc_friend&#160;</td><td class="fielddoc"><p >friend </p>
</td></tr>
<tr><td class="fieldname"><a id="a9c9a05934a8418932a82a2d39476d97da9a8553f5d79dbbec9b4c5d572a2e3489" name="a9c9a05934a8418932a82a2d39476d97da9a8553f5d79dbbec9b4c5d572a2e3489"></a>sc_virt&#160;</td><td class="fielddoc"><p >virtual </p>
</td></tr>
</table>

</div>
</div>
<a id="a4b2c98771820db5f78f2e754c97c0aaa" name="a4b2c98771820db5f78f2e754c97c0aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b2c98771820db5f78f2e754c97c0aaa">&#9670;&nbsp;</a></span>tinfo_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaa">tinfo_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes for save_tinfo functions: </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4b2c98771820db5f78f2e754c97c0aaaaf1e302c7895bfa27324ea87b2613f934" name="a4b2c98771820db5f78f2e754c97c0aaaaf1e302c7895bfa27324ea87b2613f934"></a>TERR_OK&#160;</td><td class="fielddoc"><p >ok </p>
</td></tr>
<tr><td class="fieldname"><a id="a4b2c98771820db5f78f2e754c97c0aaaab5040c8d0d7d40aaec3229056feeb441" name="a4b2c98771820db5f78f2e754c97c0aaaab5040c8d0d7d40aaec3229056feeb441"></a>TERR_SAVE&#160;</td><td class="fielddoc"><p >failed to save </p>
</td></tr>
<tr><td class="fieldname"><a id="a4b2c98771820db5f78f2e754c97c0aaaa8d887bee845b2f1ef5f2b91509a7d8a7" name="a4b2c98771820db5f78f2e754c97c0aaaa8d887bee845b2f1ef5f2b91509a7d8a7"></a>TERR_SERIALIZE&#160;</td><td class="fielddoc"><p >failed to serialize </p>
</td></tr>
<tr><td class="fieldname"><a id="a4b2c98771820db5f78f2e754c97c0aaaaed75b318f4c08674eb57ba88cdd7c420" name="a4b2c98771820db5f78f2e754c97c0aaaaed75b318f4c08674eb57ba88cdd7c420"></a>TERR_WRONGNAME&#160;</td><td class="fielddoc"><p >name is not acceptable </p>
</td></tr>
<tr><td class="fieldname"><a id="a4b2c98771820db5f78f2e754c97c0aaaad5b485a8aea98a39638a33b0fdf3aece" name="a4b2c98771820db5f78f2e754c97c0aaaad5b485a8aea98a39638a33b0fdf3aece"></a>TERR_BADSYNC&#160;</td><td class="fielddoc"><p >failed to synchronize with IDB </p>
</td></tr>
</table>

</div>
</div>
<a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5cba82dd91a1d49c2e0cdd8f5d5211">&#9670;&nbsp;</a></span>stock_type_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211">stock_type_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IDs for common types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211ad2201926ec41b27053183ae1156551d2" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211ad2201926ec41b27053183ae1156551d2"></a>STI_PCHAR&#160;</td><td class="fielddoc"><p >char * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211ad8ed5a69facf5f0d115305508d4360c0" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211ad8ed5a69facf5f0d115305508d4360c0"></a>STI_PUCHAR&#160;</td><td class="fielddoc"><p >uint8 * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a47647669a95737a405ea759a47ebe6d4" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a47647669a95737a405ea759a47ebe6d4"></a>STI_PCCHAR&#160;</td><td class="fielddoc"><p >const char * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a6b69598b89a319945d2378755bceda3b" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a6b69598b89a319945d2378755bceda3b"></a>STI_PCUCHAR&#160;</td><td class="fielddoc"><p >const uint8 * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211af1c5fab58b7522abba89c3e8ea011585" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211af1c5fab58b7522abba89c3e8ea011585"></a>STI_PBYTE&#160;</td><td class="fielddoc"><p >_BYTE * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a0294096331b11299a1725d47b0ec48aa" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a0294096331b11299a1725d47b0ec48aa"></a>STI_PINT&#160;</td><td class="fielddoc"><p >int * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a4ce84ce1b31df9af7da92ed166efc855" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a4ce84ce1b31df9af7da92ed166efc855"></a>STI_PUINT&#160;</td><td class="fielddoc"><p >unsigned int * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211ab91aef96c15480ad770574620493a5b5" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211ab91aef96c15480ad770574620493a5b5"></a>STI_PVOID&#160;</td><td class="fielddoc"><p >void * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211ac38dccd05b2c93cae2e8ea71a52d9548" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211ac38dccd05b2c93cae2e8ea71a52d9548"></a>STI_PPVOID&#160;</td><td class="fielddoc"><p >void ** </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a0f808184209169009a1de95bc6ed64eb" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a0f808184209169009a1de95bc6ed64eb"></a>STI_PCVOID&#160;</td><td class="fielddoc"><p >const void * </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a3b3eef78afdcd967b0314486de96f371" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a3b3eef78afdcd967b0314486de96f371"></a>STI_ACHAR&#160;</td><td class="fielddoc"><p >char[] </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a2cd9c8e886dddfe900bd01e68c1a46bc" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a2cd9c8e886dddfe900bd01e68c1a46bc"></a>STI_AUCHAR&#160;</td><td class="fielddoc"><p >uint8[] </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a69a9601f852e149baf5c28ac900bd91d" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a69a9601f852e149baf5c28ac900bd91d"></a>STI_ACCHAR&#160;</td><td class="fielddoc"><p >const char[] </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211adc44280551009cc2b281ee7f540c8d4a" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211adc44280551009cc2b281ee7f540c8d4a"></a>STI_ACUCHAR&#160;</td><td class="fielddoc"><p >const uint8[] </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211ad16bb6ab5bc017c2c424c0b43a4ba8a1" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211ad16bb6ab5bc017c2c424c0b43a4ba8a1"></a>STI_FPURGING&#160;</td><td class="fielddoc"><p >void __userpurge(int) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a95e3539d8614d7c1f78e480397fe785d" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a95e3539d8614d7c1f78e480397fe785d"></a>STI_FDELOP&#160;</td><td class="fielddoc"><p >void __cdecl(void *) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a8512c62f2fdd18bc875a81aab1acfffc" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a8512c62f2fdd18bc875a81aab1acfffc"></a>STI_MSGSEND&#160;</td><td class="fielddoc"><p >void *(void *, const char *, ...) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a1243182dde00b57ae0fdcd93578f8b91" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a1243182dde00b57ae0fdcd93578f8b91"></a>STI_AEABI_LCMP&#160;</td><td class="fielddoc"><p >int __fastcall(int64 x, int64 y) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211acfbfbda5305515c6c8bffea0c24a7d59" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211acfbfbda5305515c6c8bffea0c24a7d59"></a>STI_AEABI_ULCMP&#160;</td><td class="fielddoc"><p >int __fastcall(uint64 x, uint64 y) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a43f6e82ab8b5f5927ea126930f42d83d" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a43f6e82ab8b5f5927ea126930f42d83d"></a>STI_DONT_USE&#160;</td><td class="fielddoc"><p >unused stock type id; should not be used </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211af6f297c7ffa79618a21fb2ae0205d107" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211af6f297c7ffa79618a21fb2ae0205d107"></a>STI_SIZE_T&#160;</td><td class="fielddoc"><p >size_t </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a17d3a099be27bc57e7d2ceaecc78cbbb" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a17d3a099be27bc57e7d2ceaecc78cbbb"></a>STI_SSIZE_T&#160;</td><td class="fielddoc"><p >ssize_t </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a7db708741cdccbe41aa9418614365ab4" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a7db708741cdccbe41aa9418614365ab4"></a>STI_AEABI_MEMCPY&#160;</td><td class="fielddoc"><p >void __fastcall(void *, const void *, size_t) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a2dae55494874e37f19ea88efdcec3310" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a2dae55494874e37f19ea88efdcec3310"></a>STI_AEABI_MEMSET&#160;</td><td class="fielddoc"><p >void __fastcall(void *, size_t, int) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211acfde347b9ce367f40c8a54d664e5d67e" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211acfde347b9ce367f40c8a54d664e5d67e"></a>STI_AEABI_MEMCLR&#160;</td><td class="fielddoc"><p >void __fastcall(void *, size_t) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a79e42d641f074eaca76bb67e7e40fc85" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a79e42d641f074eaca76bb67e7e40fc85"></a>STI_RTC_CHECK_2&#160;</td><td class="fielddoc"><p >int16 __fastcall(int16 x) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a7cab85c891644bed71779929562d3d44" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a7cab85c891644bed71779929562d3d44"></a>STI_RTC_CHECK_4&#160;</td><td class="fielddoc"><p >int32 __fastcall(int32 x) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a162e68c27d6d04f6ac4c2d9997866a1c" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a162e68c27d6d04f6ac4c2d9997866a1c"></a>STI_RTC_CHECK_8&#160;</td><td class="fielddoc"><p >int64 __fastcall(int64 x) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a6fa97a7992d72da3555ef5352368e2e1" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a6fa97a7992d72da3555ef5352368e2e1"></a>STI_COMPLEX64&#160;</td><td class="fielddoc"><p >struct complex64_t { float real, imag; } </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5cba82dd91a1d49c2e0cdd8f5d5211a4733b02fc9148c661af9127435afcd7b" name="a3d5cba82dd91a1d49c2e0cdd8f5d5211a4733b02fc9148c661af9127435afcd7b"></a>STI_COMPLEX128&#160;</td><td class="fielddoc"><p >struct complex128_t { double real, imag; } </p>
</td></tr>
</table>

</div>
</div>
<a id="a6a3b7b00fcc1f35943355ff4a59ee27b" name="a6a3b7b00fcc1f35943355ff4a59ee27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3b7b00fcc1f35943355ff4a59ee27b">&#9670;&nbsp;</a></span>gtd_udt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="typeinf_8hpp.html#a6a3b7b00fcc1f35943355ff4a59ee27b">gtd_udt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants to be used with get_udt_details() </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6a3b7b00fcc1f35943355ff4a59ee27ba1c0801cf7075c0d784cf8d66c608160c" name="a6a3b7b00fcc1f35943355ff4a59ee27ba1c0801cf7075c0d784cf8d66c608160c"></a>GTD_CALC_LAYOUT&#160;</td><td class="fielddoc"><p >calculate udt layout </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a3b7b00fcc1f35943355ff4a59ee27ba5fcc07edfa8f3f3d7a8df7e224ddea59" name="a6a3b7b00fcc1f35943355ff4a59ee27ba5fcc07edfa8f3f3d7a8df7e224ddea59"></a>GTD_NO_LAYOUT&#160;</td><td class="fielddoc"><p >don't calculate udt layout please note that udt layout may have been calculated earlier </p>
</td></tr>
<tr><td class="fieldname"><a id="a6a3b7b00fcc1f35943355ff4a59ee27badb23c2ea9cfb7587fd7afbeb4fc61f93" name="a6a3b7b00fcc1f35943355ff4a59ee27badb23c2ea9cfb7587fd7afbeb4fc61f93"></a>GTD_DEL_BITFLDS&#160;</td><td class="fielddoc"><p >delete udt bitfields </p>
</td></tr>
</table>

</div>
</div>
<a id="ab7f0a2e39ac376a1f6e903e970e527c9" name="ab7f0a2e39ac376a1f6e903e970e527c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f0a2e39ac376a1f6e903e970e527c9">&#9670;&nbsp;</a></span>gtd_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="typeinf_8hpp.html#ab7f0a2e39ac376a1f6e903e970e527c9">gtd_func_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants to be used with get_func_details() </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab7f0a2e39ac376a1f6e903e970e527c9a5bd1413dc6a22cf8e0b2d924da8db70b" name="ab7f0a2e39ac376a1f6e903e970e527c9a5bd1413dc6a22cf8e0b2d924da8db70b"></a>GTD_CALC_ARGLOCS&#160;</td><td class="fielddoc"><p >calculate func arg locations </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7f0a2e39ac376a1f6e903e970e527c9a10a6bd6a4e21f49a406a5d5b81ca0504" name="ab7f0a2e39ac376a1f6e903e970e527c9a10a6bd6a4e21f49a406a5d5b81ca0504"></a>GTD_NO_ARGLOCS&#160;</td><td class="fielddoc"><p >don't calculate func arg locations please note that the locations may have been calculated earlier </p>
</td></tr>
</table>

</div>
</div>
<a id="a0f68192de992d505e6ba381993bccc5b" name="a0f68192de992d505e6ba381993bccc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f68192de992d505e6ba381993bccc5b">&#9670;&nbsp;</a></span>gts_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="typeinf_8hpp.html#a0f68192de992d505e6ba381993bccc5b">gts_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants to be used with get_size() </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0f68192de992d505e6ba381993bccc5bace4d40b057bf8f9dd9af50fa4e1bbddb" name="a0f68192de992d505e6ba381993bccc5bace4d40b057bf8f9dd9af50fa4e1bbddb"></a>GTS_NESTED&#160;</td><td class="fielddoc"><p >nested type (embedded into a udt) </p>
</td></tr>
<tr><td class="fieldname"><a id="a0f68192de992d505e6ba381993bccc5badf69b340e31e11338120b48af3ec52f5" name="a0f68192de992d505e6ba381993bccc5badf69b340e31e11338120b48af3ec52f5"></a>GTS_BASECLASS&#160;</td><td class="fielddoc"><p >is baseclass of a udt </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3b044ce67e074ad66bb905809f8461aa" name="a3b044ce67e074ad66bb905809f8461aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b044ce67e074ad66bb905809f8461aa">&#9670;&nbsp;</a></span>is_tah_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool is_tah_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The TAH byte (type attribute header byte) denotes the start of type attributes. </p>
<p >(see "tah-typeattrs" in the type bit definitions) </p>

</div>
</div>
<a id="a9d20f03e4434bdd91c0b012bc847b610" name="a9d20f03e4434bdd91c0b012bc847b610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d20f03e4434bdd91c0b012bc847b610">&#9670;&nbsp;</a></span>is_sdacl_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool is_sdacl_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify an sdacl byte. </p>
<p >The first sdacl byte has the following format: 11xx000x. The sdacl bytes are appended to udt fields. They indicate the start of type attributes (as the tah-bytes do). The sdacl bytes are used in the udt headers instead of the tah-byte. This is done for compatibility with old databases, they were already using sdacl bytes in udt headers and as udt field postfixes. (see "sdacl-typeattrs" in the type bit definitions) </p>

</div>
</div>
<a id="aaeb51dca7f479be755b0487951ec0491" name="aaeb51dca7f479be755b0487951ec0491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb51dca7f479be755b0487951ec0491">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbytevec__t.html">bytevec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbytevec__t.html">bytevec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two bytevecs with '&lt;'. </p>
<p >v1 is considered less than v2 if either:</p><ul>
<li>v1.size() &lt; v2.size()</li>
<li>there is some i such that v1[i] &lt; v2[i] </li>
</ul>

</div>
</div>
<a id="a064da0ed8c78e492feeae9c6db99d3be" name="a064da0ed8c78e492feeae9c6db99d3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064da0ed8c78e492feeae9c6db99d3be">&#9670;&nbsp;</a></span>extract_argloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export extract_argloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classargloc__t.html">argloc_t</a> *&#160;</td>
          <td class="paramname"><em>vloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forbid_stkoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an argument location. </p>
<p >Argument FORBID_STKOFF checks location type. It can be used, for example, to check the return location of a function that cannot return a value in the stack </p>

</div>
</div>
<a id="a5f6edbd7cbdda3ef90191430f3060474" name="a5f6edbd7cbdda3ef90191430f3060474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6edbd7cbdda3ef90191430f3060474">&#9670;&nbsp;</a></span>add_base_tils()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export add_base_tils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>errbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tildir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>gen_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add multiple base tils. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">errbuf</td><td>error message </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ti</td><td>target til </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tildir</td><td>directory where specified tils can be found. nullptr means all default til subdirectories. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bases</td><td>comma separated list of til names </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gen_events</td><td>generate corresponding IDB events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___t_i_l___a_d_d__.html">Add TIL result codes</a> </dd></dl>

</div>
</div>
<a id="a6dac6319b660df2fb2f24ffbd7cade88" name="a6dac6319b660df2fb2f24ffbd7cade88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dac6319b660df2fb2f24ffbd7cade88">&#9670;&nbsp;</a></span>load_til()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="structtil__t.html">til_t</a> *ida_export load_til </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>errbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tildir</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load til from a file without adding it to the database list (see also <a class="el" href="typeinf_8hpp.html#a6ae3c9ab321e5107e8ba4df22de3fcbf">add_til</a>). </p>
<p >Failure to load base tils are reported into 'errbuf'. They do not prevent loading of the main til. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>filename of the til. If it's an absolute path, tildir is ignored.<ul>
<li>NB: the file extension is forced to .til </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errbuf</td><td>error message </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tildir</td><td>directory where to load the til from. nullptr means default til subdirectories. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to resulting til, nullptr if failed and error message is in errbuf </dd></dl>

</div>
</div>
<a id="aaec1f9582d33fb9d15bbf2f0102b693c" name="aaec1f9582d33fb9d15bbf2f0102b693c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec1f9582d33fb9d15bbf2f0102b693c">&#9670;&nbsp;</a></span>sort_til()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export sort_til </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort til (use after modifying it). </p>
<dl class="section return"><dt>Returns</dt><dd>false if no memory or bad parameter </dd></dl>

</div>
</div>
<a id="a85d12b7291be52278d2d193b82165639" name="a85d12b7291be52278d2d193b82165639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d12b7291be52278d2d193b82165639">&#9670;&nbsp;</a></span>compact_til()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export compact_til </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect garbage in til. </p>
<p >Must be called before storing the til. </p><dl class="section return"><dt>Returns</dt><dd>true if any memory was freed </dd></dl>

</div>
</div>
<a id="a8a3076c45c4329974096cc8923658f0e" name="a8a3076c45c4329974096cc8923658f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3076c45c4329974096cc8923658f0e">&#9670;&nbsp;</a></span>store_til()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export store_til </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tildir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store til to a file. </p>
<p >If the til contains garbage, it will be collected before storing the til. Your plugin should call <a class="el" href="typeinf_8hpp.html#a85d12b7291be52278d2d193b82165639" title="Collect garbage in til.">compact_til()</a> before calling <a class="el" href="typeinf_8hpp.html#a8a3076c45c4329974096cc8923658f0e" title="Store til to a file.">store_til()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type library to store </td></tr>
    <tr><td class="paramname">tildir</td><td>directory where to store the til. nullptr means current directory. </td></tr>
    <tr><td class="paramname">name</td><td>filename of the til. If it's an absolute path, tildir is ignored.<ul>
<li>NB: the file extension is forced to .til </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a12d82624c71c4f04c749344171cf4978" name="a12d82624c71c4f04c749344171cf4978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d82624c71c4f04c749344171cf4978">&#9670;&nbsp;</a></span>verify_argloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export verify_argloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;&#160;</td>
          <td class="paramname"><em>vloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrangeset__t.html">rangeset_t</a> *&#160;</td>
          <td class="paramname"><em>gaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify <a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vloc</td><td>argloc to verify </td></tr>
    <tr><td class="paramname">size</td><td>total size of the variable </td></tr>
    <tr><td class="paramname">gaps</td><td>if not nullptr, specifies gaps in structure definition. these gaps should not map to any argloc, but everything else must be covered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if ok, otherwise an interr code. </dd></dl>

</div>
</div>
<a id="ad7b916c550685f48f02b3fd5c97d3f1f" name="ad7b916c550685f48f02b3fd5c97d3f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b916c550685f48f02b3fd5c97d3f1f">&#9670;&nbsp;</a></span>optimize_argloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export optimize_argloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classargloc__t.html">argloc_t</a> *&#160;</td>
          <td class="paramname"><em>vloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrangeset__t.html">rangeset_t</a> *&#160;</td>
          <td class="paramname"><em>gaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify and optimize scattered argloc into simple form. </p>
<p >All new arglocs must be processed by this function. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>success </td></tr>
    <tr><td class="paramname">false</td><td>the input argloc was illegal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2a79c032d207973a179ca66d4b1061a" name="ac2a79c032d207973a179ca66d4b1061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a79c032d207973a179ca66d4b1061a">&#9670;&nbsp;</a></span>is_purging_cc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> bool is_purging_cc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td>
          <td class="paramname"><em>cm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the calling convention clean the stack arguments upon return?. </p>
<dl class="section note"><dt>Note</dt><dd>this function is valid only for x86 code </dd></dl>

</div>
</div>
<a id="a405f52d4a60168b4f7dab80735397a91" name="a405f52d4a60168b4f7dab80735397a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405f52d4a60168b4f7dab80735397a91">&#9670;&nbsp;</a></span>set_compiler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_compiler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcompiler__info__t.html">compiler_info_t</a> &amp;&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>abiname</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change current compiler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>compiler to switch to </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_e_t_c_o_m_p__.html">Set compiler flags</a> </td></tr>
    <tr><td class="paramname">abiname</td><td>ABI name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a574b887360c437eb564122c17a82c4ef" name="a574b887360c437eb564122c17a82c4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574b887360c437eb564122c17a82c4ef">&#9670;&nbsp;</a></span>get_abi_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_abi_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ABI name. </p>
<dl class="section return"><dt>Returns</dt><dd>length of the name (&gt;=0) </dd></dl>

</div>
</div>
<a id="ac867a63844cbacaf704143a9c52536ee" name="ac867a63844cbacaf704143a9c52536ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac867a63844cbacaf704143a9c52536ee">&#9670;&nbsp;</a></span>append_abi_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export append_abi_opts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>abi_opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user_level</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add/remove/check ABI option General form of full abi name: abiname-opt1-opt2-... or -opt1-opt2-... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abi_opts</td><td>- ABI options to add/remove in form opt1-opt2-... </td></tr>
    <tr><td class="paramname">user_level</td><td>- initiated by user if TRUE (==SETCOMP_BY_USER) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a0c5949346c28023a7823aa3e481f6a72" name="a0c5949346c28023a7823aa3e481f6a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5949346c28023a7823aa3e481f6a72">&#9670;&nbsp;</a></span>set_compiler_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_compiler_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>compstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compstr</td><td>- compiler description in form &lt;abbr&gt;:&lt;abiname&gt; </td></tr>
    <tr><td class="paramname">user_level</td><td>- initiated by user if TRUE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a6a2c9c8787240c725a87bb5cb5ffc7a4" name="a6a2c9c8787240c725a87bb5cb5ffc7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2c9c8787240c725a87bb5cb5ffc7a4">&#9670;&nbsp;</a></span>h2ti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export h2ti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lexer_t *&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="typeinf_8hpp.html#a1a2d19a5da522effe48cfe67e14fc479">HTI_HIGH</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a034013ece7194a003ffd1727075100d2">h2ti_type_cb</a> *&#160;</td>
          <td class="paramname"><em>type_cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a034013ece7194a003ffd1727075100d2">h2ti_type_cb</a> *&#160;</td>
          <td class="paramname"><em>var_cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#abcc521f1e3d068d8cdf760885a8f53c4">printer_t</a> *&#160;</td>
          <td class="paramname"><em>print_cb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_cb_data</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a784254a39507ac759a9f373a52a75ac1">abs_t</a>&#160;</td>
          <td class="paramname"><em>_isabs</em> = <code>abs_unk</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert declarations to type_t*. </p>
<p >This is a low level function - use <a class="el" href="typeinf_8hpp.html#ae4cec61d812cfc0acc08453742b729b3" title="Parse many declarations and store them in a til.">parse_decls()</a> or <a class="el" href="typeinf_8hpp.html#aa3ec4302201c52b95420edc3618b7eb2" title="Parse ONE declaration.">parse_decl()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type info library </td></tr>
    <tr><td class="paramname">lx</td><td>input lexer. may be nullptr. always destroyed by <a class="el" href="typeinf_8hpp.html#a6a2c9c8787240c725a87bb5cb5ffc7a4" title="Convert declarations to type_t*.">h2ti()</a> </td></tr>
    <tr><td class="paramname">input</td><td>file name or C declaration </td></tr>
    <tr><td class="paramname">flags</td><td>combination of <a class="el" href="group___h_t_i__.html">Type formatting flags</a> </td></tr>
    <tr><td class="paramname">type_cb</td><td>callback - for each type </td></tr>
    <tr><td class="paramname">var_cb</td><td>callback - for each var </td></tr>
    <tr><td class="paramname">print_cb</td><td>may pass msg() here </td></tr>
    <tr><td class="paramname">_cb_data</td><td>data passed to callbacks </td></tr>
    <tr><td class="paramname">_isabs</td><td>the expected abstracness of the type declaration(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of errors (they are displayed using print_cb). zero means ok </dd></dl>

</div>
</div>
<a id="aa3ec4302201c52b95420edc3618b7eb2" name="aa3ec4302201c52b95420edc3618b7eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ec4302201c52b95420edc3618b7eb2">&#9670;&nbsp;</a></span>parse_decl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export parse_decl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse ONE declaration. </p>
<p >If the input string contains more than one declaration, the first complete type declaration (<a class="el" href="typeinf_8hpp.html#a275f154b9415ddab5d773d3f2ce48a30" title="return declared type information">PT_TYP</a>) or the last variable declaration (<a class="el" href="typeinf_8hpp.html#a2372a33ffe07dcfaae46a1873a453e8f" title="return declared object information">PT_VAR</a>) will be used. </p><dl class="section note"><dt>Note</dt><dd>name &amp; tif may be empty after the call! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tif</td><td>type info </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>declared name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">til</td><td>type library to use. may be nullptr </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">decl</td><td>C declaration to parse </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>combination of <a class="el" href="group___p_t__.html">Type parsing flags</a> bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>ok </td></tr>
    <tr><td class="paramname">false</td><td>declaration is bad, the error message is displayed if !PT_SIL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedfe2fcd29fba4ba9fe6da62bbbf4fa5" name="aedfe2fcd29fba4ba9fe6da62bbbf4fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfe2fcd29fba4ba9fe6da62bbbf4fa5">&#9670;&nbsp;</a></span>convert_pt_flags_to_hti()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> int convert_pt_flags_to_hti </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pt_flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <a class="el" href="group___p_t__.html">Type parsing flags</a> to <a class="el" href="group___h_t_i__.html">Type formatting flags</a>. </p>
<p >Type parsing flags lesser than 0x10 don't have stable meaning and will be ignored (more on these flags can be seen in idc.idc) </p>

</div>
</div>
<a id="ae4cec61d812cfc0acc08453742b729b3" name="ae4cec61d812cfc0acc08453742b729b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cec61d812cfc0acc08453742b729b3">&#9670;&nbsp;</a></span>parse_decls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export parse_decls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#abcc521f1e3d068d8cdf760885a8f53c4">printer_t</a> *&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hti_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse many declarations and store them in a til. </p>
<p >If there are any errors, they will be printed using 'printer'. This function uses default include path and predefined macros from the database settings. It always uses the <a class="el" href="typeinf_8hpp.html#a7eadeea97aa05317c41e939b70714a56" title="don&#39;t complain about redeclarations">HTI_DCL</a> bit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">til</td><td>type library to store the result </td></tr>
    <tr><td class="paramname">input</td><td>input string or file name (see hti_flags) </td></tr>
    <tr><td class="paramname">printer</td><td>function to output error messages (use msg or nullptr or your own callback) </td></tr>
    <tr><td class="paramname">hti_flags</td><td>combination of <a class="el" href="group___h_t_i__.html">Type formatting flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of errors, 0 means ok. </dd></dl>

</div>
</div>
<a id="a43ef73f0df2c860b554c5fef7ce273f3" name="a43ef73f0df2c860b554c5fef7ce273f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ef73f0df2c860b554c5fef7ce273f3">&#9670;&nbsp;</a></span>print_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export print_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prtype_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type declaration for the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output buffer </td></tr>
    <tr><td class="paramname">ea</td><td>address </td></tr>
    <tr><td class="paramname">prtype_flags</td><td>combination of <a class="el" href="group___p_r_t_y_p_e__.html">Type printing flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ac0a479446982028dbaf97c024d16c1ec" name="ac0a479446982028dbaf97c024d16c1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a479446982028dbaf97c024d16c1ec">&#9670;&nbsp;</a></span>get_named_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_named_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **&#160;</td>
          <td class="paramname"><em>type</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **&#160;</td>
          <td class="paramname"><em>fields</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>cmt</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **&#160;</td>
          <td class="paramname"><em>fieldcmts</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *&#160;</td>
          <td class="paramname"><em>sclass</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get named typeinfo. </p>
<p >The returned pointers are pointers to static storage. <br  />
They are valid until <a class="el" href="typeinf_8hpp.html#a7fc9cf4e476ff8d150c1e77bb0746301" title="Free memory allocated by til.">free_til()</a>, set_named_type(), <a class="el" href="typeinf_8hpp.html#a1790476ab86ed2767f5c9c81ec3274ff" title="Delete information about a symbol.">del_named_type()</a>, <br  />
rename_named_type(), <a class="el" href="typeinf_8hpp.html#ab19a0388e87ce32020d71754d8b63475" title="Store a type in the til.">set_numbered_type()</a>, <a class="el" href="typeinf_8hpp.html#a63cf655e113e97c7d0abc8d42e7e98f4" title="Delete a numbered type.">del_numbered_type()</a>, <br  />
and idb structure/enum manipulation (in other words, until <a class="el" href="structtil__t.html" title="Type Information Library.">til_t</a> is changed). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>pointer to type information library </td></tr>
    <tr><td class="paramname">name</td><td>name of type </td></tr>
    <tr><td class="paramname">ntf_flags</td><td>combination of <a class="el" href="group___n_t_f__.html">Flags for named types</a> </td></tr>
    <tr><td class="paramname">type</td><td>ptr to ptr to output buffer for the type info </td></tr>
    <tr><td class="paramname">fields</td><td>ptr to ptr to the field/args names. may be nullptr </td></tr>
    <tr><td class="paramname">cmt</td><td>ptr to ptr to the main comment. may be nullptr </td></tr>
    <tr><td class="paramname">fieldcmts</td><td>ptr to ptr to the field/args comments. may be nullptr </td></tr>
    <tr><td class="paramname">sclass</td><td>ptr to storage class </td></tr>
    <tr><td class="paramname">value</td><td>ptr to symbol value. for types, ptr to the ordinal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>can't find the named type (or name==nullptr) </td></tr>
    <tr><td class="paramname">1</td><td>ok, the buffers are filled with information (if not nullptr) </td></tr>
    <tr><td class="paramname">2</td><td>ok, found it in a base til </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfb5b90319ad6850988d7f7e42b0fa08" name="abfb5b90319ad6850988d7f7e42b0fa08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb5b90319ad6850988d7f7e42b0fa08">&#9670;&nbsp;</a></span>get_named_type64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int idaapi get_named_type64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **&#160;</td>
          <td class="paramname"><em>type</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **&#160;</td>
          <td class="paramname"><em>fields</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>cmt</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **&#160;</td>
          <td class="paramname"><em>fieldcmts</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *&#160;</td>
          <td class="paramname"><em>sclass</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64 *&#160;</td>
          <td class="paramname"><em>value</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="typeinf_8hpp.html#ac0a479446982028dbaf97c024d16c1ec" title="Get named typeinfo.">get_named_type()</a> above. </p>
<dl class="section note"><dt>Note</dt><dd>If the value in the 'ti' library is 32-bit, it will be sign-extended before being stored in the 'value' pointer. </dd></dl>

</div>
</div>
<a id="a1790476ab86ed2767f5c9c81ec3274ff" name="a1790476ab86ed2767f5c9c81ec3274ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1790476ab86ed2767f5c9c81ec3274ff">&#9670;&nbsp;</a></span>del_named_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export del_named_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete information about a symbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type library </td></tr>
    <tr><td class="paramname">name</td><td>name of symbol </td></tr>
    <tr><td class="paramname">ntf_flags</td><td>combination of <a class="el" href="group___n_t_f__.html">Flags for named types</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a40ef86a47794fe3a1b765454a0567dc0" name="a40ef86a47794fe3a1b765454a0567dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ef86a47794fe3a1b765454a0567dc0">&#9670;&nbsp;</a></span>first_named_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const char *ida_export first_named_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type library. nullptr means the local type library for the current database. </td></tr>
    <tr><td class="paramname">ntf_flags</td><td>combination of <a class="el" href="group___n_t_f__.html">Flags for named types</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type or symbol names, depending of ntf_flags. Returns mangled names. Never returns anonymous types. To include them, enumerate types by ordinals. </dd></dl>

</div>
</div>
<a id="a18d283260144ac0abe789384d2c06e10" name="a18d283260144ac0abe789384d2c06e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d283260144ac0abe789384d2c06e10">&#9670;&nbsp;</a></span>next_named_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const char *ida_export next_named_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type library. nullptr means the local type library for the current database. </td></tr>
    <tr><td class="paramname">ntf_flags</td><td>combination of <a class="el" href="group___n_t_f__.html">Flags for named types</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type or symbol names, depending of ntf_flags. Returns mangled names. Never returns anonymous types. To include them, enumerate types by ordinals. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the current name. the name that follows this one will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7fb8bcab798445a464639d699b6126f" name="ad7fb8bcab798445a464639d699b6126f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fb8bcab798445a464639d699b6126f">&#9670;&nbsp;</a></span>copy_named_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export copy_named_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>dsttil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>srctil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a named type from one til to another. </p>
<p >This function will copy the specified type and all dependent types from the source type library to the destination library. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dsttil</td><td>Destination til. It must have orginal types enabled </td></tr>
    <tr><td class="paramname">srctil</td><td>Source til. </td></tr>
    <tr><td class="paramname">name</td><td>name of the type to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ordinal number of the copied type. 0 means error </dd></dl>

</div>
</div>
<a id="aaefdfe7cb059b39bfd6650f63a83cc44" name="aaefdfe7cb059b39bfd6650f63a83cc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefdfe7cb059b39bfd6650f63a83cc44">&#9670;&nbsp;</a></span>decorate_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export decorate_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td>
          <td class="paramname"><em>cc</em> = <code><a class="el" href="typeinf_8hpp.html#a1d8607c930b67577c7f39ac7a5d24612">CM_CC_UNKNOWN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorate/undecorate a C symbol name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output buffer </td></tr>
    <tr><td class="paramname">name</td><td>name of symbol </td></tr>
    <tr><td class="paramname">mangle</td><td>true-mangle, false-unmangle </td></tr>
    <tr><td class="paramname">cc</td><td>calling convention </td></tr>
    <tr><td class="paramname">type</td><td>name type (nullptr-unknown) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a059b898c85f397e3aadf4c409ec66c59" name="a059b898c85f397e3aadf4c409ec66c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059b898c85f397e3aadf4c409ec66c59">&#9670;&nbsp;</a></span>calc_c_cpp_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export calc_c_cpp_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ccn_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get C or C++ form of the name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output buffer </td></tr>
    <tr><td class="paramname">name</td><td>original (mangled or decorated) name </td></tr>
    <tr><td class="paramname">type</td><td>name type if known, otherwise nullptr </td></tr>
    <tr><td class="paramname">ccn_flags</td><td>one of <a class="el" href="group___c_c_n__.html">C/C++ naming flags</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1fb33088b41c01ab02e1d7739ae3d67" name="ab1fb33088b41c01ab02e1d7739ae3d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1fb33088b41c01ab02e1d7739ae3d67">&#9670;&nbsp;</a></span>enable_numbered_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export enable_numbered_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the use of numbered types in til. </p>
<p >Currently it is impossible to disable numbered types once they are enabled </p>

</div>
</div>
<a id="a1f7a68bdec901b7fbf1c0bf324ddf126" name="a1f7a68bdec901b7fbf1c0bf324ddf126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7a68bdec901b7fbf1c0bf324ddf126">&#9670;&nbsp;</a></span>alloc_type_ordinals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export alloc_type_ordinals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a range of ordinal numbers for new types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type library </td></tr>
    <tr><td class="paramname">qty</td><td>number of ordinals to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first ordinal. 0 means failure. </dd></dl>

</div>
</div>
<a id="ac850f1c54d5b4c607d64ddf76691814f" name="ac850f1c54d5b4c607d64ddf76691814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac850f1c54d5b4c607d64ddf76691814f">&#9670;&nbsp;</a></span>get_ordinal_qty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export get_ordinal_qty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of allocated ordinals. </p>
<dl class="section return"><dt>Returns</dt><dd>uint32(-1) if failed </dd></dl>

</div>
</div>
<a id="ab19a0388e87ce32020d71754d8b63475" name="ab19a0388e87ce32020d71754d8b63475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19a0388e87ce32020d71754d8b63475">&#9670;&nbsp;</a></span>set_numbered_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaa">tinfo_code_t</a> ida_export set_numbered_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *&#160;</td>
          <td class="paramname"><em>fields</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmt</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> *&#160;</td>
          <td class="paramname"><em>fldcmts</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a9c9a05934a8418932a82a2d39476d97d">sclass_t</a> *&#160;</td>
          <td class="paramname"><em>sclass</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a type in the til. </p>
<p >'name' may be nullptr for anonymous types. The specified ordinal must be free (no other type is using it). For ntf_flags, only <a class="el" href="typeinf_8hpp.html#a99d425180386ad9f256f191e88ff1ffe" title="replace original type (for set_named_type)">NTF_REPLACE</a> is consulted. </p>

</div>
</div>
<a id="aaa083016ad05fe5db5b57b25a98cf9d7" name="aaa083016ad05fe5db5b57b25a98cf9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa083016ad05fe5db5b57b25a98cf9d7">&#9670;&nbsp;</a></span>set_type_alias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_type_alias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>src_ordinal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>dst_ordinal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a type alias. </p>
<p >Redirects all references to source type to the destination type. This is equivalent to instantaneous replacement all reference to srctype by dsttype. </p>

</div>
</div>
<a id="aa3df2e4834eeaf173579f92c5feb3b88" name="aa3df2e4834eeaf173579f92c5feb3b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3df2e4834eeaf173579f92c5feb3b88">&#9670;&nbsp;</a></span>get_alias_target()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export get_alias_target </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the final alias destination. </p>
<p >If the ordinal has not been aliased, return the specified ordinal itself If failed, returns 0. </p>

</div>
</div>
<a id="a5eb6476f1e89831facd6b8375a3cf9b0" name="a5eb6476f1e89831facd6b8375a3cf9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb6476f1e89831facd6b8375a3cf9b0">&#9670;&nbsp;</a></span>get_numbered_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const char *ida_export get_numbered_type_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type name (if exists) by its ordinal. </p>
<p >If the type is anonymous, returns "". If failed, returns nullptr </p>

</div>
</div>
<a id="ab5ed1d69ef90da349923a780f84f851a" name="ab5ed1d69ef90da349923a780f84f851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ed1d69ef90da349923a780f84f851a">&#9670;&nbsp;</a></span>create_numbered_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export create_numbered_type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td>
          <td class="paramname"><em>ord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create anonymous name for numbered type. </p>
<p >This name can be used to reference a numbered type by its ordinal Ordinal names have the following format: '#' + set_de(ord) Returns: -1 if error, otherwise the name length </p>

</div>
</div>
<a id="a002eef2e97e56cb3a2bddaf6fdc70720" name="a002eef2e97e56cb3a2bddaf6fdc70720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002eef2e97e56cb3a2bddaf6fdc70720">&#9670;&nbsp;</a></span>is_ordinal_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_ordinal_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *&#160;</td>
          <td class="paramname"><em>ord</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the name is an ordinal name. </p>
<p >Ordinal names have the following format: '#' + set_de(ord) </p>

</div>
</div>
<a id="af4c7701a03bd988d81f5ed27d2f5bb39" name="af4c7701a03bd988d81f5ed27d2f5bb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c7701a03bd988d81f5ed27d2f5bb39">&#9670;&nbsp;</a></span>get_ordinal_from_idb_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_ordinal_from_idb_type </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ordinal number of an idb type (struct/enum). </p>
<p >The 'type' parameter is used only to determine the kind of the type (struct or enum) Use this function to find out the correspondence between idb types and til types </p>

</div>
</div>
<a id="a55a920a13cb45e4731cd68b7d2556588" name="a55a920a13cb45e4731cd68b7d2556588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a920a13cb45e4731cd68b7d2556588">&#9670;&nbsp;</a></span>is_autosync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool idaapi is_autosync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the specified idb type automatically synchronized? </p>

</div>
</div>
<a id="af305520e0b262734feb77427f981d0b1" name="af305520e0b262734feb77427f981d0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af305520e0b262734feb77427f981d0b1">&#9670;&nbsp;</a></span>compact_numbered_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export compact_numbered_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>min_ord</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a16a891be237a47eac68383da2ebc2fa6">intvec_t</a> *&#160;</td>
          <td class="paramname"><em>p_ordmap</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compact numbered types to get rid of empty slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>type library to compact </td></tr>
    <tr><td class="paramname">min_ord</td><td>minimal ordinal number to start to compact. lower ordinals are not modified </td></tr>
    <tr><td class="paramname">p_ordmap</td><td>the resulting mapping (for example, the new ordinal of min_ord will be in ordmap[0]) </td></tr>
    <tr><td class="paramname">flags</td><td>reserved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of freed type slots </dd></dl>

</div>
</div>
<a id="afcd359fb673ce2e937b4c85940f3b000" name="afcd359fb673ce2e937b4c85940f3b000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd359fb673ce2e937b4c85940f3b000">&#9670;&nbsp;</a></span>get_vftable_ea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_vftable_ea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address of a virtual function table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ordinal</td><td>ordinal number of a vftable type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the corresponding virtual function table in the current database. </dd></dl>

</div>
</div>
<a id="a71850d781ec15055dc73866eec6dbd7c" name="a71850d781ec15055dc73866eec6dbd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71850d781ec15055dc73866eec6dbd7c">&#9670;&nbsp;</a></span>get_vftable_ordinal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export get_vftable_ordinal </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>vftable_ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ordinal number of the virtual function table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vftable_ea</td><td>address of a virtual function table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ordinal number of the corresponding vftable type. 0 - failure. </dd></dl>

</div>
</div>
<a id="afc21cee00f0adc8357d5b68cc826db3e" name="afc21cee00f0adc8357d5b68cc826db3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc21cee00f0adc8357d5b68cc826db3e">&#9670;&nbsp;</a></span>set_vftable_ea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_vftable_ea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>vftable_ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the address of a vftable instance for a vftable type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vftable_ea</td><td>address of a virtual function table. </td></tr>
    <tr><td class="paramname">ordinal</td><td>ordinal number of the corresponding vftable type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a182186fb0925ce1dddd7f5756892ae90" name="a182186fb0925ce1dddd7f5756892ae90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182186fb0925ce1dddd7f5756892ae90">&#9670;&nbsp;</a></span>del_vftable_ea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool del_vftable_ea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the address of a vftable instance for a vftable type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ordinal</td><td>ordinal number of a vftable type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a370b5b72b6b9d2935babdd8dbb98bfdf" name="a370b5b72b6b9d2935babdd8dbb98bfdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370b5b72b6b9d2935babdd8dbb98bfdf">&#9670;&nbsp;</a></span>get_default_align()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_default_align </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get default alignment for structure fields. </p>
<dl class="section return"><dt>Returns</dt><dd>one of 1,2,4,8,... </dd></dl>

</div>
</div>
<a id="a6e7ab0213381511f40cc337d22b32e7f" name="a6e7ab0213381511f40cc337d22b32e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7ab0213381511f40cc337d22b32e7f">&#9670;&nbsp;</a></span>align_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#acb0b22a01885ebdb9ac572343bbc4dab">THREAD_SAFE</a> void align_size </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cur_tot_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elem_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>algn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get alignment delta for the a structure field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur_tot_size</td><td>the structure size calculated so far </td></tr>
    <tr><td class="paramname">elem_size</td><td>size of the current field. the whole structure should be calculated </td></tr>
    <tr><td class="paramname">algn</td><td>the structure alignment (0,1,2,4,8...) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73622568bcc491371a33367403e3e045" name="a73622568bcc491371a33367403e3e045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73622568bcc491371a33367403e3e045">&#9670;&nbsp;</a></span>deref_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export deref_ptr </td>
          <td>(</td>
          <td class="paramtype">ea_t *&#160;</td>
          <td class="paramname"><em>ptr_ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t *&#160;</td>
          <td class="paramname"><em>closure_obj</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr_ea</td><td>in/out parameter<ul>
<li>in: address of the pointer</li>
<li>out: the pointed address </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tif</td><td>type of the pointer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">closure_obj</td><td>closure object (not used yet) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ab38ec35fd1105a5ff2f5f8f157f41e57" name="ab38ec35fd1105a5ff2f5f8f157f41e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38ec35fd1105a5ff2f5f8f157f41e57">&#9670;&nbsp;</a></span>remove_tinfo_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export remove_tinfo_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove pointer of a type. </p>
<p >(i.e. convert "char *" into "char"). Optionally remove the "lp" (or similar) prefix of the input name. If the input type is not a pointer, then fail. </p>

</div>
</div>
<a id="a8df9cceb079c76e3c2b7879c763eadea" name="a8df9cceb079c76e3c2b7879c763eadea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df9cceb079c76e3c2b7879c763eadea">&#9670;&nbsp;</a></span>import_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> ida_export import_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a named type from til to idb. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">til</td><td>type library </td></tr>
    <tr><td class="paramname">idx</td><td>the position of the new type in the list of types (structures or enums). -1 means at the end of the list </td></tr>
    <tr><td class="paramname">name</td><td>the type name </td></tr>
    <tr><td class="paramname">flags</td><td>combination of <a class="el" href="group___i_m_p_t_y_p_e__.html">Import type flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="netnode_8hpp.html#ab745219216aec4e8abf2c1dcc5d5eac0" title="A number to represent a bad netnode reference.">BADNODE</a> on error </dd></dl>

</div>
</div>
<a id="a6ae3c9ab321e5107e8ba4df22de3fcbf" name="a6ae3c9ab321e5107e8ba4df22de3fcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae3c9ab321e5107e8ba4df22de3fcbf">&#9670;&nbsp;</a></span>add_til()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export add_til </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a til file and add it the database type libraries list. </p>
<p >IDA will also apply function prototypes for matching function names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>til name </td></tr>
    <tr><td class="paramname">flags</td><td>combination of <a class="el" href="group___a_d_d_t_i_l___f.html">Load TIL flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___a_d_d_t_i_l___r.html">Load TIL result codes</a> </dd></dl>

</div>
</div>
<a id="a07ce12846fdd890614f618c553fcebc2" name="a07ce12846fdd890614f618c553fcebc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce12846fdd890614f618c553fcebc2">&#9670;&nbsp;</a></span>apply_named_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export apply_named_type </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the specified named type to the address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">name</td><td>the type name, e.g. "FILE" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a5d2fbecf8fbab5dbd9ea0510d82b7e99" name="a5d2fbecf8fbab5dbd9ea0510d82b7e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2fbecf8fbab5dbd9ea0510d82b7e99">&#9670;&nbsp;</a></span>apply_tinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export apply_tinfo </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the specified type to the specified address. </p>
<p >This function sets the type and tries to convert the item at the specified address to conform the type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">tif</td><td>type string in internal format </td></tr>
    <tr><td class="paramname">flags</td><td>combination of <a class="el" href="group___t_i_n_f_o__.html">Apply tinfo flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a546009cb5f00edba6fbbfd876787b9a0" name="a546009cb5f00edba6fbbfd876787b9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546009cb5f00edba6fbbfd876787b9a0">&#9670;&nbsp;</a></span>apply_cdecl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export apply_cdecl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the specified type to the address. </p>
<p >This function parses the declaration and calls <a class="el" href="typeinf_8hpp.html#a5d2fbecf8fbab5dbd9ea0510d82b7e99" title="Apply the specified type to the specified address.">apply_tinfo()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">til</td><td>type library </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramname">decl</td><td>type declaration in C form </td></tr>
    <tr><td class="paramname">flags</td><td>flags to pass to apply_tinfo (<a class="el" href="typeinf_8hpp.html#a2a831ce211c89ef0c30c59d7e893ba5a" title="this is a definite type">TINFO_DEFINITE</a> is always passed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ad1c3dc99b159f2f1bc3d07d897885ccd" name="ad1c3dc99b159f2f1bc3d07d897885ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c3dc99b159f2f1bc3d07d897885ccd">&#9670;&nbsp;</a></span>apply_callee_tinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export apply_callee_tinfo </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the type of the called function to the calling instruction. </p>
<p >This function will append parameter comments and rename the local variables of the calling function. It also stores information about the instructions that initialize call arguments in the database. Use <a class="el" href="typeinf_8hpp.html#a7ef863a47c0208d367489126c4a8ae6a" title="Retrieve argument initialization addresses.">get_arg_addrs()</a> to retrieve it if necessary. Alternatively it is possible to hook to processor_t::arg_addrs_ready event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td>linear address of the calling instruction. must belong to a function. </td></tr>
    <tr><td class="paramname">tif</td><td>type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a7ef863a47c0208d367489126c4a8ae6a" name="a7ef863a47c0208d367489126c4a8ae6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef863a47c0208d367489126c4a8ae6a">&#9670;&nbsp;</a></span>get_arg_addrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export get_arg_addrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>caller</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve argument initialization addresses. </p>
<p >This function retrieves information about argument addresses. This information is stored in the database by <a class="el" href="typeinf_8hpp.html#ad1c3dc99b159f2f1bc3d07d897885ccd" title="Apply the type of the called function to the calling instruction.">apply_callee_tinfo()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>linear addresses of the instructions that load call arguments </td></tr>
    <tr><td class="paramname">caller</td><td>address of the call instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ac2ae24e34543c7d43021db7907758c89" name="ac2ae24e34543c7d43021db7907758c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ae24e34543c7d43021db7907758c89">&#9670;&nbsp;</a></span>apply_once_tinfo_and_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export apply_once_tinfo_and_name </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>dea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the specified type and name to the address. </p>
<p >This function checks if the address already has a type. If the old type <br  />
does not exist or the new type is 'better' than the old type, then the <br  />
new type will be applied. A type is considered better if it has more <br  />
information (e.g. <a class="el" href="typeinf_8hpp.html#acf095fd2f25df783b0f5a321d91c6adc" title="struct: MCNT records: type_t; [sdacl-typeattrs];">BTMT_STRUCT</a> is better than <a class="el" href="typeinf_8hpp.html#a0247bd6d30b0ca1725ec2cf6cbccdc83" title="natural int. (size provided by idp module)">BT_INT</a>). <br  />
The same logic is with the name: if the address already have a meaningful <br  />
name, it will be preserved. Only if the old name does not exist or it <br  />
is a dummy name like byte_123, it will be replaced by the new name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dea</td><td>linear address </td></tr>
    <tr><td class="paramname">tif</td><td>type string in the internal format </td></tr>
    <tr><td class="paramname">name</td><td>new name for the address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a1faae87435a3adfade45003c4df6c62d" name="a1faae87435a3adfade45003c4df6c62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faae87435a3adfade45003c4df6c62d">&#9670;&nbsp;</a></span>guess_tinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export guess_tinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a type information about the id from the disassembly. </p>
<p >id can be a structure/union/enum id or an address. </p><dl class="section return"><dt>Returns</dt><dd>one of <a class="el" href="group___g_u_e_s_s__.html">Guess tinfo codes</a> </dd></dl>

</div>
</div>
<a id="a398db0b3716d46018b5792570d31a852" name="a398db0b3716d46018b5792570d31a852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398db0b3716d46018b5792570d31a852">&#9670;&nbsp;</a></span>get_idati()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const <a class="el" href="structtil__t.html">til_t</a> *ida_export get_idati </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to the local type library - this til is private for each IDB file Function that accepts til_t* uses local type library instead of nullptr. </p>

</div>
</div>
<a id="ade4a22a1d0d16ee4eede061b00fd700a" name="ade4a22a1d0d16ee4eede061b00fd700a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4a22a1d0d16ee4eede061b00fd700a">&#9670;&nbsp;</a></span>get_idainfo_by_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export get_idainfo_by_type </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a55dd00e03168fb5180830e87ef0a2c57">flags_t</a> *&#160;</td>
          <td class="paramname"><em>out_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>out_mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_alsize</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract information from a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out_size</td><td>size of tif </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_flags</td><td>description of type using flags_t </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_mt</td><td>info for non-scalar types </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tif</td><td>the type to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_alsize</td><td>alignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dfe6d3378d47ae36d78b8d99079e0eb" name="a4dfe6d3378d47ae36d78b8d99079e0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfe6d3378d47ae36d78b8d99079e0eb">&#9670;&nbsp;</a></span>get_idainfo64_by_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export get_idainfo64_by_type </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> *&#160;</td>
          <td class="paramname"><em>out_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>out_mt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>out_alsize</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract information from a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information.">tinfo_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out_size</td><td>size of tif </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_flags</td><td>description of type using flags64_t </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_mt</td><td>info for non-scalar types </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tif</td><td>the type to inspect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_alsize</td><td>alignment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a197fc9ead77f71f0286b2be85e29fa" name="a4a197fc9ead77f71f0286b2be85e29fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a197fc9ead77f71f0286b2be85e29fa">&#9670;&nbsp;</a></span>remove_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtinfo__t.html">tinfo_t</a> remove_pointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="typeinf_8hpp.html#a1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer.">BT_PTR</a>: If the current type is a pointer, return the pointed object. </p>
<p >If the current type is not a pointer, return the current type. See also get_ptrarr_object() and get_pointed_object() </p>

</div>
</div>
<a id="af504617c1e963028d77c7fdb6ee99aa2" name="af504617c1e963028d77c7fdb6ee99aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af504617c1e963028d77c7fdb6ee99aa2">&#9670;&nbsp;</a></span>unpack_idcobj_from_idb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export unpack_idcobj_from_idb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classidc__value__t.html">idc_value_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbytevec__t.html">bytevec_t</a> *&#160;</td>
          <td class="paramname"><em>off0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pio_flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collection of register objects. </p>
<p >Read a typed idc object from the database </p>

</div>
</div>
<a id="a3ce985da43933ab09dfc7c9e4106d518" name="a3ce985da43933ab09dfc7c9e4106d518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce985da43933ab09dfc7c9e4106d518">&#9670;&nbsp;</a></span>pack_idcobj_to_bv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a9ad6b2dc3cbff040775e79656fe8e1a3">error_t</a> ida_export pack_idcobj_to_bv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classidc__value__t.html">idc_value_t</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrelobj__t.html">relobj_t</a> *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>objoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pio_flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a typed idc object to the byte vector. </p>
<p >Byte vector may be non-empty, this function will append data to it </p>

</div>
</div>
<a id="a4f2396d17985c39350c17886ce373b53" name="a4f2396d17985c39350c17886ce373b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2396d17985c39350c17886ce373b53">&#9670;&nbsp;</a></span>apply_tinfo_to_stkarg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export apply_tinfo_to_stkarg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinsn__t.html">insn_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classop__t.html">op_t</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for the processor modules. </p>
<p >to be called from processor_t::use_stkarg_type </p>

</div>
</div>
<a id="a2b5514519fbf80ceba7f301dde17ff16" name="a2b5514519fbf80ceba7f301dde17ff16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5514519fbf80ceba7f301dde17ff16">&#9670;&nbsp;</a></span>func_has_stkframe_hole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export func_has_stkframe_hole </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> &amp;&#160;</td>
          <td class="paramname"><em>fti</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for a hole at the beginning of the stack arguments. </p>
<p >Will make use of the IDB's <a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a> function at that place (if present) to help determine the presence of such a hole. </p>

</div>
</div>
<a id="a309e15239853f62a34bd81661b2438a0" name="a309e15239853f62a34bd81661b2438a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309e15239853f62a34bd81661b2438a0">&#9670;&nbsp;</a></span>lower_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export lower_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlowertype__helper__t.html">lowertype_helper_t</a> *&#160;</td>
          <td class="paramname"><em>_helper</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower type. </p>
<p >Inspect the type and lower all function subtypes using lower_func_type(). <br  />
We call the prototypes usually encountered in source files "high level" <br  />
They may have implicit arguments, array arguments, big structure retvals, etc <br  />
We introduce explicit arguments (i.e. 'this' pointer) and call the result <br  />
"low level prototype". See <a class="el" href="typeinf_8hpp.html#a59c49eb47a2f43c602070b01684ba871" title="high level prototype (with possibly hidden args)">FTI_HIGH</a>.</p>
<p >In order to improve heuristics for recognition of big structure retvals, <br  />
it is recommended to pass a helper that will be used to make decisions. <br  />
That helper will be used only for lowering 'tif', and not for the children <br  />
types walked through by recursion. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>removed <a class="el" href="typeinf_8hpp.html#a59c49eb47a2f43c602070b01684ba871" title="high level prototype (with possibly hidden args)">FTI_HIGH</a>, </td></tr>
    <tr><td class="paramname">2</td><td>made substantial changes </td></tr>
    <tr><td class="paramname">-1</td><td>failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43f876ba9da3260d61d62789a0234e7" name="ad43f876ba9da3260d61d62789a0234e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43f876ba9da3260d61d62789a0234e7">&#9670;&nbsp;</a></span>replace_ordinal_typerefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export replace_ordinal_typerefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>tif</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace references to ordinal types by name references. </p>
<p >This function 'unties' the type from the current local type library and makes it easier to export it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">til</td><td>type library to use. may be nullptr. </td></tr>
    <tr><td class="paramname">tif</td><td>type to modify (in/out) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">number</td><td>of replaced subtypes, -1 on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa417d7c0601ec34392c906300e20107c" name="aa417d7c0601ec34392c906300e20107c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa417d7c0601ec34392c906300e20107c">&#9670;&nbsp;</a></span>begin_type_updating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export begin_type_updating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a7ae46ad265dbaedeab1f06346a4d9f98">update_type_t</a>&#160;</td>
          <td class="paramname"><em>utp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the beginning of a large update operation on the types. </p>
<p >Can be used with <a class="el" href="enum_8hpp.html#aa655959dd35d5fe541c69b02ee76cf63" title="Add member to enum type.">add_enum_member()</a>, add_struc_member, etc... Also see <a class="el" href="typeinf_8hpp.html#abd6ae8f80de9c5b0941701216296264e" title="Mark the end of a large update operation on the types (see begin_type_updating())">end_type_updating()</a> </p>

</div>
</div>
<a id="ae2724af804f94383fa884c10d8774425" name="ae2724af804f94383fa884c10d8774425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2724af804f94383fa884c10d8774425">&#9670;&nbsp;</a></span>format_cdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export format_cdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a823b67c620f6cdca97e1d969ea4a9b02">qstrvec_t</a> *&#160;</td>
          <td class="paramname"><em>outvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classidc__value__t.html">idc_value_t</a> &amp;&#160;</td>
          <td class="paramname"><em>idc_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvalstr__t.html">valstr_t</a> *&#160;</td>
          <td class="paramname"><em>vtree</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structformat__data__info__t.html">format_data_info_t</a> *&#160;</td>
          <td class="paramname"><em>fdi</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a data value as a C initializer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outvec</td><td>buffer for the formatted string(s). may be nullptr </td></tr>
    <tr><td class="paramname">idc_value</td><td>value to format </td></tr>
    <tr><td class="paramname">tif</td><td>type of the data to format. if nullptr and <a class="el" href="typeinf_8hpp.html#ac2cd3059626ab4ab40a530fdfcc99abb" title="take value to print from the debugged process.">PTV_DEREF</a> is specified, take tinfo from idb </td></tr>
    <tr><td class="paramname">vtree</td><td>more detailed output info </td></tr>
    <tr><td class="paramname">fdi</td><td>formatting options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success. if failed, see qerrno for more info </dd></dl>

</div>
</div>
<a id="ad306e87a0242d5b900d848ca23b6d04e" name="ad306e87a0242d5b900d848ca23b6d04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad306e87a0242d5b900d848ca23b6d04e">&#9670;&nbsp;</a></span>print_cdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export print_cdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtext__sink__t.html">text_sink_t</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classidc__value__t.html">idc_value_t</a> &amp;&#160;</td>
          <td class="paramname"><em>idc_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> *&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structformat__data__info__t.html">format_data_info_t</a> *&#160;</td>
          <td class="paramname"><em>fdi</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The same as <a class="el" href="typeinf_8hpp.html#ae2724af804f94383fa884c10d8774425" title="Format a data value as a C initializer.">format_cdata()</a>, but instead of returning the answer in a vector, print it. </p>
<p >This function can handle very huge data volume without using too much memory. As soon as the output text becomes too long, the function prints it and flushes its internal buffers. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>printing failed, check qerrno </td></tr>
    <tr><td class="paramname">else</td><td>code returned by <a class="el" href="structtext__sink__t.html#a7b570b7996829f9dbcd36a7811b4cb64">text_sink_t::print()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae693627c85f4a9d02c34adb1b5055570" name="ae693627c85f4a9d02c34adb1b5055570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae693627c85f4a9d02c34adb1b5055570">&#9670;&nbsp;</a></span>print_decls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export print_decls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtext__sink__t.html">text_sink_t</a> &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classqvector.html">ordvec_t</a> *&#160;</td>
          <td class="paramname"><em>ordinals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>pdf_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print types (and possibly their dependencies) in a format suitable for using in a header file. </p>
<p >This is the reverse <a class="el" href="typeinf_8hpp.html#ae4cec61d812cfc0acc08453742b729b3" title="Parse many declarations and store them in a til.">parse_decls()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">printer</td><td>a handler for printing text </td></tr>
    <tr><td class="paramname">til</td><td>the type library holding the ordinals </td></tr>
    <tr><td class="paramname">ordinals</td><td>ordinals of types to export. nullptr means: all ordinals in til </td></tr>
    <tr><td class="paramname">pdf_flags</td><td>flags for the algorithm. A combination of PDF_ constants </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>the number of types exported </td></tr>
    <tr><td class="paramname">0</td><td>an error occurred </td></tr>
    <tr><td class="paramname">&lt;0</td><td>the negated number of types exported. There were minor errors and the resulting output might not be compilable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a054f399b8040e3504a6a0288e85ca4d6" name="a054f399b8040e3504a6a0288e85ca4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054f399b8040e3504a6a0288e85ca4d6">&#9670;&nbsp;</a></span>calc_number_of_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export calc_number_of_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classargloc__t.html">argloc_t</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dont_deref_ptr</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate max number of lines of a formatted c data, when expanded (<a class="el" href="typeinf_8hpp.html#a3961c67927e9f622c548d492555ecda7" title="print only top level on separate lines; max_length applies to separate lines; margin is ignored">PTV_EXPAND</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>location of the data (<a class="el" href="typeinf_8hpp.html#a9342b6c4b8dcb9c10ee69c2a5251f3dc" title="global address">ALOC_STATIC</a> or <a class="el" href="typeinf_8hpp.html#a6be7eb6681fc4a4396bfd4ba9b28af95" title="custom argloc (7 or higher)">ALOC_CUSTOM</a>) </td></tr>
    <tr><td class="paramname">tif</td><td>type info </td></tr>
    <tr><td class="paramname">dont_deref_ptr</td><td>consider 'ea' as the ptr value </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>data is not expandable </td></tr>
    <tr><td class="paramname">-1</td><td>error, see qerrno </td></tr>
    <tr><td class="paramname">else</td><td>the max number of lines </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ba339494aea0462baa7558b05480e17" name="a9ba339494aea0462baa7558b05480e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba339494aea0462baa7558b05480e17">&#9670;&nbsp;</a></span>format_c_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman size_t ida_export format_c_number </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint128&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pcn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a C number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>size of the output buffer </td></tr>
    <tr><td class="paramname">value</td><td>number to format </td></tr>
    <tr><td class="paramname">size</td><td>size of the number in bytes (1,2,4,8,16) </td></tr>
    <tr><td class="paramname">pcn</td><td>combination of <a class="el" href="group___p_c_n__.html">C Number formatting flags</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7779b7d833a30bcbeb313ae4be6b3547" name="a7779b7d833a30bcbeb313ae4be6b3547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7779b7d833a30bcbeb313ae4be6b3547">&#9670;&nbsp;</a></span>get_enum_member_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export get_enum_member_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a C expression that can be used to represent an enum member. </p>
<p >If the value does not correspond to any single enum member, this function tries to find a bitwise combination of enum members that correspond to it. If more than half of value bits do not match any enum members, it fails. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer </td></tr>
    <tr><td class="paramname">tif</td><td>enumeration type </td></tr>
    <tr><td class="paramname">serial</td><td>which enumeration member to use (0 means the first with the given value) </td></tr>
    <tr><td class="paramname">value</td><td>value to search in the enumeration type. only 32-bit number can be handled yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a52f7cfb48f3f391a78f8fea18e3e51ea" name="a52f7cfb48f3f391a78f8fea18e3e51ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f7cfb48f3f391a78f8fea18e3e51ea">&#9670;&nbsp;</a></span>choose_named_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export choose_named_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__symbol__t.html">til_symbol_t</a> *&#160;</td>
          <td class="paramname"><em>out_sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>root_til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpredicate__t.html">predicate_t</a> *&#160;</td>
          <td class="paramname"><em>predicate</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose a type from a type library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_sym</td><td>pointer to be filled with the chosen type </td></tr>
    <tr><td class="paramname">root_til</td><td>pointer to starting til (the function will inspect the base tils if allowed by flags) </td></tr>
    <tr><td class="paramname">title</td><td>title of listbox to display </td></tr>
    <tr><td class="paramname">ntf_flags</td><td>combination of <a class="el" href="group___n_t_f__.html">Flags for named types</a> </td></tr>
    <tr><td class="paramname">predicate</td><td>predicate to select types to display (maybe nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if nothing is chosen, otherwise true </dd></dl>

</div>
</div>
<a id="a9a77b1660621bf2ea16dbd401c80a39a" name="a9a77b1660621bf2ea16dbd401c80a39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a77b1660621bf2ea16dbd401c80a39a">&#9670;&nbsp;</a></span>choose_local_tinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export choose_local_tinfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#ab50d6548ef1add1a4a33341539d9f737">local_tinfo_predicate_t</a> *&#160;</td>
          <td class="paramname"><em>func</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>def_ord</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose a type from the local type library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ti</td><td>pointer to til </td></tr>
    <tr><td class="paramname">title</td><td>title of listbox to display </td></tr>
    <tr><td class="paramname">func</td><td>predicate to select types to display (maybe nullptr) </td></tr>
    <tr><td class="paramname">def_ord</td><td>ordinal to position cursor before choose </td></tr>
    <tr><td class="paramname">ud</td><td>user data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>== 0 means nothing is chosen, otherwise an ordinal number </dd></dl>

</div>
</div>
<a id="a4e044dce82ece0cb92f29a176fe7b828" name="a4e044dce82ece0cb92f29a176fe7b828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e044dce82ece0cb92f29a176fe7b828">&#9670;&nbsp;</a></span>choose_local_tinfo_and_delta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ida_export choose_local_tinfo_and_delta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> *&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#ab50d6548ef1add1a4a33341539d9f737">local_tinfo_predicate_t</a> *&#160;</td>
          <td class="paramname"><em>func</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>def_ord</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose a type from the local type library and specify the pointer shift value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>pointer shift value </td></tr>
    <tr><td class="paramname">ti</td><td>pointer to til </td></tr>
    <tr><td class="paramname">title</td><td>title of listbox to display </td></tr>
    <tr><td class="paramname">func</td><td>predicate to select types to display (maybe nullptr) </td></tr>
    <tr><td class="paramname">def_ord</td><td>ordinal to position cursor before choose </td></tr>
    <tr><td class="paramname">ud</td><td>user data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>== 0 means nothing is chosen, otherwise an ordinal number </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afba446d2cb3b761e1af374cd209a911e" name="afba446d2cb3b761e1af374cd209a911e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba446d2cb3b761e1af374cd209a911e">&#9670;&nbsp;</a></span>TYPE_MODIF_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> TYPE_MODIF_MASK = 0xC0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>modifiers. </p>
<ul>
<li>for <a class="el" href="typeinf_8hpp.html#a8c17124d38e796e7cd8804808e4bb5b3" title="array">BT_ARRAY</a> see <a class="el" href="group__tf__array.html">Derived type: array</a></li>
<li><a class="el" href="typeinf_8hpp.html#af99e9832d21e1b090117fc2feab1c2b5" title="void">BT_VOID</a> can have them ONLY in 'void *' </li>
</ul>

</div>
</div>
<a id="a2fc0128b8f9f51961efa661bd6c36523" name="a2fc0128b8f9f51961efa661bd6c36523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc0128b8f9f51961efa661bd6c36523">&#9670;&nbsp;</a></span>BTMT_CHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> BTMT_CHAR = 0x30</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specify char or segment register </p>
<ul>
<li><a class="el" href="typeinf_8hpp.html#ad44635e5f36e3ff87017e674a0ba1e96" title="__int8">BT_INT8</a> - char</li>
<li><a class="el" href="typeinf_8hpp.html#a0247bd6d30b0ca1725ec2cf6cbccdc83" title="natural int. (size provided by idp module)">BT_INT</a> - segment register</li>
<li>other BT_INT... - don't use </li>
</ul>

</div>
</div>
<a id="a34f394b71c9b27c46560178e0054f79b" name="a34f394b71c9b27c46560178e0054f79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f394b71c9b27c46560178e0054f79b">&#9670;&nbsp;</a></span>BTMT_SPECFLT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> BTMT_SPECFLT = 0x30</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>float (variable size). </p>
<p >if <a class="el" href="structprocessor__t.html#a7e5ad4df4d0825ffbefceb583ac8a284" title="PR_USE_TBYTE">processor_t::use_tbyte()</a> then use <a class="el" href="structprocessor__t.html#a7a1ea672e493ec9b59b6d3d8e09d69e1" title="Size of long double (tbyte) for this processor (meaningful only if asm_t::a_tbyte !...">processor_t::tbyte_size</a>, otherwise 2 bytes </p>

</div>
</div>
<a id="a1ea9ae22535f9fb09b2c74f6e7526d4e" name="a1ea9ae22535f9fb09b2c74f6e7526d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea9ae22535f9fb09b2c74f6e7526d4e">&#9670;&nbsp;</a></span>BT_PTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> BT_PTR = 0x0A</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer. </p>
<p >has the following format: [db sizeof(ptr)]; [tah-typeattrs]; type_t... </p>

</div>
</div>
<a id="a17a80f306cfd595df0d7bd2f5a9ddc64" name="a17a80f306cfd595df0d7bd2f5a9ddc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a80f306cfd595df0d7bd2f5a9ddc64">&#9670;&nbsp;</a></span>BTMT_CLOSURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> BTMT_CLOSURE = 0x30</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>closure. </p>
<ul>
<li>if ptr to <a class="el" href="typeinf_8hpp.html#a7b7fee21f21237beb6d91e854410e0fa" title="function.">BT_FUNC</a> - __closure. in this case next byte MUST be <a class="el" href="typeinf_8hpp.html#a8ac9fa3da7151dc5ffd9fbf0563a9417" title="multifunctional purpose">RESERVED_BYTE</a>, and after it <a class="el" href="typeinf_8hpp.html#a7b7fee21f21237beb6d91e854410e0fa" title="function.">BT_FUNC</a></li>
<li>else the next byte contains sizeof(ptr) allowed values are 1 - <a class="el" href="">ph</a>.<a class="el" href="">max_ptr_size</a></li>
<li>if value is bigger than <a class="el" href="">ph</a>.<a class="el" href="">max_ptr_size</a>, based_ptr_name_and_size() is called to find out the typeinfo </li>
</ul>

</div>
</div>
<a id="a0590f6ba2edff6c58152908be5137f6c" name="a0590f6ba2edff6c58152908be5137f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0590f6ba2edff6c58152908be5137f6c">&#9670;&nbsp;</a></span>BTMT_NONBASED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> BTMT_NONBASED = 0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="keywordflow">if</span> set</div>
<div class="line">   array base==0</div>
<div class="line">   format: dt num_elem; [tah-typeattrs]; type_t...</div>
<div class="line">   <span class="keywordflow">if</span> num_elem==0 then the array size is unknown</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">   format: da num_elem, base; [tah-typeattrs]; type_t... </div>
</div><!-- fragment --><p> used only for serialization </p>

</div>
</div>
<a id="a7b7fee21f21237beb6d91e854410e0fa" name="a7b7fee21f21237beb6d91e854410e0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7fee21f21237beb6d91e854410e0fa">&#9670;&nbsp;</a></span>BT_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> BT_FUNC = 0x0C</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function. </p>
<p >format: </p><pre>
      optional: <a class="el" href="typeinf_8hpp.html#a81fe26502529dff431e52823a24db36b" title="This is NOT a cc! Mark of __spoil record the low nibble is count and after n {spoilreg_t} present rea...">CM_CC_SPOILED</a> | num_of_spoiled_regs
                if num_of_spoiled_reg == BFA_FUNC_MARKER:
                  ::bfa_byte
                  if (bfa_byte &amp; BFA_FUNC_EXT_FORMAT) != 0
                   ::fti_bits (only low bits: FTI_SPOILED,...,FTI_VIRTUAL)
                   num_of_spoiled_reg times: spoiled reg info (see extract_spoiledreg)
                  else
                    bfa_byte is function attribute byte (see <a class="el" href="group___b_f_a__.html">Function attribute byte</a>...)
                else:
                  num_of_spoiled_reg times: spoiled reg info (see extract_spoiledreg)
      <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model">cm_t</a> ... calling convention and memory model
      [tah-typeattrs];
      <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733" title="byte sequence used to describe a type in IDA (see Type flags)">type_t</a> ... return type;
      [serialized <a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> of returned value (if <a class="el" href="typeinf_8hpp.html#a377054c414ac35be6e5e9bf6c550b390" title="usercall: locations of all arguments and the return value are explicitly specified">CM_CC_SPECIAL</a>{PE} &amp;&amp; !return void);
      if !<a class="el" href="typeinf_8hpp.html#aecea308116df480106f38d080f73ab8e" title="function without arguments if has other cc and argnum == 0, represent as f() - unknown list">CM_CC_VOIDARG</a>:
        dt N (N=number of parameters)
        if ( N == 0 )
        if <a class="el" href="typeinf_8hpp.html#a8e4d072bec04a20754290978b8b141be" title="cdecl + ellipsis">CM_CC_ELLIPSIS</a> or <a class="el" href="typeinf_8hpp.html#a6c042d42c6daf03444d06907a8498b06" title="CM_CC_SPECIAL with ellipsis">CM_CC_SPECIALE</a>
            func(...)
          else
            parameters are unknown
        else
          N records:
            <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733" title="byte sequence used to describe a type in IDA (see Type flags)">type_t</a> ... (i.e. type of each parameter)
            [serialized <a class="el" href="classargloc__t.html" title="Describes an argument location.">argloc_t</a> (if <a class="el" href="typeinf_8hpp.html#a377054c414ac35be6e5e9bf6c550b390" title="usercall: locations of all arguments and the return value are explicitly specified">CM_CC_SPECIAL</a>{PE})] (i.e. place of each parameter)
            [<a class="el" href="typeinf_8hpp.html#ab68b66c0853e4271d2ab199fa3a50f3f" title="function argument attribute header byte">FAH_BYTE</a> + de( <a class="el" href="structfuncarg__t.html#ad8e3c72762a709b04a234fbb8cc1c9ec">funcarg_t::flags</a> )] </pre> 
</div>
</div>
<a id="a86c5e589737e005ba4741423fd2ca5c6" name="a86c5e589737e005ba4741423fd2ca5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c5e589737e005ba4741423fd2ca5c6">&#9670;&nbsp;</a></span>BT_COMPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> BT_COMPLEX = 0x0D</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>struct/union/enum/typedef. </p>
<p >format: </p><pre>
       [dt N (N=field count) if !<a class="el" href="typeinf_8hpp.html#aa4e0907e07d1538053682550c2117290" title="named reference always p_string name">BTMT_TYPEDEF</a>]
       if N == 0:
         p_string name (unnamed types have names "anon_...")
         [sdacl-typeattrs];
       else, for struct &amp; union:
         if N == 0x7FFE   // Support for high (i.e., &gt; 4095) members count
           N = deserialize_de()
         ALPOW = N &amp; 0x7
         MCNT = N &gt;&gt; 3
         if MCNT == 0
           empty struct
         if ALPOW == 0
           ALIGN = <a class="el" href="typeinf_8hpp.html#a370b5b72b6b9d2935babdd8dbb98bfdf" title="Get default alignment for structure fields.">get_default_align()</a>
         else
           ALIGN = (1 &lt;&lt; (ALPOW - 1))
         [sdacl-typeattrs];
       else, for enums:
         if N == 0x7FFE   // Support for high enum entries count.
           N = deserialize_de()
         [tah-typeattrs]; </pre> 
</div>
</div>
<a id="aec042ce7c6f887be34b76ae5f404e482" name="aec042ce7c6f887be34b76ae5f404e482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec042ce7c6f887be34b76ae5f404e482">&#9670;&nbsp;</a></span>BTE_SIZE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a> BTE_SIZE_MASK = 0x07</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>storage size. </p>
<ul>
<li>if == 0 then inf_get_cc_size_e()</li>
<li>else 1 &lt;&lt; (n -1) = 1,2,4...64 </li>
</ul>

</div>
</div>
<a id="a11628b413da4de1841d54d3684fbbf4f" name="a11628b413da4de1841d54d3684fbbf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11628b413da4de1841d54d3684fbbf4f">&#9670;&nbsp;</a></span>BTE_BITFIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="typeinf_8hpp.html#a9ae7aa54dbc597ec17cbb17555306a02">bte_t</a> BTE_BITFIELD = 0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'subarrays'. </p>
<p >In this case ANY record has the following format:</p><ul>
<li>'de' mask (has name)</li>
<li>'dt' cnt</li>
<li>cnt records of 'de' values (cnt CAN be 0) <dl class="section note"><dt>Note</dt><dd>delta for ALL subsegment is ONE </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a81fe26502529dff431e52823a24db36b" name="a81fe26502529dff431e52823a24db36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fe26502529dff431e52823a24db36b">&#9670;&nbsp;</a></span>CM_CC_SPOILED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a> CM_CC_SPOILED = 0xA0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is NOT a cc! Mark of __spoil record the low nibble is count and after n {spoilreg_t} present real cm_t byte. </p>
<p >if n == BFA_FUNC_MARKER, the next byte is the function attribute byte. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
