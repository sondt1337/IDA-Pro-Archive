<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: frame.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">frame.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Routines to manipulate function stack frames, stack variables, register variables and local labels.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstkpnt__t.html">stkpnt_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstkpnts__t.html">stkpnts_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregvar__t.html">regvar_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A register variable allows the user to rename a general processor register to a meaningful name.  <a href="structregvar__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxreflist__entry__t.html">xreflist_entry_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An xref to an argument or variable located in a function's stack frame.  <a href="structxreflist__entry__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:adea83308bbe3028f66bde2b06d3931e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#adea83308bbe3028f66bde2b06d3931e1">STKVAR_VALID_SIZE</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:adea83308bbe3028f66bde2b06d3931e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">x.dtyp contains correct variable type (for insns like 'lea' this bit must be off).  <a href="frame_8hpp.html#adea83308bbe3028f66bde2b06d3931e1">More...</a><br /></td></tr>
<tr class="separator:adea83308bbe3028f66bde2b06d3931e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583c0f5683ebbc2fda4b3d17f9a44484"><td class="memItemLeft" align="right" valign="top"><a id="a583c0f5683ebbc2fda4b3d17f9a44484" name="a583c0f5683ebbc2fda4b3d17f9a44484"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REGVAR_ERROR_OK</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a583c0f5683ebbc2fda4b3d17f9a44484"><td class="mdescLeft">&#160;</td><td class="mdescRight">all ok <br /></td></tr>
<tr class="separator:a583c0f5683ebbc2fda4b3d17f9a44484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9174f12f12b7415326bb4baa0bcaa416"><td class="memItemLeft" align="right" valign="top"><a id="a9174f12f12b7415326bb4baa0bcaa416" name="a9174f12f12b7415326bb4baa0bcaa416"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REGVAR_ERROR_ARG</b>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:a9174f12f12b7415326bb4baa0bcaa416"><td class="mdescLeft">&#160;</td><td class="mdescRight">function arguments are bad <br /></td></tr>
<tr class="separator:a9174f12f12b7415326bb4baa0bcaa416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde3e058bcbf2f1e663b5565cea5c40c"><td class="memItemLeft" align="right" valign="top"><a id="acde3e058bcbf2f1e663b5565cea5c40c" name="acde3e058bcbf2f1e663b5565cea5c40c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REGVAR_ERROR_RANGE</b>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:acde3e058bcbf2f1e663b5565cea5c40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the definition range is bad <br /></td></tr>
<tr class="separator:acde3e058bcbf2f1e663b5565cea5c40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812754dcd62f1afa4789f66c29caf530"><td class="memItemLeft" align="right" valign="top"><a id="a812754dcd62f1afa4789f66c29caf530" name="a812754dcd62f1afa4789f66c29caf530"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>REGVAR_ERROR_NAME</b>&#160;&#160;&#160;(-3)</td></tr>
<tr class="memdesc:a812754dcd62f1afa4789f66c29caf530"><td class="mdescLeft">&#160;</td><td class="mdescRight">the provided name(s) can't be accepted <br /></td></tr>
<tr class="separator:a812754dcd62f1afa4789f66c29caf530"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a88d80d5d38b062a7743afc80d32e8a2c"><td class="memItemLeft" align="right" valign="top"><a id="a88d80d5d38b062a7743afc80d32e8a2c" name="a88d80d5d38b062a7743afc80d32e8a2c"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structxreflist__entry__t.html">xreflist_entry_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>xreflist_t</b></td></tr>
<tr class="memdesc:a88d80d5d38b062a7743afc80d32e8a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of xrefs to variables in a function's stack frame <br /></td></tr>
<tr class="separator:a88d80d5d38b062a7743afc80d32e8a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7277e4b0fbb084261a7e828ec29c88e7"><td class="memItemLeft" align="right" valign="top"><a id="a7277e4b0fbb084261a7e828ec29c88e7" name="a7277e4b0fbb084261a7e828ec29c88e7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a7277e4b0fbb084261a7e828ec29c88e7">frame_part_t</a> { <b>FPC_ARGS</b>
, <b>FPC_RETADDR</b>
, <b>FPC_SAVREGS</b>
, <b>FPC_LVARS</b>
 }</td></tr>
<tr class="memdesc:a7277e4b0fbb084261a7e828ec29c88e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parts of a frame. <br /></td></tr>
<tr class="separator:a7277e4b0fbb084261a7e828ec29c88e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a248f3def030aba4ba4b0ac2fec67a472"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a248f3def030aba4ba4b0ac2fec67a472">add_frame</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> frsize, <a class="el" href="pro_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> frregs, asize_t argsize)</td></tr>
<tr class="memdesc:a248f3def030aba4ba4b0ac2fec67a472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add function frame.  <a href="frame_8hpp.html#a248f3def030aba4ba4b0ac2fec67a472">More...</a><br /></td></tr>
<tr class="separator:a248f3def030aba4ba4b0ac2fec67a472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f27311ac95915332fec813bc65f3dc6"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a8f27311ac95915332fec813bc65f3dc6">del_frame</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a8f27311ac95915332fec813bc65f3dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a function frame.  <a href="frame_8hpp.html#a8f27311ac95915332fec813bc65f3dc6">More...</a><br /></td></tr>
<tr class="separator:a8f27311ac95915332fec813bc65f3dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713c7440f3458dfe4318bd1e92743f2e"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a713c7440f3458dfe4318bd1e92743f2e">set_frame_size</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, asize_t frsize, <a class="el" href="pro_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a> frregs, asize_t argsize)</td></tr>
<tr class="memdesc:a713c7440f3458dfe4318bd1e92743f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size of function frame.  <a href="frame_8hpp.html#a713c7440f3458dfe4318bd1e92743f2e">More...</a><br /></td></tr>
<tr class="separator:a713c7440f3458dfe4318bd1e92743f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cd09a14b5832965ad746d5e605ef87"><td class="memItemLeft" align="right" valign="top">idaman asize_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a06cd09a14b5832965ad746d5e605ef87">get_frame_size</a> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a06cd09a14b5832965ad746d5e605ef87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full size of a function frame.  <a href="frame_8hpp.html#a06cd09a14b5832965ad746d5e605ef87">More...</a><br /></td></tr>
<tr class="separator:a06cd09a14b5832965ad746d5e605ef87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f585fc61fb88ad3ee8b90b2d0993a2e"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a1f585fc61fb88ad3ee8b90b2d0993a2e">get_frame_retsize</a> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a1f585fc61fb88ad3ee8b90b2d0993a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of function return address.  <a href="frame_8hpp.html#a1f585fc61fb88ad3ee8b90b2d0993a2e">More...</a><br /></td></tr>
<tr class="separator:a1f585fc61fb88ad3ee8b90b2d0993a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227ca109bc1fdf781d018c037901eeec"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a227ca109bc1fdf781d018c037901eeec">get_frame_part</a> (<a class="el" href="structrange__t.html">range_t</a> *range, const <a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="frame_8hpp.html#a7277e4b0fbb084261a7e828ec29c88e7">frame_part_t</a> part)</td></tr>
<tr class="memdesc:a227ca109bc1fdf781d018c037901eeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offsets of the frame part in the frame.  <a href="frame_8hpp.html#a227ca109bc1fdf781d018c037901eeec">More...</a><br /></td></tr>
<tr class="separator:a227ca109bc1fdf781d018c037901eeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f814fdfb6e3307611f60491be7386f"><td class="memItemLeft" align="right" valign="top"><a id="a47f814fdfb6e3307611f60491be7386f" name="a47f814fdfb6e3307611f60491be7386f"></a>
ea_t&#160;</td><td class="memItemRight" valign="bottom"><b>frame_off_args</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a47f814fdfb6e3307611f60491be7386f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get starting address of arguments section. <br /></td></tr>
<tr class="separator:a47f814fdfb6e3307611f60491be7386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2075164225d9cc53c6964a5adcfaf0dd"><td class="memItemLeft" align="right" valign="top"><a id="a2075164225d9cc53c6964a5adcfaf0dd" name="a2075164225d9cc53c6964a5adcfaf0dd"></a>
ea_t&#160;</td><td class="memItemRight" valign="bottom"><b>frame_off_retaddr</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a2075164225d9cc53c6964a5adcfaf0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get starting address of return address section. <br /></td></tr>
<tr class="separator:a2075164225d9cc53c6964a5adcfaf0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd88c894a96749d393dcd369e64cfa23"><td class="memItemLeft" align="right" valign="top"><a id="abd88c894a96749d393dcd369e64cfa23" name="abd88c894a96749d393dcd369e64cfa23"></a>
ea_t&#160;</td><td class="memItemRight" valign="bottom"><b>frame_off_savregs</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:abd88c894a96749d393dcd369e64cfa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get starting address of saved registers section. <br /></td></tr>
<tr class="separator:abd88c894a96749d393dcd369e64cfa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2508cc9a0bc14d2a4b36a6434ffdebc"><td class="memItemLeft" align="right" valign="top"><a id="af2508cc9a0bc14d2a4b36a6434ffdebc" name="af2508cc9a0bc14d2a4b36a6434ffdebc"></a>
ea_t&#160;</td><td class="memItemRight" valign="bottom"><b>frame_off_lvars</b> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:af2508cc9a0bc14d2a4b36a6434ffdebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get start address of local variables section. <br /></td></tr>
<tr class="separator:af2508cc9a0bc14d2a4b36a6434ffdebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25883d7ab5d18e89bd843c75320e987"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classstruc__t.html">struc_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#aa25883d7ab5d18e89bd843c75320e987">get_frame</a> (const <a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:aa25883d7ab5d18e89bd843c75320e987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to function frame.  <a href="frame_8hpp.html#aa25883d7ab5d18e89bd843c75320e987">More...</a><br /></td></tr>
<tr class="separator:aa25883d7ab5d18e89bd843c75320e987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bc6a5c4f8ff04c4c92f672198c33cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstruc__t.html">struc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a70bc6a5c4f8ff04c4c92f672198c33cd">get_frame</a> (ea_t ea)</td></tr>
<tr class="memdesc:a70bc6a5c4f8ff04c4c92f672198c33cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to function frame.  <a href="frame_8hpp.html#a70bc6a5c4f8ff04c4c92f672198c33cd">More...</a><br /></td></tr>
<tr class="separator:a70bc6a5c4f8ff04c4c92f672198c33cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8cad41bcd22c5739e4477168974120"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a7c8cad41bcd22c5739e4477168974120">soff_to_fpoff</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> soff)</td></tr>
<tr class="memdesc:a7c8cad41bcd22c5739e4477168974120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert struct offsets into fp-relative offsets.  <a href="frame_8hpp.html#a7c8cad41bcd22c5739e4477168974120">More...</a><br /></td></tr>
<tr class="separator:a7c8cad41bcd22c5739e4477168974120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8284122ba3ea987a183ead63859b4902"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a8284122ba3ea987a183ead63859b4902">update_fpd</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, asize_t fpd)</td></tr>
<tr class="memdesc:a8284122ba3ea987a183ead63859b4902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update frame pointer delta.  <a href="frame_8hpp.html#a8284122ba3ea987a183ead63859b4902">More...</a><br /></td></tr>
<tr class="separator:a8284122ba3ea987a183ead63859b4902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7b4155b3c9bb4143f43a1905f62e26"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a7d7b4155b3c9bb4143f43a1905f62e26">set_purged</a> (ea_t ea, int nbytes, bool override_old_value)</td></tr>
<tr class="memdesc:a7d7b4155b3c9bb4143f43a1905f62e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of purged bytes for a function or data item (funcptr).  <a href="frame_8hpp.html#a7d7b4155b3c9bb4143f43a1905f62e26">More...</a><br /></td></tr>
<tr class="separator:a7d7b4155b3c9bb4143f43a1905f62e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50781e1dc737efc6b1db5552fe0be9f7"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a50781e1dc737efc6b1db5552fe0be9f7">get_func_by_frame</a> (<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> frame_id)</td></tr>
<tr class="memdesc:a50781e1dc737efc6b1db5552fe0be9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get function by its frame id.  <a href="frame_8hpp.html#a50781e1dc737efc6b1db5552fe0be9f7">More...</a><br /></td></tr>
<tr class="separator:a50781e1dc737efc6b1db5552fe0be9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883390acc0ac0805b5d9182602d8c605"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a883390acc0ac0805b5d9182602d8c605">get_stkvar</a> (<a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> *actval, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, const <a class="el" href="classop__t.html">op_t</a> &amp;x, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> v)</td></tr>
<tr class="memdesc:a883390acc0ac0805b5d9182602d8c605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to stack variable.  <a href="frame_8hpp.html#a883390acc0ac0805b5d9182602d8c605">More...</a><br /></td></tr>
<tr class="separator:a883390acc0ac0805b5d9182602d8c605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecc3558ed60be999ec7b3e7d682dad3"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a6ecc3558ed60be999ec7b3e7d682dad3">add_stkvar</a> (const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, const <a class="el" href="classop__t.html">op_t</a> &amp;x, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> v, int flags)</td></tr>
<tr class="memdesc:a6ecc3558ed60be999ec7b3e7d682dad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically add stack variable if doesn't exist.  <a href="frame_8hpp.html#a6ecc3558ed60be999ec7b3e7d682dad3">More...</a><br /></td></tr>
<tr class="separator:a6ecc3558ed60be999ec7b3e7d682dad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bbf7162a2d71aa96f747762d3f3040"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#ab4bbf7162a2d71aa96f747762d3f3040">define_stkvar</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, const char *name, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> off, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> flags, const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *ti, asize_t nbytes)</td></tr>
<tr class="memdesc:ab4bbf7162a2d71aa96f747762d3f3040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define/redefine a stack variable.  <a href="frame_8hpp.html#ab4bbf7162a2d71aa96f747762d3f3040">More...</a><br /></td></tr>
<tr class="separator:ab4bbf7162a2d71aa96f747762d3f3040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb089d29a4ea64752af90dc32a4baf2c"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#aeb089d29a4ea64752af90dc32a4baf2c">build_stkvar_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> v)</td></tr>
<tr class="memdesc:aeb089d29a4ea64752af90dc32a4baf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build automatic stack variable name.  <a href="frame_8hpp.html#aeb089d29a4ea64752af90dc32a4baf2c">More...</a><br /></td></tr>
<tr class="separator:aeb089d29a4ea64752af90dc32a4baf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3161147e2b4325883c73c86034d71ba"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#af3161147e2b4325883c73c86034d71ba">calc_stkvar_struc_offset</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn, int n)</td></tr>
<tr class="memdesc:af3161147e2b4325883c73c86034d71ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate offset of stack variable in the frame structure.  <a href="frame_8hpp.html#af3161147e2b4325883c73c86034d71ba">More...</a><br /></td></tr>
<tr class="separator:af3161147e2b4325883c73c86034d71ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaa7150097393bae7091d317ad8ac79"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#aacaa7150097393bae7091d317ad8ac79">delete_wrong_frame_info</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, bool idaapi should_reanalyze(const <a class="el" href="classinsn__t.html">insn_t</a> &amp;insn))</td></tr>
<tr class="memdesc:aacaa7150097393bae7091d317ad8ac79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and delete wrong frame info.  <a href="frame_8hpp.html#aacaa7150097393bae7091d317ad8ac79">More...</a><br /></td></tr>
<tr class="separator:aacaa7150097393bae7091d317ad8ac79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a61b0e9102f355f13f4bd192df3b909"><td class="memItemLeft" align="right" valign="top"><a id="a5a61b0e9102f355f13f4bd192df3b909" name="a5a61b0e9102f355f13f4bd192df3b909"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>free_regvar</b> (struct <a class="el" href="structregvar__t.html">regvar_t</a> *v)</td></tr>
<tr class="separator:a5a61b0e9102f355f13f4bd192df3b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f77d2c231f8faeb5939be2bc8e2a298"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a5f77d2c231f8faeb5939be2bc8e2a298">add_regvar</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea1, ea_t ea2, const char *canon, const char *user, const char *cmt)</td></tr>
<tr class="memdesc:a5f77d2c231f8faeb5939be2bc8e2a298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a register variable.  <a href="frame_8hpp.html#a5f77d2c231f8faeb5939be2bc8e2a298">More...</a><br /></td></tr>
<tr class="separator:a5f77d2c231f8faeb5939be2bc8e2a298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85af8e7f76b191d51fd3aeb95104dee7"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="structregvar__t.html">regvar_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a85af8e7f76b191d51fd3aeb95104dee7">find_regvar</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea1, ea_t ea2, const char *canon, const char *user)</td></tr>
<tr class="memdesc:a85af8e7f76b191d51fd3aeb95104dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a register variable definition (powerful version).  <a href="frame_8hpp.html#a85af8e7f76b191d51fd3aeb95104dee7">More...</a><br /></td></tr>
<tr class="separator:a85af8e7f76b191d51fd3aeb95104dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada160cc32177f5d1f81fea165385ee90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregvar__t.html">regvar_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#ada160cc32177f5d1f81fea165385ee90">find_regvar</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea, const char *canon)</td></tr>
<tr class="memdesc:ada160cc32177f5d1f81fea165385ee90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a register variable definition.  <a href="frame_8hpp.html#ada160cc32177f5d1f81fea165385ee90">More...</a><br /></td></tr>
<tr class="separator:ada160cc32177f5d1f81fea165385ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fec00b4effdb288f0aef24e7f6381a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#ae2fec00b4effdb288f0aef24e7f6381a">has_regvar</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="memdesc:ae2fec00b4effdb288f0aef24e7f6381a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there a register variable definition?  <a href="frame_8hpp.html#ae2fec00b4effdb288f0aef24e7f6381a">More...</a><br /></td></tr>
<tr class="separator:ae2fec00b4effdb288f0aef24e7f6381a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f5e5e05bd45253e8e546e8d7048e44"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a28f5e5e05bd45253e8e546e8d7048e44">rename_regvar</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="structregvar__t.html">regvar_t</a> *v, const char *user)</td></tr>
<tr class="memdesc:a28f5e5e05bd45253e8e546e8d7048e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a register variable.  <a href="frame_8hpp.html#a28f5e5e05bd45253e8e546e8d7048e44">More...</a><br /></td></tr>
<tr class="separator:a28f5e5e05bd45253e8e546e8d7048e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864c220a61416541dcbc6b0d35353b5d"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a864c220a61416541dcbc6b0d35353b5d">set_regvar_cmt</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, <a class="el" href="structregvar__t.html">regvar_t</a> *v, const char *cmt)</td></tr>
<tr class="memdesc:a864c220a61416541dcbc6b0d35353b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set comment for a register variable.  <a href="frame_8hpp.html#a864c220a61416541dcbc6b0d35353b5d">More...</a><br /></td></tr>
<tr class="separator:a864c220a61416541dcbc6b0d35353b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28b200b6ffb1dfe1dad1683ac87d112"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#ae28b200b6ffb1dfe1dad1683ac87d112">del_regvar</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea1, ea_t ea2, const char *canon)</td></tr>
<tr class="memdesc:ae28b200b6ffb1dfe1dad1683ac87d112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a register variable definition.  <a href="frame_8hpp.html#ae28b200b6ffb1dfe1dad1683ac87d112">More...</a><br /></td></tr>
<tr class="separator:ae28b200b6ffb1dfe1dad1683ac87d112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245da2e9f6e1f65ca306d0bab0db5368"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a245da2e9f6e1f65ca306d0bab0db5368">add_auto_stkpnt</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> delta)</td></tr>
<tr class="memdesc:a245da2e9f6e1f65ca306d0bab0db5368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add automatic SP register change point.  <a href="frame_8hpp.html#a245da2e9f6e1f65ca306d0bab0db5368">More...</a><br /></td></tr>
<tr class="separator:a245da2e9f6e1f65ca306d0bab0db5368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13680589c0aea771a34d1fd0d63c37f"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#ab13680589c0aea771a34d1fd0d63c37f">add_user_stkpnt</a> (ea_t ea, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> delta)</td></tr>
<tr class="memdesc:ab13680589c0aea771a34d1fd0d63c37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add user-defined SP register change point.  <a href="frame_8hpp.html#ab13680589c0aea771a34d1fd0d63c37f">More...</a><br /></td></tr>
<tr class="separator:ab13680589c0aea771a34d1fd0d63c37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68a1de58fbd9e15b5a46d0189369467"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#ac68a1de58fbd9e15b5a46d0189369467">del_stkpnt</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="memdesc:ac68a1de58fbd9e15b5a46d0189369467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete SP register change point.  <a href="frame_8hpp.html#ac68a1de58fbd9e15b5a46d0189369467">More...</a><br /></td></tr>
<tr class="separator:ac68a1de58fbd9e15b5a46d0189369467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be01e2fa6c64579f40540d42c6d598e"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a5be01e2fa6c64579f40540d42c6d598e">get_spd</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="memdesc:a5be01e2fa6c64579f40540d42c6d598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get difference between the initial and current values of ESP.  <a href="frame_8hpp.html#a5be01e2fa6c64579f40540d42c6d598e">More...</a><br /></td></tr>
<tr class="separator:a5be01e2fa6c64579f40540d42c6d598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cbc5afee0af39cfbca5de4c9d62dfb"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a32cbc5afee0af39cfbca5de4c9d62dfb">get_effective_spd</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="memdesc:a32cbc5afee0af39cfbca5de4c9d62dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get effective difference between the initial and current values of ESP.  <a href="frame_8hpp.html#a32cbc5afee0af39cfbca5de4c9d62dfb">More...</a><br /></td></tr>
<tr class="separator:a32cbc5afee0af39cfbca5de4c9d62dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5928077ab43a648f05af0d7dd168a6c7"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#a5928077ab43a648f05af0d7dd168a6c7">get_sp_delta</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, ea_t ea)</td></tr>
<tr class="memdesc:a5928077ab43a648f05af0d7dd168a6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get modification of SP made at the specified location.  <a href="frame_8hpp.html#a5928077ab43a648f05af0d7dd168a6c7">More...</a><br /></td></tr>
<tr class="separator:a5928077ab43a648f05af0d7dd168a6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae937235a31f9216d185337a3425551eb"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#ae937235a31f9216d185337a3425551eb">recalc_spd</a> (ea_t cur_ea)</td></tr>
<tr class="memdesc:ae937235a31f9216d185337a3425551eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate SP delta for an instruction that stops execution.  <a href="frame_8hpp.html#ae937235a31f9216d185337a3425551eb">More...</a><br /></td></tr>
<tr class="separator:ae937235a31f9216d185337a3425551eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeba4d56367ba26fb9a04923cfc89bb6"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8hpp.html#aaeba4d56367ba26fb9a04923cfc89bb6">build_stkvar_xrefs</a> (<a class="el" href="frame_8hpp.html#a88d80d5d38b062a7743afc80d32e8a2c">xreflist_t</a> *out, <a class="el" href="classfunc__t.html">func_t</a> *pfn, const <a class="el" href="classmember__t.html">member_t</a> *mptr)</td></tr>
<tr class="memdesc:aaeba4d56367ba26fb9a04923cfc89bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill 'out' with a list of all the xrefs made from function 'pfn', to the argument or variable 'mptr' in 'pfn's stack frame.  <a href="frame_8hpp.html#aaeba4d56367ba26fb9a04923cfc89bb6">More...</a><br /></td></tr>
<tr class="separator:aaeba4d56367ba26fb9a04923cfc89bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Routines to manipulate function stack frames, stack variables, register variables and local labels. </p>
<p >The frame is represented as a structure: </p><pre>
  +------------------------------------------------+
  | function arguments                             |
  +------------------------------------------------+
  | return address (isn't stored in <a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics.">func_t</a>)        |
  +------------------------------------------------+
  | saved registers (SI, DI, etc - <a class="el" href="classfunc__t.html#aaae89da99feeba7a2d3440d8582d85be" title="size of saved registers in frame.">func_t::frregs</a>) |
  +------------------------------------------------+ &lt;- typical BP
  |                                                |  |
  |                                                |  | <a class="el" href="classfunc__t.html#a676f92e8f23adfdb5f5bc5be5a3345c4" title="frame pointer delta.">func_t::fpd</a>
  |                                                |  |
  |                                                | &lt;- real BP
  | local variables (<a class="el" href="classfunc__t.html#af7831991ec87f4696d51599ef59b97fc" title="size of local variables part of frame in bytes.">func_t::frsize</a>)               |
  |                                                |
  |                                                |
  +------------------------------------------------+ &lt;- SP
</pre><p >To access the structure of a function frame, use:</p><ul>
<li><a class="el" href="struct_8hpp.html#ac83f120345806e9bda5412bcdb1a6389" title="Get pointer to struct type info.">get_struc()</a> (use <a class="el" href="classfunc__t.html#a38a4fc253b5d88c343d973dbd2032dbe" title="netnode id of frame structure - see frame.hpp">func_t::frame</a> as structure ID)</li>
<li><a class="el" href="frame_8hpp.html#aa25883d7ab5d18e89bd843c75320e987" title="Get pointer to function frame.">get_frame(const func_t *pfn)</a></li>
<li><a class="el" href="frame_8hpp.html#a70bc6a5c4f8ff04c4c92f672198c33cd" title="Get pointer to function frame.">get_frame(ea_t ea)</a> </li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="adea83308bbe3028f66bde2b06d3931e1" name="adea83308bbe3028f66bde2b06d3931e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea83308bbe3028f66bde2b06d3931e1">&#9670;&nbsp;</a></span>STKVAR_VALID_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STKVAR_VALID_SIZE&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>x.dtyp contains correct variable type (for insns like 'lea' this bit must be off). </p>
<p >In general, dr_O references do not allow to determine the variable size </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a248f3def030aba4ba4b0ac2fec67a472" name="a248f3def030aba4ba4b0ac2fec67a472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248f3def030aba4ba4b0ac2fec67a472">&#9670;&nbsp;</a></span>add_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td>
          <td class="paramname"><em>frsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>&#160;</td>
          <td class="paramname"><em>frregs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>argsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add function frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function structure </td></tr>
    <tr><td class="paramname">frsize</td><td>size of function local variables </td></tr>
    <tr><td class="paramname">frregs</td><td>size of saved registers </td></tr>
    <tr><td class="paramname">argsize</td><td>size of function arguments range which will be purged upon return. this parameter is used for __stdcall and __pascal calling conventions. for other calling conventions please pass 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed (no function, frame already exists) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f27311ac95915332fec813bc65f3dc6" name="a8f27311ac95915332fec813bc65f3dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f27311ac95915332fec813bc65f3dc6">&#9670;&nbsp;</a></span>del_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export del_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a function frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a713c7440f3458dfe4318bd1e92743f2e" name="a713c7440f3458dfe4318bd1e92743f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713c7440f3458dfe4318bd1e92743f2e">&#9670;&nbsp;</a></span>set_frame_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_frame_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>frsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>&#160;</td>
          <td class="paramname"><em>frregs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>argsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size of function frame. </p>
<p >Note: The returned size may not include all stack arguments. It does so only for __stdcall and __fastcall calling conventions. To get the entire frame size for all cases use get_struc_size(get_frame(pfn)). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function structure </td></tr>
    <tr><td class="paramname">frsize</td><td>size of function local variables </td></tr>
    <tr><td class="paramname">frregs</td><td>size of saved registers </td></tr>
    <tr><td class="paramname">argsize</td><td>size of function arguments that will be purged from the stack upon return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a06cd09a14b5832965ad746d5e605ef87" name="a06cd09a14b5832965ad746d5e605ef87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cd09a14b5832965ad746d5e605ef87">&#9670;&nbsp;</a></span>get_frame_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman asize_t ida_export get_frame_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get full size of a function frame. </p>
<p >This function takes into account size of local variables + size of saved registers + size of return address + number of purged bytes. The purged bytes correspond to the arguments of the functions with __stdcall and __fastcall calling conventions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function structure, may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of frame in bytes or zero </dd></dl>

</div>
</div>
<a id="a1f585fc61fb88ad3ee8b90b2d0993a2e" name="a1f585fc61fb88ad3ee8b90b2d0993a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f585fc61fb88ad3ee8b90b2d0993a2e">&#9670;&nbsp;</a></span>get_frame_retsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_frame_retsize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of function return address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function structure, can't be nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a227ca109bc1fdf781d018c037901eeec" name="a227ca109bc1fdf781d018c037901eeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227ca109bc1fdf781d018c037901eeec">&#9670;&nbsp;</a></span>get_frame_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export get_frame_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrange__t.html">range_t</a> *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="frame_8hpp.html#a7277e4b0fbb084261a7e828ec29c88e7">frame_part_t</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get offsets of the frame part in the frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>pointer to the output buffer with the frame part start/end(exclusive) offsets, can't be nullptr </td></tr>
    <tr><td class="paramname">pfn</td><td>pointer to function structure, can't be nullptr </td></tr>
    <tr><td class="paramname">part</td><td>frame part </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa25883d7ab5d18e89bd843c75320e987" name="aa25883d7ab5d18e89bd843c75320e987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25883d7ab5d18e89bd843c75320e987">&#9670;&nbsp;</a></span>get_frame() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classstruc__t.html">struc_t</a> *ida_export get_frame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to function frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70bc6a5c4f8ff04c4c92f672198c33cd" name="a70bc6a5c4f8ff04c4c92f672198c33cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bc6a5c4f8ff04c4c92f672198c33cd">&#9670;&nbsp;</a></span>get_frame() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstruc__t.html">struc_t</a> * get_frame </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to function frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address in the function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c8cad41bcd22c5739e4477168974120" name="a7c8cad41bcd22c5739e4477168974120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8cad41bcd22c5739e4477168974120">&#9670;&nbsp;</a></span>soff_to_fpoff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> soff_to_fpoff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td>
          <td class="paramname"><em>soff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert struct offsets into fp-relative offsets. </p>
<p >This function converts the offsets inside the <a class="el" href="classstruc__t.html" title="Information about a structure type (assembly level)">struc_t</a> object into the frame pointer offsets (for example, EBP-relative). </p>

</div>
</div>
<a id="a8284122ba3ea987a183ead63859b4902" name="a8284122ba3ea987a183ead63859b4902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8284122ba3ea987a183ead63859b4902">&#9670;&nbsp;</a></span>update_fpd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export update_fpd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>fpd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update frame pointer delta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function structure </td></tr>
    <tr><td class="paramname">fpd</td><td>new fpd value. cannot be bigger than the local variable range size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a7d7b4155b3c9bb4143f43a1905f62e26" name="a7d7b4155b3c9bb4143f43a1905f62e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7b4155b3c9bb4143f43a1905f62e26">&#9670;&nbsp;</a></span>set_purged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_purged </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>override_old_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of purged bytes for a function or data item (funcptr). </p>
<p >This function will update the database and plan to reanalyze items referencing the specified address. It works only for processors with <a class="el" href="idp_8hpp.html#a5fbd4b03256088198824f6d375caeb54" title="there are calling conventions which may purge bytes from the stack">PR_PURGING</a> bit in 16 and 32 bit modes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>address of the function of item </td></tr>
    <tr><td class="paramname">nbytes</td><td>number of purged bytes </td></tr>
    <tr><td class="paramname">override_old_value</td><td>may overwrite old information about purged bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a50781e1dc737efc6b1db5552fe0be9f7" name="a50781e1dc737efc6b1db5552fe0be9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50781e1dc737efc6b1db5552fe0be9f7">&#9670;&nbsp;</a></span>get_func_by_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_func_by_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a>&#160;</td>
          <td class="paramname"><em>frame_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get function by its frame id. </p>
<dl class="section warning"><dt>Warning</dt><dd>this function works only with databases created by IDA &gt; 5.6 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame_id</td><td>id of the function frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>start address of the function or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> </dd></dl>

</div>
</div>
<a id="a883390acc0ac0805b5d9182602d8c605" name="a883390acc0ac0805b5d9182602d8c605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883390acc0ac0805b5d9182602d8c605">&#9670;&nbsp;</a></span>get_stkvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classmember__t.html">member_t</a> *ida_export get_stkvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> *&#160;</td>
          <td class="paramname"><em>actval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinsn__t.html">insn_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classop__t.html">op_t</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to stack variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actval</td><td>actual value used to fetch stack variable this pointer may point to 'v' </td></tr>
    <tr><td class="paramname">insn</td><td>the instruction </td></tr>
    <tr><td class="paramname">x</td><td>reference to instruction operand </td></tr>
    <tr><td class="paramname">v</td><td>immediate value in the operand (usually x.addr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr or ptr to stack variable </dd></dl>

</div>
</div>
<a id="a6ecc3558ed60be999ec7b3e7d682dad3" name="a6ecc3558ed60be999ec7b3e7d682dad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecc3558ed60be999ec7b3e7d682dad3">&#9670;&nbsp;</a></span>add_stkvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_stkvar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classinsn__t.html">insn_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classop__t.html">op_t</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically add stack variable if doesn't exist. </p>
<p >Processor modules should use <a class="el" href="classinsn__t.html#abaeb6683f9b328932887c458550edd50" title="Create or modify a stack variable in the function frame.">insn_t::create_stkvar()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn</td><td>the instruction </td></tr>
    <tr><td class="paramname">x</td><td>reference to instruction operand </td></tr>
    <tr><td class="paramname">v</td><td>immediate value in the operand (usually x.addr) </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_t_k_v_a_r__1.html">Add stkvar flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ab4bbf7162a2d71aa96f747762d3f3040" name="ab4bbf7162a2d71aa96f747762d3f3040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bbf7162a2d71aa96f747762d3f3040">&#9670;&nbsp;</a></span>define_stkvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export define_stkvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionopinfo__t.html">opinfo_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">asize_t&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define/redefine a stack variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function </td></tr>
    <tr><td class="paramname">name</td><td>variable name, nullptr means autogenerate a name </td></tr>
    <tr><td class="paramname">off</td><td>offset of the stack variable in the frame. negative values denote local variables, positive - function arguments. </td></tr>
    <tr><td class="paramname">flags</td><td>variable type flags (<a class="el" href="bytes_8hpp.html#a6376a30aecda71f92475c02eeeee99ae" title="Get a flags64_t representing a byte.">byte_flag()</a> for a byte variable, for example) </td></tr>
    <tr><td class="paramname">ti</td><td>additional type information (like offsets, structs, etc) </td></tr>
    <tr><td class="paramname">nbytes</td><td>number of bytes occupied by the variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="aeb089d29a4ea64752af90dc32a4baf2c" name="aeb089d29a4ea64752af90dc32a4baf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb089d29a4ea64752af90dc32a4baf2c">&#9670;&nbsp;</a></span>build_stkvar_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export build_stkvar_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build automatic stack variable name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>pointer to buffer </td></tr>
    <tr><td class="paramname">pfn</td><td>pointer to function (can't be nullptr!) </td></tr>
    <tr><td class="paramname">v</td><td>value of variable offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of stack variable name or -1 </dd></dl>

</div>
</div>
<a id="af3161147e2b4325883c73c86034d71ba" name="af3161147e2b4325883c73c86034d71ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3161147e2b4325883c73c86034d71ba">&#9670;&nbsp;</a></span>calc_stkvar_struc_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export calc_stkvar_struc_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classinsn__t.html">insn_t</a> &amp;&#160;</td>
          <td class="paramname"><em>insn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate offset of stack variable in the frame structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function (can't be nullptr!) </td></tr>
    <tr><td class="paramname">insn</td><td>the instruction </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number -1 if error, return <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if some error (issue a warning if stack frame is bad) </dd></dl>

</div>
</div>
<a id="aacaa7150097393bae7091d317ad8ac79" name="aacaa7150097393bae7091d317ad8ac79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaa7150097393bae7091d317ad8ac79">&#9670;&nbsp;</a></span>delete_wrong_frame_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export delete_wrong_frame_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool idaapi &#160;</td>
          <td class="paramname"><em>should_reanalyze</em>const insn_t &amp;insn&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and delete wrong frame info. </p>
<p >Namely, we delete:</p><ul>
<li>unreferenced stack variable definitions</li>
<li>references to dead stack variables (i.e. operands displayed in red) these operands will be untyped and most likely displayed in hex. We also plan to reanalyze instruction with the stack frame references <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to the function </td></tr>
    <tr><td class="paramname">should_reanalyze</td><td>callback to determine which instructions to reanalyze </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of deleted definitions </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a5f77d2c231f8faeb5939be2bc8e2a298" name="a5f77d2c231f8faeb5939be2bc8e2a298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f77d2c231f8faeb5939be2bc8e2a298">&#9670;&nbsp;</a></span>add_regvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export add_regvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>canon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a register variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>function in which the definition will be created </td></tr>
    <tr><td class="paramname">ea1,ea2</td><td>range of addresses within the function where the definition will be used </td></tr>
    <tr><td class="paramname">canon</td><td>name of a general register </td></tr>
    <tr><td class="paramname">user</td><td>user-defined name for the register </td></tr>
    <tr><td class="paramname">cmt</td><td>comment for the definition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___r_e_g_v_a_r___e_r_r_o_r__.html">Register variable error codes</a> </dd></dl>

</div>
</div>
<a id="a85af8e7f76b191d51fd3aeb95104dee7" name="a85af8e7f76b191d51fd3aeb95104dee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85af8e7f76b191d51fd3aeb95104dee7">&#9670;&nbsp;</a></span>find_regvar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="structregvar__t.html">regvar_t</a> *ida_export find_regvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>canon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a register variable definition (powerful version). </p>
<p >One of 'canon' and 'user' should be nullptr. If both 'canon' and 'user' are nullptr it returns the first regvar definition in the range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>function in question </td></tr>
    <tr><td class="paramname">ea1,ea2</td><td>range of addresses to search. ea1==BADADDR means the entire function </td></tr>
    <tr><td class="paramname">canon</td><td>name of a general register </td></tr>
    <tr><td class="paramname">user</td><td>user-defined name for the register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr-not found, otherwise ptr to <a class="el" href="structregvar__t.html" title="A register variable allows the user to rename a general processor register to a meaningful name.">regvar_t</a> </dd></dl>

</div>
</div>
<a id="ada160cc32177f5d1f81fea165385ee90" name="ada160cc32177f5d1f81fea165385ee90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada160cc32177f5d1f81fea165385ee90">&#9670;&nbsp;</a></span>find_regvar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregvar__t.html">regvar_t</a> * find_regvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>canon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a register variable definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>function in question </td></tr>
    <tr><td class="paramname">ea</td><td>current address </td></tr>
    <tr><td class="paramname">canon</td><td>name of a general register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr-not found, otherwise ptr to <a class="el" href="structregvar__t.html" title="A register variable allows the user to rename a general processor register to a meaningful name.">regvar_t</a> </dd></dl>

</div>
</div>
<a id="ae2fec00b4effdb288f0aef24e7f6381a" name="ae2fec00b4effdb288f0aef24e7f6381a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fec00b4effdb288f0aef24e7f6381a">&#9670;&nbsp;</a></span>has_regvar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool has_regvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is there a register variable definition? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>function in question </td></tr>
    <tr><td class="paramname">ea</td><td>current address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28f5e5e05bd45253e8e546e8d7048e44" name="a28f5e5e05bd45253e8e546e8d7048e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f5e5e05bd45253e8e546e8d7048e44">&#9670;&nbsp;</a></span>rename_regvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export rename_regvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structregvar__t.html">regvar_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a register variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>function in question </td></tr>
    <tr><td class="paramname">v</td><td>variable to rename </td></tr>
    <tr><td class="paramname">user</td><td>new user-defined name for the register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___r_e_g_v_a_r___e_r_r_o_r__.html">Register variable error codes</a> </dd></dl>

</div>
</div>
<a id="a864c220a61416541dcbc6b0d35353b5d" name="a864c220a61416541dcbc6b0d35353b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864c220a61416541dcbc6b0d35353b5d">&#9670;&nbsp;</a></span>set_regvar_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export set_regvar_cmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structregvar__t.html">regvar_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set comment for a register variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>function in question </td></tr>
    <tr><td class="paramname">v</td><td>variable to rename </td></tr>
    <tr><td class="paramname">cmt</td><td>new comment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___r_e_g_v_a_r___e_r_r_o_r__.html">Register variable error codes</a> </dd></dl>

</div>
</div>
<a id="ae28b200b6ffb1dfe1dad1683ac87d112" name="ae28b200b6ffb1dfe1dad1683ac87d112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28b200b6ffb1dfe1dad1683ac87d112">&#9670;&nbsp;</a></span>del_regvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export del_regvar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>canon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a register variable definition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>function in question </td></tr>
    <tr><td class="paramname">ea1,ea2</td><td>range of addresses within the function where the definition holds </td></tr>
    <tr><td class="paramname">canon</td><td>name of a general register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___r_e_g_v_a_r___e_r_r_o_r__.html">Register variable error codes</a> </dd></dl>

</div>
</div>
<a id="a245da2e9f6e1f65ca306d0bab0db5368" name="a245da2e9f6e1f65ca306d0bab0db5368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245da2e9f6e1f65ca306d0bab0db5368">&#9670;&nbsp;</a></span>add_auto_stkpnt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_auto_stkpnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add automatic SP register change point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function. may be nullptr. </td></tr>
    <tr><td class="paramname">ea</td><td>linear address where SP changes. usually this is the end of the instruction which modifies the stack pointer ( <a class="el" href="classinsn__t.html#a68b331560b7f026c120373ca574c2889" title="Linear address of the instruction.">insn_t::ea</a>+ <a class="el" href="classinsn__t.html#ac3c2b72b27e268eeb2d55bdcbcdbd2b9" title="Size of instruction in bytes.">insn_t::size</a>) </td></tr>
    <tr><td class="paramname">delta</td><td>difference between old and new values of SP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ab13680589c0aea771a34d1fd0d63c37f" name="ab13680589c0aea771a34d1fd0d63c37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13680589c0aea771a34d1fd0d63c37f">&#9670;&nbsp;</a></span>add_user_stkpnt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_user_stkpnt </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a>&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add user-defined SP register change point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address where SP changes </td></tr>
    <tr><td class="paramname">delta</td><td>difference between old and new values of SP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ac68a1de58fbd9e15b5a46d0189369467" name="ac68a1de58fbd9e15b5a46d0189369467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68a1de58fbd9e15b5a46d0189369467">&#9670;&nbsp;</a></span>del_stkpnt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export del_stkpnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete SP register change point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function. may be nullptr. </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a5be01e2fa6c64579f40540d42c6d598e" name="a5be01e2fa6c64579f40540d42c6d598e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be01e2fa6c64579f40540d42c6d598e">&#9670;&nbsp;</a></span>get_spd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> ida_export get_spd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get difference between the initial and current values of ESP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function. may be nullptr. </td></tr>
    <tr><td class="paramname">ea</td><td>linear address of an instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or the difference, usually a negative number. returns the sp-diff before executing the instruction. </dd></dl>

</div>
</div>
<a id="a32cbc5afee0af39cfbca5de4c9d62dfb" name="a32cbc5afee0af39cfbca5de4c9d62dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cbc5afee0af39cfbca5de4c9d62dfb">&#9670;&nbsp;</a></span>get_effective_spd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> ida_export get_effective_spd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get effective difference between the initial and current values of ESP. </p>
<p >This function returns the sp-diff used by the instruction. The difference between <a class="el" href="frame_8hpp.html#a5be01e2fa6c64579f40540d42c6d598e" title="Get difference between the initial and current values of ESP.">get_spd()</a> and <a class="el" href="frame_8hpp.html#a32cbc5afee0af39cfbca5de4c9d62dfb" title="Get effective difference between the initial and current values of ESP.">get_effective_spd()</a> is present only for instructions like "pop [esp+N]": they modify sp and use the modified value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function. may be nullptr. </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or the difference, usually a negative number </dd></dl>

</div>
</div>
<a id="a5928077ab43a648f05af0d7dd168a6c7" name="a5928077ab43a648f05af0d7dd168a6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5928077ab43a648f05af0d7dd168a6c7">&#9670;&nbsp;</a></span>get_sp_delta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> ida_export get_sp_delta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get modification of SP made at the specified location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function. may be nullptr. </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the specified location doesn't contain a SP change point. otherwise return delta of SP modification. </dd></dl>

</div>
</div>
<a id="ae937235a31f9216d185337a3425551eb" name="ae937235a31f9216d185337a3425551eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae937235a31f9216d185337a3425551eb">&#9670;&nbsp;</a></span>recalc_spd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export recalc_spd </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>cur_ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate SP delta for an instruction that stops execution. </p>
<p >The next instruction is not reached from the current instruction. We need to recalculate SP for the next instruction.</p>
<p >This function will create a new automatic SP register change point if necessary. It should be called from the emulator (emu.cpp) when auto_state == <a class="el" href="auto_8hpp.html#a26484b0dda0e7740b5db01459e9da421" title="6: reanalyze">AU_USED</a> if the current instruction doesn't pass the execution flow to the next instruction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cur_ea</td><td>linear address of the current instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>new stkpnt is added </td></tr>
    <tr><td class="paramname">0</td><td>nothing is changed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeba4d56367ba26fb9a04923cfc89bb6" name="aaeba4d56367ba26fb9a04923cfc89bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeba4d56367ba26fb9a04923cfc89bb6">&#9670;&nbsp;</a></span>build_stkvar_xrefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export build_stkvar_xrefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="frame_8hpp.html#a88d80d5d38b062a7743afc80d32e8a2c">xreflist_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmember__t.html">member_t</a> *&#160;</td>
          <td class="paramname"><em>mptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill 'out' with a list of all the xrefs made from function 'pfn', to the argument or variable 'mptr' in 'pfn's stack frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the list of xrefs to fill. </td></tr>
    <tr><td class="paramname">pfn</td><td>the function to scan. </td></tr>
    <tr><td class="paramname">mptr</td><td>the argument/variable in pfn's stack frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
