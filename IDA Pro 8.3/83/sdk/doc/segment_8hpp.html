<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: segment.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">segment.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions that deal with segments.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsegment__t.html">segment_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a program segment.  <a href="classsegment__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlock__segment.html">lock_segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to lock a segment pointer so it stays valid.  <a href="classlock__segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2cc79101b0a36f26dae427dec04047e7"><td class="memItemLeft" align="right" valign="top"><a id="a2cc79101b0a36f26dae427dec04047e7" name="a2cc79101b0a36f26dae427dec04047e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SREG_NUM</b>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a2cc79101b0a36f26dae427dec04047e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of segment registers is 16 (see <a class="el" href="segregs_8hpp.html" title="Functions that deal with the segment registers.">segregs.hpp</a>) <br /></td></tr>
<tr class="separator:a2cc79101b0a36f26dae427dec04047e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4697d125cb311ad2487ddd63683bb9bd"><td class="memItemLeft" align="right" valign="top"><a id="a4697d125cb311ad2487ddd63683bb9bd" name="a4697d125cb311ad2487ddd63683bb9bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saAbs</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a4697d125cb311ad2487ddd63683bb9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute segment. <br /></td></tr>
<tr class="separator:a4697d125cb311ad2487ddd63683bb9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aecfd12e64028f0712d6cad0403b66b"><td class="memItemLeft" align="right" valign="top"><a id="a0aecfd12e64028f0712d6cad0403b66b" name="a0aecfd12e64028f0712d6cad0403b66b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRelByte</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a0aecfd12e64028f0712d6cad0403b66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocatable, byte aligned. <br /></td></tr>
<tr class="separator:a0aecfd12e64028f0712d6cad0403b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec2f7b0d3cc73c432b3cd515630edce"><td class="memItemLeft" align="right" valign="top"><a id="adec2f7b0d3cc73c432b3cd515630edce" name="adec2f7b0d3cc73c432b3cd515630edce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRelWord</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:adec2f7b0d3cc73c432b3cd515630edce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocatable, word (2-byte) aligned. <br /></td></tr>
<tr class="separator:adec2f7b0d3cc73c432b3cd515630edce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034b61cd4186cc800c9cccbf4ca579fc"><td class="memItemLeft" align="right" valign="top"><a id="a034b61cd4186cc800c9cccbf4ca579fc" name="a034b61cd4186cc800c9cccbf4ca579fc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRelPara</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a034b61cd4186cc800c9cccbf4ca579fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocatable, paragraph (16-byte) aligned. <br /></td></tr>
<tr class="separator:a034b61cd4186cc800c9cccbf4ca579fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d051b1877d03b0b447cdf9ba36fb53d"><td class="memItemLeft" align="right" valign="top"><a id="a1d051b1877d03b0b447cdf9ba36fb53d" name="a1d051b1877d03b0b447cdf9ba36fb53d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRelPage</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a1d051b1877d03b0b447cdf9ba36fb53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocatable, aligned on 256-byte boundary. <br /></td></tr>
<tr class="separator:a1d051b1877d03b0b447cdf9ba36fb53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7775baddfc01bf6179be9983462f10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aff7775baddfc01bf6179be9983462f10">saRelDble</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:aff7775baddfc01bf6179be9983462f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocatable, aligned on a double word (4-byte) boundary.  <a href="segment_8hpp.html#aff7775baddfc01bf6179be9983462f10">More...</a><br /></td></tr>
<tr class="separator:aff7775baddfc01bf6179be9983462f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c3364a1877c3a87d83e40322ba14f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a765c3364a1877c3a87d83e40322ba14f">saRel4K</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a765c3364a1877c3a87d83e40322ba14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is used by the PharLap OMF for page (4K) alignment.  <a href="segment_8hpp.html#a765c3364a1877c3a87d83e40322ba14f">More...</a><br /></td></tr>
<tr class="separator:a765c3364a1877c3a87d83e40322ba14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d02d37653e067648515434ef024b7e"><td class="memItemLeft" align="right" valign="top"><a id="a98d02d37653e067648515434ef024b7e" name="a98d02d37653e067648515434ef024b7e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saGroup</b>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a98d02d37653e067648515434ef024b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment group. <br /></td></tr>
<tr class="separator:a98d02d37653e067648515434ef024b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffa6a6277b95550e88745d2b0756613"><td class="memItemLeft" align="right" valign="top"><a id="a6ffa6a6277b95550e88745d2b0756613" name="a6ffa6a6277b95550e88745d2b0756613"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRel32Bytes</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a6ffa6a6277b95550e88745d2b0756613"><td class="mdescLeft">&#160;</td><td class="mdescRight">32 bytes <br /></td></tr>
<tr class="separator:a6ffa6a6277b95550e88745d2b0756613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6663af84554de00ae36835ef061e5614"><td class="memItemLeft" align="right" valign="top"><a id="a6663af84554de00ae36835ef061e5614" name="a6663af84554de00ae36835ef061e5614"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRel64Bytes</b>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a6663af84554de00ae36835ef061e5614"><td class="mdescLeft">&#160;</td><td class="mdescRight">64 bytes <br /></td></tr>
<tr class="separator:a6663af84554de00ae36835ef061e5614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e590d43f0a17bff91318c070406c46"><td class="memItemLeft" align="right" valign="top"><a id="a44e590d43f0a17bff91318c070406c46" name="a44e590d43f0a17bff91318c070406c46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRelQword</b>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a44e590d43f0a17bff91318c070406c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">8 bytes <br /></td></tr>
<tr class="separator:a44e590d43f0a17bff91318c070406c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9328a9b21edfc4da676d29b2ce255b7e"><td class="memItemLeft" align="right" valign="top"><a id="a9328a9b21edfc4da676d29b2ce255b7e" name="a9328a9b21edfc4da676d29b2ce255b7e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRel128Bytes</b>&#160;&#160;&#160;11</td></tr>
<tr class="memdesc:a9328a9b21edfc4da676d29b2ce255b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">128 bytes <br /></td></tr>
<tr class="separator:a9328a9b21edfc4da676d29b2ce255b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae415d0f706c767f99234fe6c8d970d2b"><td class="memItemLeft" align="right" valign="top"><a id="ae415d0f706c767f99234fe6c8d970d2b" name="ae415d0f706c767f99234fe6c8d970d2b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRel512Bytes</b>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:ae415d0f706c767f99234fe6c8d970d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">512 bytes <br /></td></tr>
<tr class="separator:ae415d0f706c767f99234fe6c8d970d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5213ae8be94b40698c7c375c1f16c4"><td class="memItemLeft" align="right" valign="top"><a id="a4d5213ae8be94b40698c7c375c1f16c4" name="a4d5213ae8be94b40698c7c375c1f16c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRel1024Bytes</b>&#160;&#160;&#160;13</td></tr>
<tr class="memdesc:a4d5213ae8be94b40698c7c375c1f16c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">1024 bytes <br /></td></tr>
<tr class="separator:a4d5213ae8be94b40698c7c375c1f16c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bcf5d7907785f4fae15af499fd91b0"><td class="memItemLeft" align="right" valign="top"><a id="ab3bcf5d7907785f4fae15af499fd91b0" name="ab3bcf5d7907785f4fae15af499fd91b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRel2048Bytes</b>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:ab3bcf5d7907785f4fae15af499fd91b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">2048 bytes <br /></td></tr>
<tr class="separator:ab3bcf5d7907785f4fae15af499fd91b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40112e1c1deceb7107a877e6b5eddf9f"><td class="memItemLeft" align="right" valign="top"><a id="a40112e1c1deceb7107a877e6b5eddf9f" name="a40112e1c1deceb7107a877e6b5eddf9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>saRel_MAX_ALIGN_CODE</b>&#160;&#160;&#160;<a class="el" href="segment_8hpp.html#ab3bcf5d7907785f4fae15af499fd91b0">saRel2048Bytes</a></td></tr>
<tr class="separator:a40112e1c1deceb7107a877e6b5eddf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ed1a87ad2b2dd47313a29e07811dc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a38ed1a87ad2b2dd47313a29e07811dc4">scPriv</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a38ed1a87ad2b2dd47313a29e07811dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private.  <a href="segment_8hpp.html#a38ed1a87ad2b2dd47313a29e07811dc4">More...</a><br /></td></tr>
<tr class="separator:a38ed1a87ad2b2dd47313a29e07811dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018cbd3b983fd7b03dccaf9817397b8c"><td class="memItemLeft" align="right" valign="top"><a id="a018cbd3b983fd7b03dccaf9817397b8c" name="a018cbd3b983fd7b03dccaf9817397b8c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>scGroup</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a018cbd3b983fd7b03dccaf9817397b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment group. <br /></td></tr>
<tr class="separator:a018cbd3b983fd7b03dccaf9817397b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4d1acba99d1b265076d884ba2ec250"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aca4d1acba99d1b265076d884ba2ec250">scPub</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:aca4d1acba99d1b265076d884ba2ec250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public.  <a href="segment_8hpp.html#aca4d1acba99d1b265076d884ba2ec250">More...</a><br /></td></tr>
<tr class="separator:aca4d1acba99d1b265076d884ba2ec250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79af580de4cec4a9b836c070cba9de2"><td class="memItemLeft" align="right" valign="top"><a id="ab79af580de4cec4a9b836c070cba9de2" name="ab79af580de4cec4a9b836c070cba9de2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>scPub2</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ab79af580de4cec4a9b836c070cba9de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">As defined by Microsoft, same as C=2 (public). <br /></td></tr>
<tr class="separator:ab79af580de4cec4a9b836c070cba9de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee8fe69cf688dc99b8baa848e3bec54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aeee8fe69cf688dc99b8baa848e3bec54">scStack</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:aeee8fe69cf688dc99b8baa848e3bec54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack.  <a href="segment_8hpp.html#aeee8fe69cf688dc99b8baa848e3bec54">More...</a><br /></td></tr>
<tr class="separator:aeee8fe69cf688dc99b8baa848e3bec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433bb6d9f37f3cfb6139534aedfac6e6"><td class="memItemLeft" align="right" valign="top"><a id="a433bb6d9f37f3cfb6139534aedfac6e6" name="a433bb6d9f37f3cfb6139534aedfac6e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>scCommon</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a433bb6d9f37f3cfb6139534aedfac6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common. Combine by overlay using maximum size. <br /></td></tr>
<tr class="separator:a433bb6d9f37f3cfb6139534aedfac6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823a88802af7bc72222190bbd5ff26e1"><td class="memItemLeft" align="right" valign="top"><a id="a823a88802af7bc72222190bbd5ff26e1" name="a823a88802af7bc72222190bbd5ff26e1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>scPub3</b>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a823a88802af7bc72222190bbd5ff26e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">As defined by Microsoft, same as C=2 (public). <br /></td></tr>
<tr class="separator:a823a88802af7bc72222190bbd5ff26e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627f8aa059efe19465b30eb56e2769d1"><td class="memItemLeft" align="right" valign="top"><a id="a627f8aa059efe19465b30eb56e2769d1" name="a627f8aa059efe19465b30eb56e2769d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>sc_MAX_COMB_CODE</b>&#160;&#160;&#160;<a class="el" href="segment_8hpp.html#a823a88802af7bc72222190bbd5ff26e1">scPub3</a></td></tr>
<tr class="separator:a627f8aa059efe19465b30eb56e2769d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f99c160c8494f887194ac29968ae6d"><td class="memItemLeft" align="right" valign="top"><a id="ac1f99c160c8494f887194ac29968ae6d" name="ac1f99c160c8494f887194ac29968ae6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGPERM_EXEC</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ac1f99c160c8494f887194ac29968ae6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute. <br /></td></tr>
<tr class="separator:ac1f99c160c8494f887194ac29968ae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf28b814d1aa6a9aac4ec6bf170bc6ff"><td class="memItemLeft" align="right" valign="top"><a id="acf28b814d1aa6a9aac4ec6bf170bc6ff" name="acf28b814d1aa6a9aac4ec6bf170bc6ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGPERM_WRITE</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:acf28b814d1aa6a9aac4ec6bf170bc6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write. <br /></td></tr>
<tr class="separator:acf28b814d1aa6a9aac4ec6bf170bc6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b490152c7fc5f7ff4a9183a8c917e6a"><td class="memItemLeft" align="right" valign="top"><a id="a4b490152c7fc5f7ff4a9183a8c917e6a" name="a4b490152c7fc5f7ff4a9183a8c917e6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGPERM_READ</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a4b490152c7fc5f7ff4a9183a8c917e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read. <br /></td></tr>
<tr class="separator:a4b490152c7fc5f7ff4a9183a8c917e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc6d67d0a3d758fc7b0b34d83429bf9"><td class="memItemLeft" align="right" valign="top"><a id="a9dc6d67d0a3d758fc7b0b34d83429bf9" name="a9dc6d67d0a3d758fc7b0b34d83429bf9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGPERM_MAXVAL</b>&#160;&#160;&#160;(<a class="el" href="segment_8hpp.html#ac1f99c160c8494f887194ac29968ae6d">SEGPERM_EXEC</a> + <a class="el" href="segment_8hpp.html#acf28b814d1aa6a9aac4ec6bf170bc6ff">SEGPERM_WRITE</a> + <a class="el" href="segment_8hpp.html#a4b490152c7fc5f7ff4a9183a8c917e6a">SEGPERM_READ</a>)</td></tr>
<tr class="separator:a9dc6d67d0a3d758fc7b0b34d83429bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4007e0fda12fadafd3865883e928095b"><td class="memItemLeft" align="right" valign="top"><a id="a4007e0fda12fadafd3865883e928095b" name="a4007e0fda12fadafd3865883e928095b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_MAX_BITNESS_CODE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a4007e0fda12fadafd3865883e928095b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76758a64e75c56b04c528c84d3b70efe"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SFL_COMORG</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ga76758a64e75c56b04c528c84d3b70efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDP dependent field (IBM PC: if set, ORG directive is not commented out) <br /></td></tr>
<tr class="separator:ga76758a64e75c56b04c528c84d3b70efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dc2da752d9e80fad8caf501c5489d9"><td class="memItemLeft" align="right" valign="top"><a id="a94dc2da752d9e80fad8caf501c5489d9" name="a94dc2da752d9e80fad8caf501c5489d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDSEG_NOSREG</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a94dc2da752d9e80fad8caf501c5489d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set all default segment register values to <a class="el" href="pro_8h.html#a893ddf307fae0a3bbca667ee917cddc7" title="&#39;bad selector&#39; value">BADSEL</a> (undefine all default segment registers) <br /></td></tr>
<tr class="separator:a94dc2da752d9e80fad8caf501c5489d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2ab311485a9bc2b09d2a8f03a647a3"><td class="memItemLeft" align="right" valign="top"><a id="aef2ab311485a9bc2b09d2a8f03a647a3" name="aef2ab311485a9bc2b09d2a8f03a647a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDSEG_OR_DIE</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:aef2ab311485a9bc2b09d2a8f03a647a3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="pro_8h.html#a53e88c62090838e19cb5ee945d7ab8f7" title="Call qatexit functions, shut down UI and kernel, and exit.">qexit()</a> if can't add a segment <br /></td></tr>
<tr class="separator:aef2ab311485a9bc2b09d2a8f03a647a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6e405b6fb6faf18cc2c064ba592401"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a5d6e405b6fb6faf18cc2c064ba592401">ADDSEG_NOTRUNC</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a5d6e405b6fb6faf18cc2c064ba592401"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't truncate the new segment at the beginning of the next segment if they overlap.  <a href="segment_8hpp.html#a5d6e405b6fb6faf18cc2c064ba592401">More...</a><br /></td></tr>
<tr class="separator:a5d6e405b6fb6faf18cc2c064ba592401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee75ca1c810be184ef12055d637e5d2f"><td class="memItemLeft" align="right" valign="top"><a id="aee75ca1c810be184ef12055d637e5d2f" name="aee75ca1c810be184ef12055d637e5d2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDSEG_QUIET</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:aee75ca1c810be184ef12055d637e5d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">silent mode, no "Adding segment..." in the messages window <br /></td></tr>
<tr class="separator:aee75ca1c810be184ef12055d637e5d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1996026d4ee36dd29aeee83535c845d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#ad1996026d4ee36dd29aeee83535c845d">ADDSEG_FILLGAP</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:ad1996026d4ee36dd29aeee83535c845d"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill gap between new segment and previous one.  <a href="segment_8hpp.html#ad1996026d4ee36dd29aeee83535c845d">More...</a><br /></td></tr>
<tr class="separator:ad1996026d4ee36dd29aeee83535c845d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc4d5db47a493aca1f9a9d3725d7651"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aadc4d5db47a493aca1f9a9d3725d7651">ADDSEG_SPARSE</a>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:aadc4d5db47a493aca1f9a9d3725d7651"><td class="mdescLeft">&#160;</td><td class="mdescRight">use sparse storage method for the new ranges of the created segment.  <a href="segment_8hpp.html#aadc4d5db47a493aca1f9a9d3725d7651">More...</a><br /></td></tr>
<tr class="separator:aadc4d5db47a493aca1f9a9d3725d7651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa193b0b6eb2b21ea8b440de9fcad9e78"><td class="memItemLeft" align="right" valign="top"><a id="aa193b0b6eb2b21ea8b440de9fcad9e78" name="aa193b0b6eb2b21ea8b440de9fcad9e78"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDSEG_NOAA</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:aa193b0b6eb2b21ea8b440de9fcad9e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not mark new segment for auto-analysis <br /></td></tr>
<tr class="separator:aa193b0b6eb2b21ea8b440de9fcad9e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11530c497d1630b0f2aeae908b038d0c"><td class="memItemLeft" align="right" valign="top"><a id="a11530c497d1630b0f2aeae908b038d0c" name="a11530c497d1630b0f2aeae908b038d0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADDSEG_IDBENC</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:a11530c497d1630b0f2aeae908b038d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">'name' and 'sclass' are given in the IDB encoding; non-ASCII bytes will be decoded accordingly <br /></td></tr>
<tr class="separator:a11530c497d1630b0f2aeae908b038d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9305d855a66ea14f3efc11dbba83236a"><td class="memItemLeft" align="right" valign="top"><a id="a9305d855a66ea14f3efc11dbba83236a" name="a9305d855a66ea14f3efc11dbba83236a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGMOD_KILL</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a9305d855a66ea14f3efc11dbba83236a"><td class="mdescLeft">&#160;</td><td class="mdescRight">disable addresses if segment gets shrinked or deleted <br /></td></tr>
<tr class="separator:a9305d855a66ea14f3efc11dbba83236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c13b0da46d0f56b4a85158c48fe95eb"><td class="memItemLeft" align="right" valign="top"><a id="a8c13b0da46d0f56b4a85158c48fe95eb" name="a8c13b0da46d0f56b4a85158c48fe95eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGMOD_KEEP</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a8c13b0da46d0f56b4a85158c48fe95eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep information (code &amp; data, etc) <br /></td></tr>
<tr class="separator:a8c13b0da46d0f56b4a85158c48fe95eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6914d8e96834d9f75c3271addef56d"><td class="memItemLeft" align="right" valign="top"><a id="a3c6914d8e96834d9f75c3271addef56d" name="a3c6914d8e96834d9f75c3271addef56d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGMOD_SILENT</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a3c6914d8e96834d9f75c3271addef56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">be silent <br /></td></tr>
<tr class="separator:a3c6914d8e96834d9f75c3271addef56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1498b4080390eb46f9f905c4e67437a"><td class="memItemLeft" align="right" valign="top"><a id="ad1498b4080390eb46f9f905c4e67437a" name="ad1498b4080390eb46f9f905c4e67437a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGMOD_KEEP0</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:ad1498b4080390eb46f9f905c4e67437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for internal use, don't set <br /></td></tr>
<tr class="separator:ad1498b4080390eb46f9f905c4e67437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6657a780db914630b7a156aac2549d88"><td class="memItemLeft" align="right" valign="top"><a id="a6657a780db914630b7a156aac2549d88" name="a6657a780db914630b7a156aac2549d88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGMOD_KEEPSEL</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a6657a780db914630b7a156aac2549d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not try to delete unused selector <br /></td></tr>
<tr class="separator:a6657a780db914630b7a156aac2549d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d8f0e4d83b261bcc5de1600199230b"><td class="memItemLeft" align="right" valign="top"><a id="aa4d8f0e4d83b261bcc5de1600199230b" name="aa4d8f0e4d83b261bcc5de1600199230b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGMOD_NOMOVE</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:aa4d8f0e4d83b261bcc5de1600199230b"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't move info from the start of segment to the new start address (for <a class="el" href="segment_8hpp.html#affcd6c25a6d3bfc4bafeb786db81ec79" title="Set segment start address.">set_segm_start()</a>) <br /></td></tr>
<tr class="separator:aa4d8f0e4d83b261bcc5de1600199230b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182c0e6bd2cba7e46f360464ffe38276"><td class="memItemLeft" align="right" valign="top"><a id="a182c0e6bd2cba7e46f360464ffe38276" name="a182c0e6bd2cba7e46f360464ffe38276"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEGMOD_SPARSE</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a182c0e6bd2cba7e46f360464ffe38276"><td class="mdescLeft">&#160;</td><td class="mdescRight">use sparse storage if extending the segment (for <a class="el" href="segment_8hpp.html#affcd6c25a6d3bfc4bafeb786db81ec79" title="Set segment start address.">set_segm_start()</a>, <a class="el" href="segment_8hpp.html#aadde01303718a6cde673dca12ffac9d7" title="Set segment end address.">set_segm_end()</a>) <br /></td></tr>
<tr class="separator:a182c0e6bd2cba7e46f360464ffe38276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cba55c4f444b0a4c51653e1f5877aa"><td class="memItemLeft" align="right" valign="top"><a id="a74cba55c4f444b0a4c51653e1f5877aa" name="a74cba55c4f444b0a4c51653e1f5877aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MSF_SILENT</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a74cba55c4f444b0a4c51653e1f5877aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't display a "please wait" box on the screen <br /></td></tr>
<tr class="separator:a74cba55c4f444b0a4c51653e1f5877aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95498cd45f2b9b85103fcac3c9a1df32"><td class="memItemLeft" align="right" valign="top"><a id="a95498cd45f2b9b85103fcac3c9a1df32" name="a95498cd45f2b9b85103fcac3c9a1df32"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MSF_NOFIX</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a95498cd45f2b9b85103fcac3c9a1df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't call the loader to fix relocations <br /></td></tr>
<tr class="separator:a95498cd45f2b9b85103fcac3c9a1df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6375a028748826abee3c02826f37e8af"><td class="memItemLeft" align="right" valign="top"><a id="a6375a028748826abee3c02826f37e8af" name="a6375a028748826abee3c02826f37e8af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MSF_LDKEEP</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a6375a028748826abee3c02826f37e8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep the loader in the memory (optimization) <br /></td></tr>
<tr class="separator:a6375a028748826abee3c02826f37e8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89693134e1c29045c8c9a1b77f106813"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a89693134e1c29045c8c9a1b77f106813">MSF_FIXONCE</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a89693134e1c29045c8c9a1b77f106813"><td class="mdescLeft">&#160;</td><td class="mdescRight">call loader only once with the special calling method.  <a href="segment_8hpp.html#a89693134e1c29045c8c9a1b77f106813">More...</a><br /></td></tr>
<tr class="separator:a89693134e1c29045c8c9a1b77f106813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8b83720e61ef7c1cd29ea477ace306"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a2c8b83720e61ef7c1cd29ea477ace306">MSF_PRIORITY</a>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a2c8b83720e61ef7c1cd29ea477ace306"><td class="mdescLeft">&#160;</td><td class="mdescRight">loader segments will overwrite any existing debugger segments when moved.  <a href="segment_8hpp.html#a2c8b83720e61ef7c1cd29ea477ace306">More...</a><br /></td></tr>
<tr class="separator:a2c8b83720e61ef7c1cd29ea477ace306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f785caaa726dbe4ad21af7156d465e"><td class="memItemLeft" align="right" valign="top"><a id="a54f785caaa726dbe4ad21af7156d465e" name="a54f785caaa726dbe4ad21af7156d465e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MSF_NETNODES</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:a54f785caaa726dbe4ad21af7156d465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">move netnodes instead of changing inf.netdelta (this is slower); valid for <a class="el" href="segment_8hpp.html#addfcd63e80534616c4c6987100d6ea3a" title="Rebase the whole program by &#39;delta&#39; bytes.">rebase_program()</a> <br /></td></tr>
<tr class="separator:a54f785caaa726dbe4ad21af7156d465e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd7caffb298078265b62e590ae8dd62"><td class="memItemLeft" align="right" valign="top"><a id="acbd7caffb298078265b62e590ae8dd62" name="acbd7caffb298078265b62e590ae8dd62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSS_OK</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:acbd7caffb298078265b62e590ae8dd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">ok <br /></td></tr>
<tr class="separator:acbd7caffb298078265b62e590ae8dd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6e05ab80cc7007dcd4789418c2e76f"><td class="memItemLeft" align="right" valign="top"><a id="a5e6e05ab80cc7007dcd4789418c2e76f" name="a5e6e05ab80cc7007dcd4789418c2e76f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSS_NODBG</b>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:a5e6e05ab80cc7007dcd4789418c2e76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">debugger is not running <br /></td></tr>
<tr class="separator:a5e6e05ab80cc7007dcd4789418c2e76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b428dbce6e559a12a517f2b92a1ad9b"><td class="memItemLeft" align="right" valign="top"><a id="a9b428dbce6e559a12a517f2b92a1ad9b" name="a9b428dbce6e559a12a517f2b92a1ad9b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSS_NORANGE</b>&#160;&#160;&#160;-2</td></tr>
<tr class="memdesc:a9b428dbce6e559a12a517f2b92a1ad9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">could not find corresponding memory range <br /></td></tr>
<tr class="separator:a9b428dbce6e559a12a517f2b92a1ad9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7003f98227bcf53ea4be23de87bc81a8"><td class="memItemLeft" align="right" valign="top"><a id="a7003f98227bcf53ea4be23de87bc81a8" name="a7003f98227bcf53ea4be23de87bc81a8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSS_NOMEM</b>&#160;&#160;&#160;-3</td></tr>
<tr class="memdesc:a7003f98227bcf53ea4be23de87bc81a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">not enough memory (might be because the segment is too big) <br /></td></tr>
<tr class="separator:a7003f98227bcf53ea4be23de87bc81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0fb084636ab14048e25f1b9f57b926"><td class="memItemLeft" align="right" valign="top"><a id="a1d0fb084636ab14048e25f1b9f57b926" name="a1d0fb084636ab14048e25f1b9f57b926"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSS_BREAK</b>&#160;&#160;&#160;-4</td></tr>
<tr class="memdesc:a1d0fb084636ab14048e25f1b9f57b926"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory reading process stopped by user <br /></td></tr>
<tr class="separator:a1d0fb084636ab14048e25f1b9f57b926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054d87dc6fa25654d3356dd9dfd95a15"><td class="memItemLeft" align="right" valign="top"><a id="a054d87dc6fa25654d3356dd9dfd95a15" name="a054d87dc6fa25654d3356dd9dfd95a15"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNAP_ALL_SEG</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a054d87dc6fa25654d3356dd9dfd95a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a snapshot of all segments. <br /></td></tr>
<tr class="separator:a054d87dc6fa25654d3356dd9dfd95a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefc0bb61b773d5f64865067f227fb25"><td class="memItemLeft" align="right" valign="top"><a id="abefc0bb61b773d5f64865067f227fb25" name="abefc0bb61b773d5f64865067f227fb25"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNAP_LOAD_SEG</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:abefc0bb61b773d5f64865067f227fb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a snapshot of loader segments. <br /></td></tr>
<tr class="separator:abefc0bb61b773d5f64865067f227fb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84c5624f300e811033a36c52d710e26"><td class="memItemLeft" align="right" valign="top"><a id="af84c5624f300e811033a36c52d710e26" name="af84c5624f300e811033a36c52d710e26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SNAP_CUR_SEG</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:af84c5624f300e811033a36c52d710e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a snapshot of current segment. <br /></td></tr>
<tr class="separator:af84c5624f300e811033a36c52d710e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d20ba74425036fd66f863bb89adeda"><td class="memItemLeft" align="right" valign="top"><a id="a36d20ba74425036fd66f863bb89adeda" name="a36d20ba74425036fd66f863bb89adeda"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_GROUPS</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a36d20ba74425036fd66f863bb89adeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">max number of segment groups <br /></td></tr>
<tr class="separator:a36d20ba74425036fd66f863bb89adeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3337a43b347cedb01c040f78cd68a6bf"><td class="memItemLeft" align="right" valign="top"><a id="a3337a43b347cedb01c040f78cd68a6bf" name="a3337a43b347cedb01c040f78cd68a6bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SEGM_TRANSLATIONS</b>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:a3337a43b347cedb01c040f78cd68a6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">max number of segment translations <br /></td></tr>
<tr class="separator:a3337a43b347cedb01c040f78cd68a6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment flag: ORG directive</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >See <a class="el" href="group___s_f_l__.html#ga76758a64e75c56b04c528c84d3b70efe" title="IDP dependent field (IBM PC: if set, ORG directive is not commented out)">SFL_COMORG</a> </p>
</div></td></tr>
<tr class="memitem:ga33bd87d84e584f97b279e193f0ae958a"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SFL_OBOK</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ga33bd87d84e584f97b279e193f0ae958a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orgbase is present? (IDP dependent field) <br /></td></tr>
<tr class="separator:ga33bd87d84e584f97b279e193f0ae958a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment flag: orgbase</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >See <a class="el" href="group___s_f_l__.html#ga33bd87d84e584f97b279e193f0ae958a" title="Orgbase is present? (IDP dependent field)">SFL_OBOK</a> </p>
</div></td></tr>
<tr class="memitem:gac31257ddd90ad0acab343cebc28c2233"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SFL_HIDDEN</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:gac31257ddd90ad0acab343cebc28c2233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the segment hidden? <br /></td></tr>
<tr class="separator:gac31257ddd90ad0acab343cebc28c2233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment flag: hidden</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >See <a class="el" href="group___s_f_l__.html#gac31257ddd90ad0acab343cebc28c2233" title="Is the segment hidden?">SFL_HIDDEN</a> </p>
</div></td></tr>
<tr class="memitem:ga663d197c2dead5d7c02d36afa81b6738"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_f_l__.html#ga663d197c2dead5d7c02d36afa81b6738">SFL_DEBUG</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:ga663d197c2dead5d7c02d36afa81b6738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the segment created for the debugger?.  <a href="group___s_f_l__.html#ga663d197c2dead5d7c02d36afa81b6738">More...</a><br /></td></tr>
<tr class="separator:ga663d197c2dead5d7c02d36afa81b6738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment flag: debugger segment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >See <a class="el" href="group___s_f_l__.html#ga663d197c2dead5d7c02d36afa81b6738" title="Is the segment created for the debugger?.">SFL_DEBUG</a> </p>
</div></td></tr>
<tr class="memitem:gac89841edaa1830e41e109c416948c96d"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SFL_LOADER</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:gac89841edaa1830e41e109c416948c96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the segment created by the loader? <br /></td></tr>
<tr class="separator:gac89841edaa1830e41e109c416948c96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment flag: loader segment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >See <a class="el" href="group___s_f_l__.html#gac89841edaa1830e41e109c416948c96d" title="Is the segment created by the loader?">SFL_LOADER</a> </p>
</div></td></tr>
<tr class="memitem:ga5897753448a6c769538ed3890b9b8129"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SFL_HIDETYPE</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:ga5897753448a6c769538ed3890b9b8129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hide segment type (do not print it in the listing) <br /></td></tr>
<tr class="separator:ga5897753448a6c769538ed3890b9b8129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment flag: hide segment type</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >See <a class="el" href="group___s_f_l__.html#ga5897753448a6c769538ed3890b9b8129" title="Hide segment type (do not print it in the listing)">SFL_HIDETYPE</a> </p>
</div></td></tr>
<tr class="memitem:gac3bc49be172d44aad904ac8ab8aa8c3c"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SFL_HEADER</b>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:gac3bc49be172d44aad904ac8ab8aa8c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header segment (do not create offsets to it in the disassembly) <br /></td></tr>
<tr class="separator:gac3bc49be172d44aad904ac8ab8aa8c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment flag: header segment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >See <a class="el" href="group___s_f_l__.html#gac3bc49be172d44aad904ac8ab8aa8c3c" title="Header segment (do not create offsets to it in the disassembly)">SFL_HEADER</a> </p>
</div></td></tr>
<tr class="memitem:a8743c2828565f269e2e28c131abdc4ff"><td class="memItemLeft" align="right" valign="top"><a id="a8743c2828565f269e2e28c131abdc4ff" name="a8743c2828565f269e2e28c131abdc4ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_NORM</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a8743c2828565f269e2e28c131abdc4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">unknown type, no assumptions <br /></td></tr>
<tr class="separator:a8743c2828565f269e2e28c131abdc4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9bbede59653b945dacc70598306289"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a5c9bbede59653b945dacc70598306289">SEG_XTRN</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a5c9bbede59653b945dacc70598306289"><td class="mdescLeft">&#160;</td><td class="mdescRight">* segment with 'extern' definitions.  <a href="segment_8hpp.html#a5c9bbede59653b945dacc70598306289">More...</a><br /></td></tr>
<tr class="separator:a5c9bbede59653b945dacc70598306289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc10101b1288e858b747c0a9c329226"><td class="memItemLeft" align="right" valign="top"><a id="acfc10101b1288e858b747c0a9c329226" name="acfc10101b1288e858b747c0a9c329226"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_CODE</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:acfc10101b1288e858b747c0a9c329226"><td class="mdescLeft">&#160;</td><td class="mdescRight">code segment <br /></td></tr>
<tr class="separator:acfc10101b1288e858b747c0a9c329226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f583dca1a7fef2948458048c70b2f1c"><td class="memItemLeft" align="right" valign="top"><a id="a9f583dca1a7fef2948458048c70b2f1c" name="a9f583dca1a7fef2948458048c70b2f1c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_DATA</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a9f583dca1a7fef2948458048c70b2f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">data segment <br /></td></tr>
<tr class="separator:a9f583dca1a7fef2948458048c70b2f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22448536108607769405d6ca1f69034"><td class="memItemLeft" align="right" valign="top"><a id="aa22448536108607769405d6ca1f69034" name="aa22448536108607769405d6ca1f69034"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_IMP</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:aa22448536108607769405d6ca1f69034"><td class="mdescLeft">&#160;</td><td class="mdescRight">java: implementation segment <br /></td></tr>
<tr class="separator:aa22448536108607769405d6ca1f69034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bd0f97c65dd59b10ea76b16d444784"><td class="memItemLeft" align="right" valign="top"><a id="ab3bd0f97c65dd59b10ea76b16d444784" name="ab3bd0f97c65dd59b10ea76b16d444784"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_GRP</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:ab3bd0f97c65dd59b10ea76b16d444784"><td class="mdescLeft">&#160;</td><td class="mdescRight">* group of segments <br /></td></tr>
<tr class="separator:ab3bd0f97c65dd59b10ea76b16d444784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594f82f31d1ed7189ad21c3af3279269"><td class="memItemLeft" align="right" valign="top"><a id="a594f82f31d1ed7189ad21c3af3279269" name="a594f82f31d1ed7189ad21c3af3279269"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_NULL</b>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a594f82f31d1ed7189ad21c3af3279269"><td class="mdescLeft">&#160;</td><td class="mdescRight">zero-length segment <br /></td></tr>
<tr class="separator:a594f82f31d1ed7189ad21c3af3279269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344b3516eb098ebe8ce00e193af53270"><td class="memItemLeft" align="right" valign="top"><a id="a344b3516eb098ebe8ce00e193af53270" name="a344b3516eb098ebe8ce00e193af53270"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_UNDF</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a344b3516eb098ebe8ce00e193af53270"><td class="mdescLeft">&#160;</td><td class="mdescRight">undefined segment type (not used) <br /></td></tr>
<tr class="separator:a344b3516eb098ebe8ce00e193af53270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d8517210b3c56679eca1111e4c0fc"><td class="memItemLeft" align="right" valign="top"><a id="a0e7d8517210b3c56679eca1111e4c0fc" name="a0e7d8517210b3c56679eca1111e4c0fc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_BSS</b>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a0e7d8517210b3c56679eca1111e4c0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">uninitialized segment <br /></td></tr>
<tr class="separator:a0e7d8517210b3c56679eca1111e4c0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c130d299e48ff537068e03e8ae23d71"><td class="memItemLeft" align="right" valign="top"><a id="a5c130d299e48ff537068e03e8ae23d71" name="a5c130d299e48ff537068e03e8ae23d71"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_ABSSYM</b>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a5c130d299e48ff537068e03e8ae23d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">* segment with definitions of absolute symbols <br /></td></tr>
<tr class="separator:a5c130d299e48ff537068e03e8ae23d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a39aa78e00ea21899571a2b636976e"><td class="memItemLeft" align="right" valign="top"><a id="a39a39aa78e00ea21899571a2b636976e" name="a39a39aa78e00ea21899571a2b636976e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_COMM</b>&#160;&#160;&#160;11</td></tr>
<tr class="memdesc:a39a39aa78e00ea21899571a2b636976e"><td class="mdescLeft">&#160;</td><td class="mdescRight">* segment with communal definitions <br /></td></tr>
<tr class="separator:a39a39aa78e00ea21899571a2b636976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661e744128725accf12f76a91ac82c41"><td class="memItemLeft" align="right" valign="top"><a id="a661e744128725accf12f76a91ac82c41" name="a661e744128725accf12f76a91ac82c41"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_IMEM</b>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:a661e744128725accf12f76a91ac82c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal processor memory &amp; sfr (8051) <br /></td></tr>
<tr class="separator:a661e744128725accf12f76a91ac82c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44f4f206e7051e581de00a394a76282"><td class="memItemLeft" align="right" valign="top"><a id="ad44f4f206e7051e581de00a394a76282" name="ad44f4f206e7051e581de00a394a76282"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SEG_MAX_SEGTYPE_CODE</b>&#160;&#160;&#160;<a class="el" href="segment_8hpp.html#a661e744128725accf12f76a91ac82c41">SEG_IMEM</a></td></tr>
<tr class="separator:ad44f4f206e7051e581de00a394a76282"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a77847d21aeb16b4d7d0b132154bc072a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072a">move_segm_code_t</a> { <br />
&#160;&#160;<a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa41abbdfceac6b1b1da9f8910042a9bc7">MOVE_SEGM_OK</a> = 0
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa3cc3b0dd4a54e7e68cfbf0ad7275df09">MOVE_SEGM_PARAM</a> = -1
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa141e1d5f254a188935aa83ea8eab6fb4">MOVE_SEGM_ROOM</a> = -2
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa705ffca2afbcb048466a259c016133a4">MOVE_SEGM_IDP</a> = -3
, <br />
&#160;&#160;<a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa996a84accfd653aabd6ba0a8c3e335d5">MOVE_SEGM_CHUNK</a> = -4
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa058d7720ffcf8db7ef040cc45d310512">MOVE_SEGM_LOADER</a> = -5
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aae1ef7c45622afe9644b8479823a7846e">MOVE_SEGM_ODD</a> = -6
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa63c7e1edc5565750331cff7ffdb4aaae">MOVE_SEGM_ORPHAN</a> = -7
, <br />
&#160;&#160;<a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aaebd19e78d2ca7b5e7ca7bb5cc3b6f14e">MOVE_SEGM_DEBUG</a> = -8
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aae71f72430df7438e54c8b96809e8272f">MOVE_SEGM_SOURCEFILES</a> = -9
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa00fef7358927202429527848c8e75702">MOVE_SEGM_MAPPING</a> = -10
, <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072aa972f723d6c7f84d065e21ffdd326294a">MOVE_SEGM_INVAL</a> = -11
<br />
 }</td></tr>
<tr class="separator:a77847d21aeb16b4d7d0b132154bc072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5971fa41ef8ad4588a189a9715c36186"><td class="memItemLeft" align="right" valign="top"><a id="a5971fa41ef8ad4588a189a9715c36186" name="a5971fa41ef8ad4588a189a9715c36186"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CASSERT</b> (sizeof(<a class="el" href="classsegment__t.html">segment_t</a>)==104)</td></tr>
<tr class="separator:a5971fa41ef8ad4588a189a9715c36186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0317864374e984294b04693bb6b1f91"><td class="memItemLeft" align="right" valign="top"><a id="ab0317864374e984294b04693bb6b1f91" name="ab0317864374e984294b04693bb6b1f91"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_visible_segm</b> (<a class="el" href="classsegment__t.html">segment_t</a> *s)</td></tr>
<tr class="memdesc:ab0317864374e984294b04693bb6b1f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group___s_f_l__.html#gac31257ddd90ad0acab343cebc28c2233" title="Is the segment hidden?">SFL_HIDDEN</a>. <br /></td></tr>
<tr class="separator:ab0317864374e984294b04693bb6b1f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647d00f6f9abf3ca68071646eeecf833"><td class="memItemLeft" align="right" valign="top"><a id="a647d00f6f9abf3ca68071646eeecf833" name="a647d00f6f9abf3ca68071646eeecf833"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_finally_visible_segm</b> (<a class="el" href="classsegment__t.html">segment_t</a> *s)</td></tr>
<tr class="memdesc:a647d00f6f9abf3ca68071646eeecf833"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group___s_f_l__.html#gac31257ddd90ad0acab343cebc28c2233" title="Is the segment hidden?">SFL_HIDDEN</a>, <a class="el" href="ida_8hpp.html#a8975e10fbd1525ca08522503b1a78c2c" title="show hidden segments">SCF_SHHID_SEGM</a>. <br /></td></tr>
<tr class="separator:a647d00f6f9abf3ca68071646eeecf833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5fcdb678001b56f1e193ae57ed938a"><td class="memItemLeft" align="right" valign="top"><a id="a4a5fcdb678001b56f1e193ae57ed938a" name="a4a5fcdb678001b56f1e193ae57ed938a"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_visible_segm</b> (<a class="el" href="classsegment__t.html">segment_t</a> *s, bool visible)</td></tr>
<tr class="memdesc:a4a5fcdb678001b56f1e193ae57ed938a"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group___s_f_l__.html#gac31257ddd90ad0acab343cebc28c2233" title="Is the segment hidden?">SFL_HIDDEN</a>. <br /></td></tr>
<tr class="separator:a4a5fcdb678001b56f1e193ae57ed938a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20821d1751b3f47f92cc263e1552c7c"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aa20821d1751b3f47f92cc263e1552c7c">is_spec_segm</a> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> seg_type)</td></tr>
<tr class="memdesc:aa20821d1751b3f47f92cc263e1552c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has segment a special type?.  <a href="segment_8hpp.html#aa20821d1751b3f47f92cc263e1552c7c">More...</a><br /></td></tr>
<tr class="separator:aa20821d1751b3f47f92cc263e1552c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f10e64c09b833e76ca5f3b7954cc9d"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a80f10e64c09b833e76ca5f3b7954cc9d">is_spec_ea</a> (ea_t ea)</td></tr>
<tr class="memdesc:a80f10e64c09b833e76ca5f3b7954cc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the address belong to a segment with a special type?.  <a href="segment_8hpp.html#a80f10e64c09b833e76ca5f3b7954cc9d">More...</a><br /></td></tr>
<tr class="separator:a80f10e64c09b833e76ca5f3b7954cc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b6f6b1ceaff968314c9125a5206e60"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a63b6f6b1ceaff968314c9125a5206e60">lock_segm</a> (const <a class="el" href="classsegment__t.html">segment_t</a> *segm, bool lock)</td></tr>
<tr class="memdesc:a63b6f6b1ceaff968314c9125a5206e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock segment pointer Locked pointers are guaranteed to remain valid until they are unlocked.  <a href="segment_8hpp.html#a63b6f6b1ceaff968314c9125a5206e60">More...</a><br /></td></tr>
<tr class="separator:a63b6f6b1ceaff968314c9125a5206e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e6c48b6b509790a83f5a78f77c4224"><td class="memItemLeft" align="right" valign="top"><a id="a61e6c48b6b509790a83f5a78f77c4224" name="a61e6c48b6b509790a83f5a78f77c4224"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_segm_locked</b> (const <a class="el" href="classsegment__t.html">segment_t</a> *segm)</td></tr>
<tr class="memdesc:a61e6c48b6b509790a83f5a78f77c4224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a segment pointer locked? <br /></td></tr>
<tr class="separator:a61e6c48b6b509790a83f5a78f77c4224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14f8b09f7f016cd4b179a4820129ecf"><td class="memItemLeft" align="right" valign="top"><a id="ad14f8b09f7f016cd4b179a4820129ecf" name="ad14f8b09f7f016cd4b179a4820129ecf"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>getn_selector</b> (sel_t *sel, ea_t *base, int n)</td></tr>
<tr class="memdesc:ad14f8b09f7f016cd4b179a4820129ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get description of selector (0..<a class="el" href="segment_8hpp.html#a5a72e6537e7241d7feacee3a7c30a5d1" title="Get number of defined selectors.">get_selector_qty()</a>-1) <br /></td></tr>
<tr class="separator:ad14f8b09f7f016cd4b179a4820129ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a72e6537e7241d7feacee3a7c30a5d1"><td class="memItemLeft" align="right" valign="top"><a id="a5a72e6537e7241d7feacee3a7c30a5d1" name="a5a72e6537e7241d7feacee3a7c30a5d1"></a>
idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_selector_qty</b> (void)</td></tr>
<tr class="memdesc:a5a72e6537e7241d7feacee3a7c30a5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of defined selectors. <br /></td></tr>
<tr class="separator:a5a72e6537e7241d7feacee3a7c30a5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b819f125c442c7476c1a844cee22d5"><td class="memItemLeft" align="right" valign="top">idaman sel_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a95b819f125c442c7476c1a844cee22d5">setup_selector</a> (ea_t segbase)</td></tr>
<tr class="memdesc:a95b819f125c442c7476c1a844cee22d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a selector for a segment if necessary.  <a href="segment_8hpp.html#a95b819f125c442c7476c1a844cee22d5">More...</a><br /></td></tr>
<tr class="separator:a95b819f125c442c7476c1a844cee22d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc493dc34c0cc8268be321fc89a72fd"><td class="memItemLeft" align="right" valign="top">idaman sel_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a0bc493dc34c0cc8268be321fc89a72fd">allocate_selector</a> (ea_t segbase)</td></tr>
<tr class="memdesc:a0bc493dc34c0cc8268be321fc89a72fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a selector for a segment unconditionally.  <a href="segment_8hpp.html#a0bc493dc34c0cc8268be321fc89a72fd">More...</a><br /></td></tr>
<tr class="separator:a0bc493dc34c0cc8268be321fc89a72fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d8d263928e1700026ab15eabf10480"><td class="memItemLeft" align="right" valign="top">idaman sel_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#ae9d8d263928e1700026ab15eabf10480">find_free_selector</a> (void)</td></tr>
<tr class="memdesc:ae9d8d263928e1700026ab15eabf10480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find first unused selector.  <a href="segment_8hpp.html#ae9d8d263928e1700026ab15eabf10480">More...</a><br /></td></tr>
<tr class="separator:ae9d8d263928e1700026ab15eabf10480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee421bd585e301aea9452c84ac735c6a"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aee421bd585e301aea9452c84ac735c6a">set_selector</a> (sel_t selector, ea_t paragraph)</td></tr>
<tr class="memdesc:aee421bd585e301aea9452c84ac735c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set mapping of selector to a paragraph.  <a href="segment_8hpp.html#aee421bd585e301aea9452c84ac735c6a">More...</a><br /></td></tr>
<tr class="separator:aee421bd585e301aea9452c84ac735c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f786fe1f285b2a2df2c7c6a18d57a9"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a30f786fe1f285b2a2df2c7c6a18d57a9">del_selector</a> (sel_t selector)</td></tr>
<tr class="memdesc:a30f786fe1f285b2a2df2c7c6a18d57a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete mapping of a selector.  <a href="segment_8hpp.html#a30f786fe1f285b2a2df2c7c6a18d57a9">More...</a><br /></td></tr>
<tr class="separator:a30f786fe1f285b2a2df2c7c6a18d57a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8416e3237013eadfd32dfafc87953e3c"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a8416e3237013eadfd32dfafc87953e3c">sel2para</a> (sel_t selector)</td></tr>
<tr class="memdesc:a8416e3237013eadfd32dfafc87953e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mapping of a selector.  <a href="segment_8hpp.html#a8416e3237013eadfd32dfafc87953e3c">More...</a><br /></td></tr>
<tr class="separator:a8416e3237013eadfd32dfafc87953e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf8f3ddf2be4616b37609bf3d302c8e"><td class="memItemLeft" align="right" valign="top">ea_t idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a0bf8f3ddf2be4616b37609bf3d302c8e">sel2ea</a> (sel_t selector)</td></tr>
<tr class="memdesc:a0bf8f3ddf2be4616b37609bf3d302c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mapping of a selector as a linear address.  <a href="segment_8hpp.html#a0bf8f3ddf2be4616b37609bf3d302c8e">More...</a><br /></td></tr>
<tr class="separator:a0bf8f3ddf2be4616b37609bf3d302c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a5a8ead1db6a02fe332395bb0f1e25"><td class="memItemLeft" align="right" valign="top">idaman sel_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#af4a5a8ead1db6a02fe332395bb0f1e25">find_selector</a> (ea_t base)</td></tr>
<tr class="memdesc:af4a5a8ead1db6a02fe332395bb0f1e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a selector that has mapping to the specified paragraph.  <a href="segment_8hpp.html#af4a5a8ead1db6a02fe332395bb0f1e25">More...</a><br /></td></tr>
<tr class="separator:af4a5a8ead1db6a02fe332395bb0f1e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6e924cc3dd3971f5576a4569afc3c7"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a6e6e924cc3dd3971f5576a4569afc3c7">enumerate_selectors</a> (int(idaapi *func)(sel_t sel, ea_t para))</td></tr>
<tr class="memdesc:a6e6e924cc3dd3971f5576a4569afc3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all selectors from the translation table.  <a href="segment_8hpp.html#a6e6e924cc3dd3971f5576a4569afc3c7">More...</a><br /></td></tr>
<tr class="separator:a6e6e924cc3dd3971f5576a4569afc3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4e1add83a761fa1d74c87aee963aa7"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a3e4e1add83a761fa1d74c87aee963aa7">enumerate_segments_with_selector</a> (sel_t selector, ea_t(idaapi *func)(<a class="el" href="classsegment__t.html">segment_t</a> *s, void *ud), void *ud=nullptr)</td></tr>
<tr class="memdesc:a3e4e1add83a761fa1d74c87aee963aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all segments with the specified selector.  <a href="segment_8hpp.html#a3e4e1add83a761fa1d74c87aee963aa7">More...</a><br /></td></tr>
<tr class="separator:a3e4e1add83a761fa1d74c87aee963aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e10a0ce567121fdb3748886228de7bf"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a2e10a0ce567121fdb3748886228de7bf">get_segm_by_sel</a> (sel_t selector)</td></tr>
<tr class="memdesc:a2e10a0ce567121fdb3748886228de7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to segment structure.  <a href="segment_8hpp.html#a2e10a0ce567121fdb3748886228de7bf">More...</a><br /></td></tr>
<tr class="separator:a2e10a0ce567121fdb3748886228de7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38d0afa3faaa85ce63da0a69882bc60"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aa38d0afa3faaa85ce63da0a69882bc60">add_segm_ex</a> (<a class="el" href="classsegment__t.html">segment_t</a> *NONNULL s, const char *name, const char *sclass, int flags)</td></tr>
<tr class="memdesc:aa38d0afa3faaa85ce63da0a69882bc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new segment.  <a href="segment_8hpp.html#aa38d0afa3faaa85ce63da0a69882bc60">More...</a><br /></td></tr>
<tr class="separator:aa38d0afa3faaa85ce63da0a69882bc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f6ee9677c2605aeac9541e38e54025"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a59f6ee9677c2605aeac9541e38e54025">add_segm</a> (ea_t para, ea_t start, ea_t end, const char *name, const char *sclass, int flags=0)</td></tr>
<tr class="memdesc:a59f6ee9677c2605aeac9541e38e54025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new segment, second form.  <a href="segment_8hpp.html#a59f6ee9677c2605aeac9541e38e54025">More...</a><br /></td></tr>
<tr class="separator:a59f6ee9677c2605aeac9541e38e54025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebbd185abaf370753d5ea59d32d9985"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#abebbd185abaf370753d5ea59d32d9985">del_segm</a> (ea_t ea, int flags)</td></tr>
<tr class="memdesc:abebbd185abaf370753d5ea59d32d9985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a segment.  <a href="segment_8hpp.html#abebbd185abaf370753d5ea59d32d9985">More...</a><br /></td></tr>
<tr class="separator:abebbd185abaf370753d5ea59d32d9985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e848ee2505a32634309a914195fe141"><td class="memItemLeft" align="right" valign="top"><a id="a9e848ee2505a32634309a914195fe141" name="a9e848ee2505a32634309a914195fe141"></a>
idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_segm_qty</b> (void)</td></tr>
<tr class="memdesc:a9e848ee2505a32634309a914195fe141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of segments. <br /></td></tr>
<tr class="separator:a9e848ee2505a32634309a914195fe141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56c8c4cfc5b232ee2580d86671d96f8"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#ab56c8c4cfc5b232ee2580d86671d96f8">getseg</a> (ea_t ea)</td></tr>
<tr class="memdesc:ab56c8c4cfc5b232ee2580d86671d96f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to segment by linear address.  <a href="segment_8hpp.html#ab56c8c4cfc5b232ee2580d86671d96f8">More...</a><br /></td></tr>
<tr class="separator:ab56c8c4cfc5b232ee2580d86671d96f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab562913860bdc24ddfdf45e5203b131c"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#ab562913860bdc24ddfdf45e5203b131c">getnseg</a> (int n)</td></tr>
<tr class="memdesc:ab562913860bdc24ddfdf45e5203b131c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to segment by its number.  <a href="segment_8hpp.html#ab562913860bdc24ddfdf45e5203b131c">More...</a><br /></td></tr>
<tr class="separator:ab562913860bdc24ddfdf45e5203b131c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73fd60fa5ec55b12441ecbf3224f742"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#ab73fd60fa5ec55b12441ecbf3224f742">get_segm_num</a> (ea_t ea)</td></tr>
<tr class="memdesc:ab73fd60fa5ec55b12441ecbf3224f742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of segment by address.  <a href="segment_8hpp.html#ab73fd60fa5ec55b12441ecbf3224f742">More...</a><br /></td></tr>
<tr class="separator:ab73fd60fa5ec55b12441ecbf3224f742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273a3e74f7e470e6ca552491b81365ef"><td class="memItemLeft" align="right" valign="top"><a id="a273a3e74f7e470e6ca552491b81365ef" name="a273a3e74f7e470e6ca552491b81365ef"></a>
idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_next_seg</b> (ea_t ea)</td></tr>
<tr class="memdesc:a273a3e74f7e470e6ca552491b81365ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the next segment. <br /></td></tr>
<tr class="separator:a273a3e74f7e470e6ca552491b81365ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011689c1304c845921f3e6ae4972678c"><td class="memItemLeft" align="right" valign="top"><a id="a011689c1304c845921f3e6ae4972678c" name="a011689c1304c845921f3e6ae4972678c"></a>
idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_prev_seg</b> (ea_t ea)</td></tr>
<tr class="memdesc:a011689c1304c845921f3e6ae4972678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the previous segment. <br /></td></tr>
<tr class="separator:a011689c1304c845921f3e6ae4972678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16de4decb8d1f3d2ba8c3a39d1bc0580"><td class="memItemLeft" align="right" valign="top"><a id="a16de4decb8d1f3d2ba8c3a39d1bc0580" name="a16de4decb8d1f3d2ba8c3a39d1bc0580"></a>
idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_first_seg</b> (void)</td></tr>
<tr class="memdesc:a16de4decb8d1f3d2ba8c3a39d1bc0580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the first segment. <br /></td></tr>
<tr class="separator:a16de4decb8d1f3d2ba8c3a39d1bc0580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa3010081d686333eabc8fed9b98e37"><td class="memItemLeft" align="right" valign="top"><a id="a3fa3010081d686333eabc8fed9b98e37" name="a3fa3010081d686333eabc8fed9b98e37"></a>
idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_last_seg</b> (void)</td></tr>
<tr class="memdesc:a3fa3010081d686333eabc8fed9b98e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the last segment. <br /></td></tr>
<tr class="separator:a3fa3010081d686333eabc8fed9b98e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7086a4321f2d301b27edc9ec4960370d"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a7086a4321f2d301b27edc9ec4960370d">get_segm_by_name</a> (const char *name)</td></tr>
<tr class="memdesc:a7086a4321f2d301b27edc9ec4960370d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to segment by its name.  <a href="segment_8hpp.html#a7086a4321f2d301b27edc9ec4960370d">More...</a><br /></td></tr>
<tr class="separator:a7086a4321f2d301b27edc9ec4960370d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadde01303718a6cde673dca12ffac9d7"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aadde01303718a6cde673dca12ffac9d7">set_segm_end</a> (ea_t ea, ea_t newend, int flags)</td></tr>
<tr class="memdesc:aadde01303718a6cde673dca12ffac9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set segment end address.  <a href="segment_8hpp.html#aadde01303718a6cde673dca12ffac9d7">More...</a><br /></td></tr>
<tr class="separator:aadde01303718a6cde673dca12ffac9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcd6c25a6d3bfc4bafeb786db81ec79"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#affcd6c25a6d3bfc4bafeb786db81ec79">set_segm_start</a> (ea_t ea, ea_t newstart, int flags)</td></tr>
<tr class="memdesc:affcd6c25a6d3bfc4bafeb786db81ec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set segment start address.  <a href="segment_8hpp.html#affcd6c25a6d3bfc4bafeb786db81ec79">More...</a><br /></td></tr>
<tr class="separator:affcd6c25a6d3bfc4bafeb786db81ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93c02cc5dccb84dc5d302dc8dcf67dc"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aa93c02cc5dccb84dc5d302dc8dcf67dc">move_segm_start</a> (ea_t ea, ea_t newstart, int mode)</td></tr>
<tr class="memdesc:aa93c02cc5dccb84dc5d302dc8dcf67dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move segment start.  <a href="segment_8hpp.html#aa93c02cc5dccb84dc5d302dc8dcf67dc">More...</a><br /></td></tr>
<tr class="separator:aa93c02cc5dccb84dc5d302dc8dcf67dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cef193322f009bdb14962ff341adeb"><td class="memItemLeft" align="right" valign="top"><a id="a50cef193322f009bdb14962ff341adeb" name="a50cef193322f009bdb14962ff341adeb"></a>
idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>move_segm_strerror</b> (<a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072a">move_segm_code_t</a> code)</td></tr>
<tr class="memdesc:a50cef193322f009bdb14962ff341adeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return string describing error MOVE_SEGM_... code. <br /></td></tr>
<tr class="separator:a50cef193322f009bdb14962ff341adeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbc36e396bf222ba1f2c278764b09ba"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072a">move_segm_code_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#adfbc36e396bf222ba1f2c278764b09ba">move_segm</a> (<a class="el" href="classsegment__t.html">segment_t</a> *s, ea_t to, int flags=0)</td></tr>
<tr class="memdesc:adfbc36e396bf222ba1f2c278764b09ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function moves all information to the new address.  <a href="segment_8hpp.html#adfbc36e396bf222ba1f2c278764b09ba">More...</a><br /></td></tr>
<tr class="separator:adfbc36e396bf222ba1f2c278764b09ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfcd63e80534616c4c6987100d6ea3a"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072a">move_segm_code_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#addfcd63e80534616c4c6987100d6ea3a">rebase_program</a> (adiff_t delta, int flags)</td></tr>
<tr class="memdesc:addfcd63e80534616c4c6987100d6ea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebase the whole program by 'delta' bytes.  <a href="segment_8hpp.html#addfcd63e80534616c4c6987100d6ea3a">More...</a><br /></td></tr>
<tr class="separator:addfcd63e80534616c4c6987100d6ea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad15e77b3eb0f53f1b5083aa0c3a70b"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a4ad15e77b3eb0f53f1b5083aa0c3a70b">change_segment_status</a> (<a class="el" href="classsegment__t.html">segment_t</a> *s, bool is_deb_segm)</td></tr>
<tr class="memdesc:a4ad15e77b3eb0f53f1b5083aa0c3a70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a debugger segment to a regular segment and vice versa.  <a href="segment_8hpp.html#a4ad15e77b3eb0f53f1b5083aa0c3a70b">More...</a><br /></td></tr>
<tr class="separator:a4ad15e77b3eb0f53f1b5083aa0c3a70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfec844a1b815af3e425d8e2144bea7"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aacfec844a1b815af3e425d8e2144bea7">take_memory_snapshot</a> (int type)</td></tr>
<tr class="memdesc:aacfec844a1b815af3e425d8e2144bea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a memory snapshot of the running process.  <a href="segment_8hpp.html#aacfec844a1b815af3e425d8e2144bea7">More...</a><br /></td></tr>
<tr class="separator:aacfec844a1b815af3e425d8e2144bea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e9fffcb08d5be5a4d94b5f30a84be2"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#ac6e9fffcb08d5be5a4d94b5f30a84be2">is_miniidb</a> (void)</td></tr>
<tr class="memdesc:ac6e9fffcb08d5be5a4d94b5f30a84be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the database a miniidb created by the debugger?.  <a href="segment_8hpp.html#ac6e9fffcb08d5be5a4d94b5f30a84be2">More...</a><br /></td></tr>
<tr class="separator:ac6e9fffcb08d5be5a4d94b5f30a84be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb1707a8b4bec1a05923aa43c4c06f0"><td class="memItemLeft" align="right" valign="top"><a id="acdb1707a8b4bec1a05923aa43c4c06f0" name="acdb1707a8b4bec1a05923aa43c4c06f0"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_segm_base</b> (<a class="el" href="classsegment__t.html">segment_t</a> *s, ea_t newbase)</td></tr>
<tr class="memdesc:acdb1707a8b4bec1a05923aa43c4c06f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function. <br /></td></tr>
<tr class="separator:acdb1707a8b4bec1a05923aa43c4c06f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0011ca67788905ff2b401b3376f8802"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#ac0011ca67788905ff2b401b3376f8802">set_group_selector</a> (sel_t grp, sel_t sel)</td></tr>
<tr class="memdesc:ac0011ca67788905ff2b401b3376f8802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new group of segments (used OMF files).  <a href="segment_8hpp.html#ac0011ca67788905ff2b401b3376f8802">More...</a><br /></td></tr>
<tr class="separator:ac0011ca67788905ff2b401b3376f8802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dfb9e4396914c0118978a77897c427"><td class="memItemLeft" align="right" valign="top">idaman sel_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a38dfb9e4396914c0118978a77897c427">get_group_selector</a> (sel_t grpsel)</td></tr>
<tr class="memdesc:a38dfb9e4396914c0118978a77897c427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get common selector for a group of segments.  <a href="segment_8hpp.html#a38dfb9e4396914c0118978a77897c427">More...</a><br /></td></tr>
<tr class="separator:a38dfb9e4396914c0118978a77897c427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162acfa28de46b3afb2aba0639f7f0a8"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a162acfa28de46b3afb2aba0639f7f0a8">add_segment_translation</a> (ea_t segstart, ea_t mappedseg)</td></tr>
<tr class="memdesc:a162acfa28de46b3afb2aba0639f7f0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add segment translation.  <a href="segment_8hpp.html#a162acfa28de46b3afb2aba0639f7f0a8">More...</a><br /></td></tr>
<tr class="separator:a162acfa28de46b3afb2aba0639f7f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b4d9ab9a809f3ae2e12ea7ef285576"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a77b4d9ab9a809f3ae2e12ea7ef285576">set_segment_translations</a> (ea_t segstart, const <a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> &amp;transmap)</td></tr>
<tr class="memdesc:a77b4d9ab9a809f3ae2e12ea7ef285576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new translation list.  <a href="segment_8hpp.html#a77b4d9ab9a809f3ae2e12ea7ef285576">More...</a><br /></td></tr>
<tr class="separator:a77b4d9ab9a809f3ae2e12ea7ef285576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d43bfa417e11caee34c45ff3ca5288"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a18d43bfa417e11caee34c45ff3ca5288">del_segment_translations</a> (ea_t segstart)</td></tr>
<tr class="memdesc:a18d43bfa417e11caee34c45ff3ca5288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the translation list.  <a href="segment_8hpp.html#a18d43bfa417e11caee34c45ff3ca5288">More...</a><br /></td></tr>
<tr class="separator:a18d43bfa417e11caee34c45ff3ca5288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546786583c25f26b1477f83df2d35fa2"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a546786583c25f26b1477f83df2d35fa2">get_segment_translations</a> (<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> *transmap, ea_t segstart)</td></tr>
<tr class="memdesc:a546786583c25f26b1477f83df2d35fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment translation list.  <a href="segment_8hpp.html#a546786583c25f26b1477f83df2d35fa2">More...</a><br /></td></tr>
<tr class="separator:a546786583c25f26b1477f83df2d35fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa055ce0d55f0949d6f907a584e1ec65d"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aa055ce0d55f0949d6f907a584e1ec65d">get_segment_cmt</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classsegment__t.html">segment_t</a> *s, bool repeatable)</td></tr>
<tr class="memdesc:aa055ce0d55f0949d6f907a584e1ec65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment comment.  <a href="segment_8hpp.html#aa055ce0d55f0949d6f907a584e1ec65d">More...</a><br /></td></tr>
<tr class="separator:aa055ce0d55f0949d6f907a584e1ec65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092e05e64ba60bc29bb90cfdd03f05f8"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a092e05e64ba60bc29bb90cfdd03f05f8">set_segment_cmt</a> (const <a class="el" href="classsegment__t.html">segment_t</a> *s, const char *cmt, bool repeatable)</td></tr>
<tr class="memdesc:a092e05e64ba60bc29bb90cfdd03f05f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set segment comment.  <a href="segment_8hpp.html#a092e05e64ba60bc29bb90cfdd03f05f8">More...</a><br /></td></tr>
<tr class="separator:a092e05e64ba60bc29bb90cfdd03f05f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7510d346be798cbe9bb08305ee964e5"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#aa7510d346be798cbe9bb08305ee964e5">std_out_segm_footer</a> (struct <a class="el" href="structoutctx__t.html">outctx_t</a> &amp;ctx, <a class="el" href="classsegment__t.html">segment_t</a> *seg)</td></tr>
<tr class="memdesc:aa7510d346be798cbe9bb08305ee964e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate segment footer line as a comment line.  <a href="segment_8hpp.html#aa7510d346be798cbe9bb08305ee964e5">More...</a><br /></td></tr>
<tr class="separator:aa7510d346be798cbe9bb08305ee964e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5103bc9a9467bf76955237678ebe1a"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a3d5103bc9a9467bf76955237678ebe1a">set_segm_name</a> (<a class="el" href="classsegment__t.html">segment_t</a> *s, const char *name, int flags=0)</td></tr>
<tr class="memdesc:a3d5103bc9a9467bf76955237678ebe1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename segment.  <a href="segment_8hpp.html#a3d5103bc9a9467bf76955237678ebe1a">More...</a><br /></td></tr>
<tr class="separator:a3d5103bc9a9467bf76955237678ebe1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338226d1af237de04e3ca6c941560afe"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a338226d1af237de04e3ca6c941560afe">get_segm_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classsegment__t.html">segment_t</a> *s, int flags=0)</td></tr>
<tr class="memdesc:a338226d1af237de04e3ca6c941560afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get true segment name by pointer to segment.  <a href="segment_8hpp.html#a338226d1af237de04e3ca6c941560afe">More...</a><br /></td></tr>
<tr class="separator:a338226d1af237de04e3ca6c941560afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9664611338c9701b54dd1f0e4915a7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a9664611338c9701b54dd1f0e4915a7d9">get_visible_segm_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classsegment__t.html">segment_t</a> *s)</td></tr>
<tr class="memdesc:a9664611338c9701b54dd1f0e4915a7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment name by pointer to segment.  <a href="segment_8hpp.html#a9664611338c9701b54dd1f0e4915a7d9">More...</a><br /></td></tr>
<tr class="separator:a9664611338c9701b54dd1f0e4915a7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbbb4017cfa20f887d0b6f0fe01693f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#afbbbb4017cfa20f887d0b6f0fe01693f">get_segm_expr</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, ea_t from, sel_t sel)</td></tr>
<tr class="memdesc:afbbbb4017cfa20f887d0b6f0fe01693f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get colored segment name expression in the form (segname + displacement).  <a href="segment_8hpp.html#afbbbb4017cfa20f887d0b6f0fe01693f">More...</a><br /></td></tr>
<tr class="separator:afbbbb4017cfa20f887d0b6f0fe01693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd2a886a9bee23b3f9746d4e618ead2"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a6fd2a886a9bee23b3f9746d4e618ead2">get_segm_class</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, const <a class="el" href="classsegment__t.html">segment_t</a> *s)</td></tr>
<tr class="memdesc:a6fd2a886a9bee23b3f9746d4e618ead2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment class.  <a href="segment_8hpp.html#a6fd2a886a9bee23b3f9746d4e618ead2">More...</a><br /></td></tr>
<tr class="separator:a6fd2a886a9bee23b3f9746d4e618ead2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3053ee105dd0c1201b7cb5ad2feb963d"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a3053ee105dd0c1201b7cb5ad2feb963d">set_segm_class</a> (<a class="el" href="classsegment__t.html">segment_t</a> *s, const char *sclass, int flags=0)</td></tr>
<tr class="memdesc:a3053ee105dd0c1201b7cb5ad2feb963d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set segment class.  <a href="segment_8hpp.html#a3053ee105dd0c1201b7cb5ad2feb963d">More...</a><br /></td></tr>
<tr class="separator:a3053ee105dd0c1201b7cb5ad2feb963d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eaaed66c079e1ac389902d19046d20"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a67eaaed66c079e1ac389902d19046d20">segtype</a> (ea_t ea)</td></tr>
<tr class="memdesc:a67eaaed66c079e1ac389902d19046d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment type.  <a href="segment_8hpp.html#a67eaaed66c079e1ac389902d19046d20">More...</a><br /></td></tr>
<tr class="separator:a67eaaed66c079e1ac389902d19046d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f9d15ab461fecbffc39007716eefcd"><td class="memItemLeft" align="right" valign="top">idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a91f9d15ab461fecbffc39007716eefcd">get_segment_alignment</a> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> align)</td></tr>
<tr class="memdesc:a91f9d15ab461fecbffc39007716eefcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get text representation of segment alignment code.  <a href="segment_8hpp.html#a91f9d15ab461fecbffc39007716eefcd">More...</a><br /></td></tr>
<tr class="separator:a91f9d15ab461fecbffc39007716eefcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8064649970d3c5c0f906951a2cc1092d"><td class="memItemLeft" align="right" valign="top">idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a8064649970d3c5c0f906951a2cc1092d">get_segment_combination</a> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> comb)</td></tr>
<tr class="memdesc:a8064649970d3c5c0f906951a2cc1092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get text representation of segment combination code.  <a href="segment_8hpp.html#a8064649970d3c5c0f906951a2cc1092d">More...</a><br /></td></tr>
<tr class="separator:a8064649970d3c5c0f906951a2cc1092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa3f21e8091747f90c4aba53018db25"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a5aa3f21e8091747f90c4aba53018db25">get_segm_para</a> (const <a class="el" href="classsegment__t.html">segment_t</a> *s)</td></tr>
<tr class="memdesc:a5aa3f21e8091747f90c4aba53018db25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment base paragraph.  <a href="segment_8hpp.html#a5aa3f21e8091747f90c4aba53018db25">More...</a><br /></td></tr>
<tr class="separator:a5aa3f21e8091747f90c4aba53018db25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc3df3c526b319baa6e89f261796400"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a2dc3df3c526b319baa6e89f261796400">get_segm_base</a> (const <a class="el" href="classsegment__t.html">segment_t</a> *s)</td></tr>
<tr class="memdesc:a2dc3df3c526b319baa6e89f261796400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment base linear address.  <a href="segment_8hpp.html#a2dc3df3c526b319baa6e89f261796400">More...</a><br /></td></tr>
<tr class="separator:a2dc3df3c526b319baa6e89f261796400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f536b5ce889abea32a4aa7d50415fc"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8hpp.html#a25f536b5ce889abea32a4aa7d50415fc">set_segm_addressing</a> (<a class="el" href="classsegment__t.html">segment_t</a> *s, size_t bitness)</td></tr>
<tr class="memdesc:a25f536b5ce889abea32a4aa7d50415fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change segment addressing mode (16, 32, 64 bits).  <a href="segment_8hpp.html#a25f536b5ce889abea32a4aa7d50415fc">More...</a><br /></td></tr>
<tr class="separator:a25f536b5ce889abea32a4aa7d50415fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874ebd7096a79c963a3eaa7e1210c64a"><td class="memItemLeft" align="right" valign="top"><a id="a874ebd7096a79c963a3eaa7e1210c64a" name="a874ebd7096a79c963a3eaa7e1210c64a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_debugger_segm</b> (ea_t ea)</td></tr>
<tr class="memdesc:a874ebd7096a79c963a3eaa7e1210c64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the address belong to a debug segment? <br /></td></tr>
<tr class="separator:a874ebd7096a79c963a3eaa7e1210c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc0d9cfbf8cda312a07f001884959b3"><td class="memItemLeft" align="right" valign="top"><a id="a3cc0d9cfbf8cda312a07f001884959b3" name="a3cc0d9cfbf8cda312a07f001884959b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ephemeral_segm</b> (ea_t ea)</td></tr>
<tr class="memdesc:a3cc0d9cfbf8cda312a07f001884959b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the address belong to an ephemeral segment? <br /></td></tr>
<tr class="separator:a3cc0d9cfbf8cda312a07f001884959b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17eeb77aa800c7e063d95f87e93222cb"><td class="memItemLeft" align="right" valign="top"><a id="a17eeb77aa800c7e063d95f87e93222cb" name="a17eeb77aa800c7e063d95f87e93222cb"></a>
idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>correct_address</b> (ea_t ea, ea_t from, ea_t to, ea_t size, bool skip_check=false)</td></tr>
<tr class="separator:a17eeb77aa800c7e063d95f87e93222cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4464b4f207debe82fe447f2135a84312"><td class="memItemLeft" align="right" valign="top"><a id="a4464b4f207debe82fe447f2135a84312" name="a4464b4f207debe82fe447f2135a84312"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>update_segm</b> (<a class="el" href="classsegment__t.html">segment_t</a> *s)</td></tr>
<tr class="separator:a4464b4f207debe82fe447f2135a84312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cff39cba1cd5de91be3f3bc31d972a9"><td class="memItemLeft" align="right" valign="top"><a id="a9cff39cba1cd5de91be3f3bc31d972a9" name="a9cff39cba1cd5de91be3f3bc31d972a9"></a>
idaman adiff_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>segm_adjust_diff</b> (const <a class="el" href="classsegment__t.html">segment_t</a> *s, adiff_t delta)</td></tr>
<tr class="memdesc:a9cff39cba1cd5de91be3f3bc31d972a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate and sign extend a delta depending on the segment. <br /></td></tr>
<tr class="separator:a9cff39cba1cd5de91be3f3bc31d972a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe9cc92047ef647a56e5daff99b7b32"><td class="memItemLeft" align="right" valign="top"><a id="adbe9cc92047ef647a56e5daff99b7b32" name="adbe9cc92047ef647a56e5daff99b7b32"></a>
idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>segm_adjust_ea</b> (const <a class="el" href="classsegment__t.html">segment_t</a> *s, ea_t ea)</td></tr>
<tr class="memdesc:adbe9cc92047ef647a56e5daff99b7b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate an address depending on the segment. <br /></td></tr>
<tr class="separator:adbe9cc92047ef647a56e5daff99b7b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Functions that deal with segments. </p>
<p >IDA requires that all program addresses belong to segments (each address must belong to exactly one segment). The situation when an address doesn't belong to any segment is allowed as a temporary situation only when the user changes program segmentation. Bytes outside a segment can't be converted to instructions, have names, comments, etc. Each segment has its start address, ending address and represents a contiguous range of addresses. There might be unused holes between segments.</p>
<p >Each segment has its unique segment selector. This selector is used to distinguish the segment from other segments. For 16-bit programs the selector is equal to the segment base paragraph. For 32-bit programs there is special array to translate the selectors to the segment base paragraphs. A selector is a 32/64 bit value.</p>
<p >The segment base paragraph determines the offsets in the segment. If the start address of the segment == (base &lt;&lt; 4) then the first offset in the segment will be 0. The start address should be higher or equal to (base &lt;&lt; 4). We will call the offsets in the segment 'virtual addresses'. So, the virtual address of the first byte of the segment is</p>
<p >(start address of segment - segment base linear address)</p>
<p >For IBM PC, the virtual address corresponds to the offset part of the address. For other processors (Z80, for example), virtual addresses correspond to Z80 addresses and linear addresses are used only internally. For MS Windows programs the segment base paragraph is 0 and therefore the segment virtual addresses are equal to linear addresses. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aff7775baddfc01bf6179be9983462f10" name="aff7775baddfc01bf6179be9983462f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7775baddfc01bf6179be9983462f10">&#9670;&nbsp;</a></span>saRelDble</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define saRelDble&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relocatable, aligned on a double word (4-byte) boundary. </p>

</div>
</div>
<a id="a765c3364a1877c3a87d83e40322ba14f" name="a765c3364a1877c3a87d83e40322ba14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765c3364a1877c3a87d83e40322ba14f">&#9670;&nbsp;</a></span>saRel4K</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define saRel4K&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This value is used by the PharLap OMF for page (4K) alignment. </p>
<p >It is not supported by LINK. </p>

</div>
</div>
<a id="a38ed1a87ad2b2dd47313a29e07811dc4" name="a38ed1a87ad2b2dd47313a29e07811dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ed1a87ad2b2dd47313a29e07811dc4">&#9670;&nbsp;</a></span>scPriv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define scPriv&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Private. </p>
<p >Do not combine with any other program segment. </p>

</div>
</div>
<a id="aca4d1acba99d1b265076d884ba2ec250" name="aca4d1acba99d1b265076d884ba2ec250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4d1acba99d1b265076d884ba2ec250">&#9670;&nbsp;</a></span>scPub</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define scPub&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public. </p>
<p >Combine by appending at an offset that meets the alignment requirement. </p>

</div>
</div>
<a id="aeee8fe69cf688dc99b8baa848e3bec54" name="aeee8fe69cf688dc99b8baa848e3bec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee8fe69cf688dc99b8baa848e3bec54">&#9670;&nbsp;</a></span>scStack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define scStack&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack. </p>
<p >Combine as for C=2. This combine type forces byte alignment. </p>

</div>
</div>
<a id="a5c9bbede59653b945dacc70598306289" name="a5c9bbede59653b945dacc70598306289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9bbede59653b945dacc70598306289">&#9670;&nbsp;</a></span>SEG_XTRN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEG_XTRN&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>* segment with 'extern' definitions. </p>
<p >no instructions are allowed </p>

</div>
</div>
<a id="a5d6e405b6fb6faf18cc2c064ba592401" name="a5d6e405b6fb6faf18cc2c064ba592401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6e405b6fb6faf18cc2c064ba592401">&#9670;&nbsp;</a></span>ADDSEG_NOTRUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADDSEG_NOTRUNC&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>don't truncate the new segment at the beginning of the next segment if they overlap. </p>
<p >destroy/truncate old segments instead. </p>

</div>
</div>
<a id="ad1996026d4ee36dd29aeee83535c845d" name="ad1996026d4ee36dd29aeee83535c845d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1996026d4ee36dd29aeee83535c845d">&#9670;&nbsp;</a></span>ADDSEG_FILLGAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADDSEG_FILLGAP&#160;&#160;&#160;0x0010</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fill gap between new segment and previous one. </p>
<p >i.e. if such a gap exists, and this gap is less than 64K, then fill the gap by extending the previous segment and adding .align directive to it. This way we avoid gaps between segments. too many gaps lead to a virtual array failure. it cannot hold more than ~1000 gaps. </p>

</div>
</div>
<a id="aadc4d5db47a493aca1f9a9d3725d7651" name="aadc4d5db47a493aca1f9a9d3725d7651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc4d5db47a493aca1f9a9d3725d7651">&#9670;&nbsp;</a></span>ADDSEG_SPARSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADDSEG_SPARSE&#160;&#160;&#160;0x0020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use sparse storage method for the new ranges of the created segment. </p>
<p >please note that the ranges that were already enabled before creating the segment will not change their storage type. </p>

</div>
</div>
<a id="a89693134e1c29045c8c9a1b77f106813" name="a89693134e1c29045c8c9a1b77f106813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89693134e1c29045c8c9a1b77f106813">&#9670;&nbsp;</a></span>MSF_FIXONCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSF_FIXONCE&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call loader only once with the special calling method. </p>
<p >valid for <a class="el" href="segment_8hpp.html#addfcd63e80534616c4c6987100d6ea3a" title="Rebase the whole program by &#39;delta&#39; bytes.">rebase_program()</a>. see <a class="el" href="structloader__t.html#a7a329922101a4e28a2b7018e565a3b5d" title="Take care of a moved segment (fix up relocations, for example).">loader_t::move_segm</a>. </p>

</div>
</div>
<a id="a2c8b83720e61ef7c1cd29ea477ace306" name="a2c8b83720e61ef7c1cd29ea477ace306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8b83720e61ef7c1cd29ea477ace306">&#9670;&nbsp;</a></span>MSF_PRIORITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSF_PRIORITY&#160;&#160;&#160;0x0020</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>loader segments will overwrite any existing debugger segments when moved. </p>
<p >valid for <a class="el" href="segment_8hpp.html#adfbc36e396bf222ba1f2c278764b09ba" title="This function moves all information to the new address.">move_segm()</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a77847d21aeb16b4d7d0b132154bc072a" name="a77847d21aeb16b4d7d0b132154bc072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77847d21aeb16b4d7d0b132154bc072a">&#9670;&nbsp;</a></span>move_segm_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072a">move_segm_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa41abbdfceac6b1b1da9f8910042a9bc7" name="a77847d21aeb16b4d7d0b132154bc072aa41abbdfceac6b1b1da9f8910042a9bc7"></a>MOVE_SEGM_OK&#160;</td><td class="fielddoc"><p >all ok </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa3cc3b0dd4a54e7e68cfbf0ad7275df09" name="a77847d21aeb16b4d7d0b132154bc072aa3cc3b0dd4a54e7e68cfbf0ad7275df09"></a>MOVE_SEGM_PARAM&#160;</td><td class="fielddoc"><p >The specified segment does not exist. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa141e1d5f254a188935aa83ea8eab6fb4" name="a77847d21aeb16b4d7d0b132154bc072aa141e1d5f254a188935aa83ea8eab6fb4"></a>MOVE_SEGM_ROOM&#160;</td><td class="fielddoc"><p >Not enough free room at the target address. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa705ffca2afbcb048466a259c016133a4" name="a77847d21aeb16b4d7d0b132154bc072aa705ffca2afbcb048466a259c016133a4"></a>MOVE_SEGM_IDP&#160;</td><td class="fielddoc"><p >IDP module forbids moving the segment. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa996a84accfd653aabd6ba0a8c3e335d5" name="a77847d21aeb16b4d7d0b132154bc072aa996a84accfd653aabd6ba0a8c3e335d5"></a>MOVE_SEGM_CHUNK&#160;</td><td class="fielddoc"><p >Too many chunks are defined, can't move. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa058d7720ffcf8db7ef040cc45d310512" name="a77847d21aeb16b4d7d0b132154bc072aa058d7720ffcf8db7ef040cc45d310512"></a>MOVE_SEGM_LOADER&#160;</td><td class="fielddoc"><p >The segment has been moved but the loader complained. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aae1ef7c45622afe9644b8479823a7846e" name="a77847d21aeb16b4d7d0b132154bc072aae1ef7c45622afe9644b8479823a7846e"></a>MOVE_SEGM_ODD&#160;</td><td class="fielddoc"><p >Cannot move segments by an odd number of bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa63c7e1edc5565750331cff7ffdb4aaae" name="a77847d21aeb16b4d7d0b132154bc072aa63c7e1edc5565750331cff7ffdb4aaae"></a>MOVE_SEGM_ORPHAN&#160;</td><td class="fielddoc"><p >Orphan bytes hinder segment movement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aaebd19e78d2ca7b5e7ca7bb5cc3b6f14e" name="a77847d21aeb16b4d7d0b132154bc072aaebd19e78d2ca7b5e7ca7bb5cc3b6f14e"></a>MOVE_SEGM_DEBUG&#160;</td><td class="fielddoc"><p >Debugger segments cannot be moved. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aae71f72430df7438e54c8b96809e8272f" name="a77847d21aeb16b4d7d0b132154bc072aae71f72430df7438e54c8b96809e8272f"></a>MOVE_SEGM_SOURCEFILES&#160;</td><td class="fielddoc"><p >Source files ranges of addresses hinder segment movement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa00fef7358927202429527848c8e75702" name="a77847d21aeb16b4d7d0b132154bc072aa00fef7358927202429527848c8e75702"></a>MOVE_SEGM_MAPPING&#160;</td><td class="fielddoc"><p >Memory mapping ranges of addresses hinder segment movement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a77847d21aeb16b4d7d0b132154bc072aa972f723d6c7f84d065e21ffdd326294a" name="a77847d21aeb16b4d7d0b132154bc072aa972f723d6c7f84d065e21ffdd326294a"></a>MOVE_SEGM_INVAL&#160;</td><td class="fielddoc"><p >Invalid argument (delta/target does not fit the address space) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa20821d1751b3f47f92cc263e1552c7c" name="aa20821d1751b3f47f92cc263e1552c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20821d1751b3f47f92cc263e1552c7c">&#9670;&nbsp;</a></span>is_spec_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_spec_segm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>seg_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has segment a special type?. </p>
<p >(<a class="el" href="segment_8hpp.html#a5c9bbede59653b945dacc70598306289" title="* segment with &#39;extern&#39; definitions.">SEG_XTRN</a>, <a class="el" href="segment_8hpp.html#ab3bd0f97c65dd59b10ea76b16d444784" title="* group of segments">SEG_GRP</a>, <a class="el" href="segment_8hpp.html#a5c130d299e48ff537068e03e8ae23d71" title="* segment with definitions of absolute symbols">SEG_ABSSYM</a>, <a class="el" href="segment_8hpp.html#a39a39aa78e00ea21899571a2b636976e" title="* segment with communal definitions">SEG_COMM</a>) </p>

</div>
</div>
<a id="a80f10e64c09b833e76ca5f3b7954cc9d" name="a80f10e64c09b833e76ca5f3b7954cc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f10e64c09b833e76ca5f3b7954cc9d">&#9670;&nbsp;</a></span>is_spec_ea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_spec_ea </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the address belong to a segment with a special type?. </p>
<p >(<a class="el" href="segment_8hpp.html#a5c9bbede59653b945dacc70598306289" title="* segment with &#39;extern&#39; definitions.">SEG_XTRN</a>, <a class="el" href="segment_8hpp.html#ab3bd0f97c65dd59b10ea76b16d444784" title="* group of segments">SEG_GRP</a>, <a class="el" href="segment_8hpp.html#a5c130d299e48ff537068e03e8ae23d71" title="* segment with definitions of absolute symbols">SEG_ABSSYM</a>, <a class="el" href="segment_8hpp.html#a39a39aa78e00ea21899571a2b636976e" title="* segment with communal definitions">SEG_COMM</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63b6f6b1ceaff968314c9125a5206e60" name="a63b6f6b1ceaff968314c9125a5206e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b6f6b1ceaff968314c9125a5206e60">&#9670;&nbsp;</a></span>lock_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export lock_segm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>segm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock segment pointer Locked pointers are guaranteed to remain valid until they are unlocked. </p>
<p >Ranges with locked pointers cannot be deleted or moved. </p>

</div>
</div>
<a id="a95b819f125c442c7476c1a844cee22d5" name="a95b819f125c442c7476c1a844cee22d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b819f125c442c7476c1a844cee22d5">&#9670;&nbsp;</a></span>setup_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman sel_t ida_export setup_selector </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>segbase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a selector for a segment if necessary. </p>
<p >You must call this function before calling <a class="el" href="segment_8hpp.html#aa38d0afa3faaa85ce63da0a69882bc60" title="Add a new segment.">add_segm_ex()</a>. <a class="el" href="segment_8hpp.html#a59f6ee9677c2605aeac9541e38e54025" title="Add a new segment, second form.">add_segm()</a> calls this function itself, so you don't need to allocate a selector. This function will allocate a selector if 'segbase' requires more than 16 bits and the current processor is IBM PC. Otherwise it will return the segbase value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segbase</td><td>a new segment base paragraph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the allocated selector number </dd></dl>

</div>
</div>
<a id="a0bc493dc34c0cc8268be321fc89a72fd" name="a0bc493dc34c0cc8268be321fc89a72fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc493dc34c0cc8268be321fc89a72fd">&#9670;&nbsp;</a></span>allocate_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman sel_t ida_export allocate_selector </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>segbase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a selector for a segment unconditionally. </p>
<p >You must call this function before calling <a class="el" href="segment_8hpp.html#aa38d0afa3faaa85ce63da0a69882bc60" title="Add a new segment.">add_segm_ex()</a>. <a class="el" href="segment_8hpp.html#a59f6ee9677c2605aeac9541e38e54025" title="Add a new segment, second form.">add_segm()</a> calls this function itself, so you don't need to allocate a selector. This function will allocate a new free selector and setup its mapping using <a class="el" href="segment_8hpp.html#ae9d8d263928e1700026ab15eabf10480" title="Find first unused selector.">find_free_selector()</a> and <a class="el" href="segment_8hpp.html#aee421bd585e301aea9452c84ac735c6a" title="Set mapping of selector to a paragraph.">set_selector()</a> functions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segbase</td><td>a new segment base paragraph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the allocated selector number </dd></dl>

</div>
</div>
<a id="ae9d8d263928e1700026ab15eabf10480" name="ae9d8d263928e1700026ab15eabf10480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d8d263928e1700026ab15eabf10480">&#9670;&nbsp;</a></span>find_free_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman sel_t ida_export find_free_selector </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find first unused selector. </p>
<dl class="section return"><dt>Returns</dt><dd>a number &gt;= 1 </dd></dl>

</div>
</div>
<a id="aee421bd585e301aea9452c84ac735c6a" name="aee421bd585e301aea9452c84ac735c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee421bd585e301aea9452c84ac735c6a">&#9670;&nbsp;</a></span>set_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export set_selector </td>
          <td>(</td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>paragraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set mapping of selector to a paragraph. </p>
<p >You should call this function _before_ creating a segment which uses the selector, otherwise the creation of the segment will fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>number of selector to map<ul>
<li>if selector == <a class="el" href="pro_8h.html#a893ddf307fae0a3bbca667ee917cddc7" title="&#39;bad selector&#39; value">BADSEL</a>, then return 0 (fail)</li>
<li>if the selector has had a mapping, old mapping is destroyed</li>
<li>if the selector number is equal to paragraph value, then the mapping is destroyed because we don't need to keep trivial mappings. </li>
</ul>
</td></tr>
    <tr><td class="paramname">paragraph</td><td>paragraph to map selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failure (bad selector or too many mappings) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30f786fe1f285b2a2df2c7c6a18d57a9" name="a30f786fe1f285b2a2df2c7c6a18d57a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f786fe1f285b2a2df2c7c6a18d57a9">&#9670;&nbsp;</a></span>del_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export del_selector </td>
          <td>(</td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete mapping of a selector. </p>
<p >Be wary of deleting selectors that are being used in the program, this can make a mess in the segments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>number of selector to remove from the translation table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8416e3237013eadfd32dfafc87953e3c" name="a8416e3237013eadfd32dfafc87953e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8416e3237013eadfd32dfafc87953e3c">&#9670;&nbsp;</a></span>sel2para()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export sel2para </td>
          <td>(</td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get mapping of a selector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>number of selector to translate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>paragraph the specified selector is mapped to. if there is no mapping, returns 'selector'. </dd></dl>

</div>
</div>
<a id="a0bf8f3ddf2be4616b37609bf3d302c8e" name="a0bf8f3ddf2be4616b37609bf3d302c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf8f3ddf2be4616b37609bf3d302c8e">&#9670;&nbsp;</a></span>sel2ea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ea_t idaapi sel2ea </td>
          <td>(</td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get mapping of a selector as a linear address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>number of selector to translate to linear address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear address the specified selector is mapped to. if there is no mapping, returns to_ea(selector,0); </dd></dl>

</div>
</div>
<a id="af4a5a8ead1db6a02fe332395bb0f1e25" name="af4a5a8ead1db6a02fe332395bb0f1e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a5a8ead1db6a02fe332395bb0f1e25">&#9670;&nbsp;</a></span>find_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman sel_t ida_export find_selector </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a selector that has mapping to the specified paragraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>paragraph to search in the translation table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>selector value or base </dd></dl>

</div>
</div>
<a id="a6e6e924cc3dd3971f5576a4569afc3c7" name="a6e6e924cc3dd3971f5576a4569afc3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6e924cc3dd3971f5576a4569afc3c7">&#9670;&nbsp;</a></span>enumerate_selectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export enumerate_selectors </td>
          <td>(</td>
          <td class="paramtype">int(idaapi *)(sel_t sel, ea_t para)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all selectors from the translation table. </p>
<p >This function calls 'func' for each selector in the translation table. If 'func' returns non-zero code, enumeration is stopped and this code is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>callback function<ul>
<li>sel: selector number</li>
<li>para: selector mapping </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or code returned by 'func'. </dd></dl>

</div>
</div>
<a id="a3e4e1add83a761fa1d74c87aee963aa7" name="a3e4e1add83a761fa1d74c87aee963aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4e1add83a761fa1d74c87aee963aa7">&#9670;&nbsp;</a></span>enumerate_segments_with_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export enumerate_segments_with_selector </td>
          <td>(</td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t(idaapi *)(<a class="el" href="classsegment__t.html">segment_t</a> *s, void *ud)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ud</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all segments with the specified selector. </p>
<p >This function will call the callback function 'func' for each segment that has the specified selector. Enumeration starts from the last segment and stops at the first segment (reverse order). If the callback function 'func' returns a value != <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>, the enumeration is stopped and this value is returned to the caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>segments that have this selector are enumerated </td></tr>
    <tr><td class="paramname">func</td><td>callback function<ul>
<li>s: pointer to segment structure</li>
<li>ud: user data </li>
</ul>
</td></tr>
    <tr><td class="paramname">ud</td><td>pointer to user data. this pointer will be passed to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> or the value returned by the callback function 'func' </dd></dl>

</div>
</div>
<a id="a2e10a0ce567121fdb3748886228de7bf" name="a2e10a0ce567121fdb3748886228de7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e10a0ce567121fdb3748886228de7bf">&#9670;&nbsp;</a></span>get_segm_by_sel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export get_segm_by_sel </td>
          <td>(</td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to segment structure. </p>
<p >This function finds a segment by its selector. If there are several segments with the same selectors, the last one will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>a segment with the specified selector will be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to segment or nullptr </dd></dl>

</div>
</div>
<a id="aa38d0afa3faaa85ce63da0a69882bc60" name="aa38d0afa3faaa85ce63da0a69882bc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38d0afa3faaa85ce63da0a69882bc60">&#9670;&nbsp;</a></span>add_segm_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_segm_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *NONNULL&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new segment. </p>
<p >If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to filled segment structure. segment selector should have proper mapping (see <a class="el" href="segment_8hpp.html#aee421bd585e301aea9452c84ac735c6a" title="Set mapping of selector to a paragraph.">set_selector()</a>).<ul>
<li>if s.start_ea==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> then s.start_ea &lt;- get_segm_base(&amp;s)</li>
<li>if s.end_ea==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>, then a segment up to the next segment will be created (if the next segment doesn't exist, then 1 byte segment will be created).</li>
<li>if the s.end_ea &lt; s.start_ea, then fail.</li>
<li>if s.end_ea is too high and the new segment would overlap the next segment, s.end_ea is adjusted properly. </li>
</ul>
</td></tr>
    <tr><td class="paramname">name</td><td>name of new segment. may be nullptr. if specified, the segment is immediately renamed </td></tr>
    <tr><td class="paramname">sclass</td><td>class of the segment. may be nullptr. if specified, the segment class is immediately changed </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___a_d_d_s_e_g__.html">Add segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59f6ee9677c2605aeac9541e38e54025" name="a59f6ee9677c2605aeac9541e38e54025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f6ee9677c2605aeac9541e38e54025">&#9670;&nbsp;</a></span>add_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_segm </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>para</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new segment, second form. </p>
<p >Segment alignment is set to <a class="el" href="segment_8hpp.html#a0aecfd12e64028f0712d6cad0403b66b" title="Relocatable, byte aligned.">saRelByte</a>. Segment combination is "public" or "stack" (if segment class is "STACK"). Addressing mode of segment is taken as default (16bit or 32bit). Default segment registers are set to <a class="el" href="pro_8h.html#a893ddf307fae0a3bbca667ee917cddc7" title="&#39;bad selector&#39; value">BADSEL</a>. If a segment already exists at the specified range of addresses, this segment will be truncated. Instructions and data in the old segment will be deleted if the new segment has another addressing mode or another segment base address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">para</td><td>segment base paragraph. if paragraph can't fit in 16bit, then a new selector is allocated and mapped to the paragraph. </td></tr>
    <tr><td class="paramname">start</td><td>start address of the segment. if start==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> then start &lt;- to_ea(para,0). </td></tr>
    <tr><td class="paramname">end</td><td>end address of the segment. end address should be higher than start address. For emulate empty segments, use <a class="el" href="segment_8hpp.html#a594f82f31d1ed7189ad21c3af3279269" title="zero-length segment">SEG_NULL</a> segment type. If the end address is lower than start address, then fail. If end==<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>, then a segment up to the next segment will be created (if the next segment doesn't exist, then 1 byte segment will be created). If 'end' is too high and the new segment would overlap the next segment, 'end' is adjusted properly. </td></tr>
    <tr><td class="paramname">name</td><td>name of new segment. may be nullptr </td></tr>
    <tr><td class="paramname">sclass</td><td>class of the segment. may be nullptr. type of the new segment is modified if class is one of predefined names:<ul>
<li>"CODE" -&gt; <a class="el" href="segment_8hpp.html#acfc10101b1288e858b747c0a9c329226" title="code segment">SEG_CODE</a></li>
<li>"DATA" -&gt; <a class="el" href="segment_8hpp.html#a9f583dca1a7fef2948458048c70b2f1c" title="data segment">SEG_DATA</a></li>
<li>"CONST" -&gt; <a class="el" href="segment_8hpp.html#a9f583dca1a7fef2948458048c70b2f1c" title="data segment">SEG_DATA</a></li>
<li>"STACK" -&gt; <a class="el" href="segment_8hpp.html#a0e7d8517210b3c56679eca1111e4c0fc" title="uninitialized segment">SEG_BSS</a></li>
<li>"BSS" -&gt; <a class="el" href="segment_8hpp.html#a0e7d8517210b3c56679eca1111e4c0fc" title="uninitialized segment">SEG_BSS</a></li>
<li>"XTRN" -&gt; <a class="el" href="segment_8hpp.html#a5c9bbede59653b945dacc70598306289" title="* segment with &#39;extern&#39; definitions.">SEG_XTRN</a></li>
<li>"COMM" -&gt; <a class="el" href="segment_8hpp.html#a39a39aa78e00ea21899571a2b636976e" title="* segment with communal definitions">SEG_COMM</a></li>
<li>"ABS" -&gt; <a class="el" href="segment_8hpp.html#a5c130d299e48ff537068e03e8ae23d71" title="* segment with definitions of absolute symbols">SEG_ABSSYM</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___a_d_d_s_e_g__.html">Add segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abebbd185abaf370753d5ea59d32d9985" name="abebbd185abaf370753d5ea59d32d9985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebbd185abaf370753d5ea59d32d9985">&#9670;&nbsp;</a></span>del_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export del_segm </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address belonging to the segment </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_e_g_m_o_d__.html">Segment modification flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, no segment at 'ea'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab56c8c4cfc5b232ee2580d86671d96f8" name="ab56c8c4cfc5b232ee2580d86671d96f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56c8c4cfc5b232ee2580d86671d96f8">&#9670;&nbsp;</a></span>getseg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export getseg </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to segment by linear address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address belonging to the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr or pointer to segment structure </dd></dl>

</div>
</div>
<a id="ab562913860bdc24ddfdf45e5203b131c" name="ab562913860bdc24ddfdf45e5203b131c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab562913860bdc24ddfdf45e5203b131c">&#9670;&nbsp;</a></span>getnseg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export getnseg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to segment by its number. </p>
<dl class="section warning"><dt>Warning</dt><dd>Obsoleted because it can slow down the debugger (it has to refresh the whole memory segmentation to calculate the correct answer) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>segment number in the range (0..<a class="el" href="segment_8hpp.html#a9e848ee2505a32634309a914195fe141" title="Get number of segments.">get_segm_qty()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr or pointer to segment structure </dd></dl>

</div>
</div>
<a id="ab73fd60fa5ec55b12441ecbf3224f742" name="ab73fd60fa5ec55b12441ecbf3224f742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73fd60fa5ec55b12441ecbf3224f742">&#9670;&nbsp;</a></span>get_segm_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_segm_num </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of segment by address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address belonging to the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if no segment occupies the specified address. otherwise returns number of the specified segment (0..<a class="el" href="segment_8hpp.html#a9e848ee2505a32634309a914195fe141" title="Get number of segments.">get_segm_qty()</a>-1) </dd></dl>

</div>
</div>
<a id="a7086a4321f2d301b27edc9ec4960370d" name="a7086a4321f2d301b27edc9ec4960370d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7086a4321f2d301b27edc9ec4960370d">&#9670;&nbsp;</a></span>get_segm_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="classsegment__t.html">segment_t</a> *ida_export get_segm_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to segment by its name. </p>
<p >If there are several segments with the same name, returns the first of them. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>segment name. may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr or pointer to segment structure </dd></dl>

</div>
</div>
<a id="aadde01303718a6cde673dca12ffac9d7" name="aadde01303718a6cde673dca12ffac9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadde01303718a6cde673dca12ffac9d7">&#9670;&nbsp;</a></span>set_segm_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_segm_end </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>newend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set segment end address. </p>
<p >The next segment is shrinked to allow expansion of the specified segment. The kernel might even delete the next segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address belonging to the segment </td></tr>
    <tr><td class="paramname">newend</td><td>new end address of the segment </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_e_g_m_o_d__.html">Segment modification flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affcd6c25a6d3bfc4bafeb786db81ec79" name="affcd6c25a6d3bfc4bafeb786db81ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcd6c25a6d3bfc4bafeb786db81ec79">&#9670;&nbsp;</a></span>set_segm_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_segm_start </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>newstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set segment start address. </p>
<p >The previous segment is trimmed to allow expansion of the specified segment. The kernel might even delete the previous segment if necessary. The kernel will ask the user for a permission to destroy instructions or data going out of segment scope if such instructions exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address belonging to the segment </td></tr>
    <tr><td class="paramname">newstart</td><td>new start address of the segment note that segment start address should be higher than segment base linear address. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_e_g_m_o_d__.html">Segment modification flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa93c02cc5dccb84dc5d302dc8dcf67dc" name="aa93c02cc5dccb84dc5d302dc8dcf67dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93c02cc5dccb84dc5d302dc8dcf67dc">&#9670;&nbsp;</a></span>move_segm_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export move_segm_start </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>newstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move segment start. </p>
<p >The main difference between this function and <a class="el" href="segment_8hpp.html#affcd6c25a6d3bfc4bafeb786db81ec79" title="Set segment start address.">set_segm_start()</a> is that this function may expand the previous segment while <a class="el" href="segment_8hpp.html#affcd6c25a6d3bfc4bafeb786db81ec79" title="Set segment start address.">set_segm_start()</a> never does it. So, this function allows to change bounds of two segments simultaneously. If the previous segment and the specified segment have the same addressing mode and segment base, then instructions and data are not destroyed - they simply move from one segment to another. Otherwise all instructions/data which migrate from one segment to another are destroyed. </p><dl class="section note"><dt>Note</dt><dd>this function never disables addresses. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any address belonging to the segment </td></tr>
    <tr><td class="paramname">newstart</td><td>new start address of the segment note that segment start address should be higher than segment base linear address. </td></tr>
    <tr><td class="paramname">mode</td><td>policy for destroying defined items<ul>
<li>0: if it is necessary to destroy defined items, display a dialog box and ask confirmation</li>
<li>1: if it is necessary to destroy defined items, just destroy them without asking the user</li>
<li>-1: if it is necessary to destroy defined items, don't destroy them (i.e. function will fail)</li>
<li>-2: don't destroy defined items (function will succeed) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed, a warning message is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfbc36e396bf222ba1f2c278764b09ba" name="adfbc36e396bf222ba1f2c278764b09ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbc36e396bf222ba1f2c278764b09ba">&#9670;&nbsp;</a></span>move_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072a">move_segm_code_t</a> ida_export move_segm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function moves all information to the new address. </p>
<p >It fixes up address sensitive information in the kernel. The total effect is equal to reloading the segment to the target address. For the file format dependent address sensitive information, <a class="el" href="structloader__t.html#a7a329922101a4e28a2b7018e565a3b5d" title="Take care of a moved segment (fix up relocations, for example).">loader_t::move_segm</a> is called. Also IDB notification event <a class="el" href="namespaceidb__event.html#a0feb6e648b4e6e3f0ed954abea672784a9462c0eec099edd1bb2f0d7e65acf2e5" title="Segment has been moved.">idb_event::segm_moved</a> is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>segment to move </td></tr>
    <tr><td class="paramname">to</td><td>new segment start address </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___m_s_f__.html">Move segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___m_o_v_e___s_e_g_m__.html">Move segment result codes</a> </dd></dl>

</div>
</div>
<a id="addfcd63e80534616c4c6987100d6ea3a" name="addfcd63e80534616c4c6987100d6ea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfcd63e80534616c4c6987100d6ea3a">&#9670;&nbsp;</a></span>rebase_program()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="segment_8hpp.html#a77847d21aeb16b4d7d0b132154bc072a">move_segm_code_t</a> ida_export rebase_program </td>
          <td>(</td>
          <td class="paramtype">adiff_t&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rebase the whole program by 'delta' bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>number of bytes to move the program </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___m_s_f__.html">Move segment flags</a> it is recommended to use <a class="el" href="segment_8hpp.html#a89693134e1c29045c8c9a1b77f106813" title="call loader only once with the special calling method.">MSF_FIXONCE</a> so that the loader takes care of global variables it stored in the database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___m_o_v_e___s_e_g_m__.html">Move segment result codes</a> </dd></dl>

</div>
</div>
<a id="a4ad15e77b3eb0f53f1b5083aa0c3a70b" name="a4ad15e77b3eb0f53f1b5083aa0c3a70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad15e77b3eb0f53f1b5083aa0c3a70b">&#9670;&nbsp;</a></span>change_segment_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export change_segment_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_deb_segm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a debugger segment to a regular segment and vice versa. </p>
<p >When converting debug-&gt;regular, the memory contents will be copied to the database. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>segment to modify </td></tr>
    <tr><td class="paramname">is_deb_segm</td><td>new status of the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___c_s_s__.html">Change segment status result codes</a> </dd></dl>

</div>
</div>
<a id="aacfec844a1b815af3e425d8e2144bea7" name="aacfec844a1b815af3e425d8e2144bea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfec844a1b815af3e425d8e2144bea7">&#9670;&nbsp;</a></span>take_memory_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export take_memory_snapshot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a memory snapshot of the running process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specifies which snapshot we want (see SNAP_ Snapshot types) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="ac6e9fffcb08d5be5a4d94b5f30a84be2" name="ac6e9fffcb08d5be5a4d94b5f30a84be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e9fffcb08d5be5a4d94b5f30a84be2">&#9670;&nbsp;</a></span>is_miniidb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_miniidb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the database a miniidb created by the debugger?. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the database contains no segments or only debugger segments </dd></dl>

</div>
</div>
<a id="ac0011ca67788905ff2b401b3376f8802" name="ac0011ca67788905ff2b401b3376f8802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0011ca67788905ff2b401b3376f8802">&#9670;&nbsp;</a></span>set_group_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export set_group_selector </td>
          <td>(</td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new group of segments (used OMF files). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp</td><td>selector of group segment (segment type is <a class="el" href="segment_8hpp.html#ab3bd0f97c65dd59b10ea76b16d444784" title="* group of segments">SEG_GRP</a>) You should create an 'empty' (1 byte) group segment It won't contain anything and will be used to redirect references to the group of segments to the common selector. </td></tr>
    <tr><td class="paramname">sel</td><td>common selector of all segments belonging to the segment You should create all segments within the group with the same selector value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 ok </dd>
<dd>
0 too many groups (see <a class="el" href="segment_8hpp.html#a36d20ba74425036fd66f863bb89adeda" title="max number of segment groups">MAX_GROUPS</a>) </dd></dl>

</div>
</div>
<a id="a38dfb9e4396914c0118978a77897c427" name="a38dfb9e4396914c0118978a77897c427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dfb9e4396914c0118978a77897c427">&#9670;&nbsp;</a></span>get_group_selector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman sel_t ida_export get_group_selector </td>
          <td>(</td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>grpsel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get common selector for a group of segments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grpsel</td><td>selector of group segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>common selector of the group or 'grpsel' if no such group is found </dd></dl>

</div>
</div>
<a id="a162acfa28de46b3afb2aba0639f7f0a8" name="a162acfa28de46b3afb2aba0639f7f0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162acfa28de46b3afb2aba0639f7f0a8">&#9670;&nbsp;</a></span>add_segment_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export add_segment_translation </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>segstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>mappedseg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add segment translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segstart</td><td>start address of the segment to add translation to </td></tr>
    <tr><td class="paramname">mappedseg</td><td>start address of the overlayed segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>too many translations or bad segstart </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77b4d9ab9a809f3ae2e12ea7ef285576" name="a77b4d9ab9a809f3ae2e12ea7ef285576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b4d9ab9a809f3ae2e12ea7ef285576">&#9670;&nbsp;</a></span>set_segment_translations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_segment_translations </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>segstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>transmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set new translation list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segstart</td><td>start address of the segment to add translation to </td></tr>
    <tr><td class="paramname">transmap</td><td>vector of segment start addresses for the translation list. If transmap is empty, the translation list is deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>too many translations or bad segstart </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18d43bfa417e11caee34c45ff3ca5288" name="a18d43bfa417e11caee34c45ff3ca5288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d43bfa417e11caee34c45ff3ca5288">&#9670;&nbsp;</a></span>del_segment_translations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export del_segment_translations </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>segstart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the translation list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segstart</td><td>start address of the segment to delete translation list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a546786583c25f26b1477f83df2d35fa2" name="a546786583c25f26b1477f83df2d35fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546786583c25f26b1477f83df2d35fa2">&#9670;&nbsp;</a></span>get_segment_translations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_segment_translations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4">eavec_t</a> *&#160;</td>
          <td class="paramname"><em>transmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>segstart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get segment translation list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transmap</td><td>vector of segment start addresses for the translation list </td></tr>
    <tr><td class="paramname">segstart</td><td>start address of the segment to get information about </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if no translation list or bad segstart. otherwise returns size of translation list. </dd></dl>

</div>
</div>
<a id="aa055ce0d55f0949d6f907a584e1ec65d" name="aa055ce0d55f0949d6f907a584e1ec65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa055ce0d55f0949d6f907a584e1ec65d">&#9670;&nbsp;</a></span>get_segment_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_segment_cmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeatable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get segment comment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer for the comment </td></tr>
    <tr><td class="paramname">s</td><td>pointer to segment structure </td></tr>
    <tr><td class="paramname">repeatable</td><td>0: get regular comment. 1: get repeatable comment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of comment or -1 </dd></dl>

</div>
</div>
<a id="a092e05e64ba60bc29bb90cfdd03f05f8" name="a092e05e64ba60bc29bb90cfdd03f05f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092e05e64ba60bc29bb90cfdd03f05f8">&#9670;&nbsp;</a></span>set_segment_cmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export set_segment_cmt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeatable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set segment comment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to segment structure </td></tr>
    <tr><td class="paramname">cmt</td><td>comment string, may be multiline (with '<br  />
'). maximal size is 4096 bytes. Use empty str ("") to delete comment </td></tr>
    <tr><td class="paramname">repeatable</td><td>0: set regular comment. 1: set repeatable comment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7510d346be798cbe9bb08305ee964e5" name="aa7510d346be798cbe9bb08305ee964e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7510d346be798cbe9bb08305ee964e5">&#9670;&nbsp;</a></span>std_out_segm_footer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export std_out_segm_footer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structoutctx__t.html">outctx_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>seg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate segment footer line as a comment line. </p>
<p >This function may be used in IDP modules to generate segment footer if the target assembler doesn't have 'ends' directive. </p>

</div>
</div>
<a id="a3d5103bc9a9467bf76955237678ebe1a" name="a3d5103bc9a9467bf76955237678ebe1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5103bc9a9467bf76955237678ebe1a">&#9670;&nbsp;</a></span>set_segm_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export set_segm_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename segment. </p>
<p >The new name is validated (see validate_name). A segment always has a name. If you hadn't specified a name, the kernel will assign it "seg###" name where ### is segment number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to segment (may be nullptr) </td></tr>
    <tr><td class="paramname">name</td><td>new segment name </td></tr>
    <tr><td class="paramname">flags</td><td>ADDSEG_IDBENC or 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok, name is good and segment is renamed </td></tr>
    <tr><td class="paramname">0</td><td>failure, name is bad or segment is nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a338226d1af237de04e3ca6c941560afe" name="a338226d1af237de04e3ca6c941560afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338226d1af237de04e3ca6c941560afe">&#9670;&nbsp;</a></span>get_segm_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_segm_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get true segment name by pointer to segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer. cannot be nullptr </td></tr>
    <tr><td class="paramname">s</td><td>pointer to segment </td></tr>
    <tr><td class="paramname">flags</td><td>0-return name as is; 1-substitute bad symbols with _ 1 corresponds to GN_VISIBLE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of segment name (-1 if s==nullptr) </dd></dl>

</div>
</div>
<a id="a9664611338c9701b54dd1f0e4915a7d9" name="a9664611338c9701b54dd1f0e4915a7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9664611338c9701b54dd1f0e4915a7d9">&#9670;&nbsp;</a></span>get_visible_segm_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi get_visible_segm_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get segment name by pointer to segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer. cannot be nullptr </td></tr>
    <tr><td class="paramname">s</td><td>pointer to segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of segment name (-1 if s==nullptr) </dd></dl>

</div>
</div>
<a id="afbbbb4017cfa20f887d0b6f0fe01693f" name="afbbbb4017cfa20f887d0b6f0fe01693f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbbb4017cfa20f887d0b6f0fe01693f">&#9670;&nbsp;</a></span>get_segm_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> get_segm_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sel_t&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get colored segment name expression in the form (segname + displacement). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer to hold segment expression </td></tr>
    <tr><td class="paramname">from</td><td>linear address of instruction operand or data referring to the name. This address will be used to get fixup information, so it should point to exact position of operand in the instruction. </td></tr>
    <tr><td class="paramname">sel</td><td>value to convert to segment expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of segment expression or -1 </dd></dl>

</div>
</div>
<a id="a6fd2a886a9bee23b3f9746d4e618ead2" name="a6fd2a886a9bee23b3f9746d4e618ead2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd2a886a9bee23b3f9746d4e618ead2">&#9670;&nbsp;</a></span>get_segm_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_segm_class </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get segment class. </p>
<p >Segment class is arbitrary text (max 8 characters). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>output buffer. cannot be nullptr. </td></tr>
    <tr><td class="paramname">s</td><td>pointer to segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of segment class (-1 if s==nullptr or bufsize&lt;=0) </dd></dl>

</div>
</div>
<a id="a3053ee105dd0c1201b7cb5ad2feb963d" name="a3053ee105dd0c1201b7cb5ad2feb963d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3053ee105dd0c1201b7cb5ad2feb963d">&#9670;&nbsp;</a></span>set_segm_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export set_segm_class </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sclass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set segment class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to segment (may be nullptr) </td></tr>
    <tr><td class="paramname">sclass</td><td>segment class (may be nullptr). If segment type is <a class="el" href="segment_8hpp.html#a8743c2828565f269e2e28c131abdc4ff" title="unknown type, no assumptions">SEG_NORM</a> and segment class is one of predefined names, then segment type is changed to:<ul>
<li>"CODE" -&gt; <a class="el" href="segment_8hpp.html#acfc10101b1288e858b747c0a9c329226" title="code segment">SEG_CODE</a></li>
<li>"DATA" -&gt; <a class="el" href="segment_8hpp.html#a9f583dca1a7fef2948458048c70b2f1c" title="data segment">SEG_DATA</a></li>
<li>"STACK" -&gt; <a class="el" href="segment_8hpp.html#a0e7d8517210b3c56679eca1111e4c0fc" title="uninitialized segment">SEG_BSS</a></li>
<li>"BSS" -&gt; <a class="el" href="segment_8hpp.html#a0e7d8517210b3c56679eca1111e4c0fc" title="uninitialized segment">SEG_BSS</a></li>
<li>if "UNK" then segment type is reset to <a class="el" href="segment_8hpp.html#a8743c2828565f269e2e28c131abdc4ff" title="unknown type, no assumptions">SEG_NORM</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___a_d_d_s_e_g__.html">Add segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok, name is good and segment is renamed </td></tr>
    <tr><td class="paramname">0</td><td>failure, name is nullptr or bad or segment is nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67eaaed66c079e1ac389902d19046d20" name="a67eaaed66c079e1ac389902d19046d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67eaaed66c079e1ac389902d19046d20">&#9670;&nbsp;</a></span>segtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> ida_export segtype </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get segment type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>any linear address within the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___s_e_g__.html">Segment types</a>, <a class="el" href="segment_8hpp.html#a344b3516eb098ebe8ce00e193af53270" title="undefined segment type (not used)">SEG_UNDF</a> if no segment found at 'ea' </dd></dl>

</div>
</div>
<a id="a91f9d15ab461fecbffc39007716eefcd" name="a91f9d15ab461fecbffc39007716eefcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f9d15ab461fecbffc39007716eefcd">&#9670;&nbsp;</a></span>get_segment_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const char *ida_export get_segment_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>align</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get text representation of segment alignment code. </p>
<dl class="section return"><dt>Returns</dt><dd>text digestable by IBM PC assembler. </dd></dl>

</div>
</div>
<a id="a8064649970d3c5c0f906951a2cc1092d" name="a8064649970d3c5c0f906951a2cc1092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8064649970d3c5c0f906951a2cc1092d">&#9670;&nbsp;</a></span>get_segment_combination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman const char *ida_export get_segment_combination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td>
          <td class="paramname"><em>comb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get text representation of segment combination code. </p>
<dl class="section return"><dt>Returns</dt><dd>text digestable by IBM PC assembler. </dd></dl>

</div>
</div>
<a id="a5aa3f21e8091747f90c4aba53018db25" name="a5aa3f21e8091747f90c4aba53018db25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa3f21e8091747f90c4aba53018db25">&#9670;&nbsp;</a></span>get_segm_para()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_segm_para </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get segment base paragraph. </p>
<p >Segment base paragraph may be converted to segment base linear address using <a class="el" href="ida_8hpp.html#adc120ab54f6510cdb72799c4f919d874" title="Convert (sel,off) value to a linear address.">to_ea()</a> function. In fact, to_ea(get_segm_para(s), 0) == get_segm_base(s). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if s == nullptr, the segment base paragraph </dd></dl>

</div>
</div>
<a id="a2dc3df3c526b319baa6e89f261796400" name="a2dc3df3c526b319baa6e89f261796400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc3df3c526b319baa6e89f261796400">&#9670;&nbsp;</a></span>get_segm_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_segm_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get segment base linear address. </p>
<p >Segment base linear address is used to calculate virtual addresses. The virtual address of the first byte of the segment will be (start address of segment - segment base linear address) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if s == nullptr, otherwise segment base linear address </dd></dl>

</div>
</div>
<a id="a25f536b5ce889abea32a4aa7d50415fc" name="a25f536b5ce889abea32a4aa7d50415fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f536b5ce889abea32a4aa7d50415fc">&#9670;&nbsp;</a></span>set_segm_addressing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_segm_addressing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsegment__t.html">segment_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change segment addressing mode (16, 32, 64 bits). </p>
<p >You must use this function to change segment addressing, never change the 'bitness' field directly. This function will delete all instructions, comments and names in the segment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>pointer to segment </td></tr>
    <tr><td class="paramname">bitness</td><td>new addressing mode of segment<ul>
<li>2: 64bit segment</li>
<li>1: 32bit segment</li>
<li>0: 16bit segment </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
