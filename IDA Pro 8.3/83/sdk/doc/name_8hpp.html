<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDA SDK: name.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">name.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions that deal with names.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgetname__info__t.html">getname_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional information for <a class="el" href="name_8hpp.html#a12648107028fb2927759f78edc8b3e7a" title="Get name at the specified address.">get_ea_name()</a> function.  <a href="structgetname__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structea__name__t.html">ea_name_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ea, name pair  <a href="structea__name__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a56739a38cf3fb0c5d7d842fe94f96f86"><td class="memItemLeft" align="right" valign="top"><a id="a56739a38cf3fb0c5d7d842fe94f96f86" name="a56739a38cf3fb0c5d7d842fe94f96f86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAXNAMELEN</b>&#160;&#160;&#160;512</td></tr>
<tr class="memdesc:a56739a38cf3fb0c5d7d842fe94f96f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of a name in IDA (with the trailing zero) <br /></td></tr>
<tr class="separator:a56739a38cf3fb0c5d7d842fe94f96f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d81345c315a8aeedfdf7fc00496d395"><td class="memItemLeft" align="right" valign="top"><a id="a9d81345c315a8aeedfdf7fc00496d395" name="a9d81345c315a8aeedfdf7fc00496d395"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FUNC_IMPORT_PREFIX</b>&#160;&#160;&#160;&quot;__imp_&quot;</td></tr>
<tr class="memdesc:a9d81345c315a8aeedfdf7fc00496d395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name prefix used by IDA for the imported functions. <br /></td></tr>
<tr class="separator:a9d81345c315a8aeedfdf7fc00496d395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1458a641d26514c3464c986b74d003aa"><td class="memItemLeft" align="right" valign="top"><a id="a1458a641d26514c3464c986b74d003aa" name="a1458a641d26514c3464c986b74d003aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_CHECK</b>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:a1458a641d26514c3464c986b74d003aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fail if the name contains invalid characters. <br /></td></tr>
<tr class="separator:a1458a641d26514c3464c986b74d003aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7882b24fb8463d16e80274851e0e203"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#ad7882b24fb8463d16e80274851e0e203">SN_NOCHECK</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ad7882b24fb8463d16e80274851e0e203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace invalid characters silently.  <a href="name_8hpp.html#ad7882b24fb8463d16e80274851e0e203">More...</a><br /></td></tr>
<tr class="separator:ad7882b24fb8463d16e80274851e0e203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0867a80ae5531d5a6f37e9b8ca2078d8"><td class="memItemLeft" align="right" valign="top"><a id="a0867a80ae5531d5a6f37e9b8ca2078d8" name="a0867a80ae5531d5a6f37e9b8ca2078d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_PUBLIC</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:a0867a80ae5531d5a6f37e9b8ca2078d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, make name public <br /></td></tr>
<tr class="separator:a0867a80ae5531d5a6f37e9b8ca2078d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa682721856e47459dd83249ce69e84f4"><td class="memItemLeft" align="right" valign="top"><a id="aa682721856e47459dd83249ce69e84f4" name="aa682721856e47459dd83249ce69e84f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_NON_PUBLIC</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:aa682721856e47459dd83249ce69e84f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, make name non-public <br /></td></tr>
<tr class="separator:aa682721856e47459dd83249ce69e84f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3e06b901908b81c01a9f0062e9b71b"><td class="memItemLeft" align="right" valign="top"><a id="a6a3e06b901908b81c01a9f0062e9b71b" name="a6a3e06b901908b81c01a9f0062e9b71b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_WEAK</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:a6a3e06b901908b81c01a9f0062e9b71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, make name weak <br /></td></tr>
<tr class="separator:a6a3e06b901908b81c01a9f0062e9b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc2cae373dd31ec2dc329afbaf0d3e9"><td class="memItemLeft" align="right" valign="top"><a id="a3dc2cae373dd31ec2dc329afbaf0d3e9" name="a3dc2cae373dd31ec2dc329afbaf0d3e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_NON_WEAK</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a3dc2cae373dd31ec2dc329afbaf0d3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, make name non-weak <br /></td></tr>
<tr class="separator:a3dc2cae373dd31ec2dc329afbaf0d3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649469af3f3ed0924be751921e29d60e"><td class="memItemLeft" align="right" valign="top"><a id="a649469af3f3ed0924be751921e29d60e" name="a649469af3f3ed0924be751921e29d60e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_AUTO</b>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:a649469af3f3ed0924be751921e29d60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, make name autogenerated <br /></td></tr>
<tr class="separator:a649469af3f3ed0924be751921e29d60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5839893e37d57ecdea4964f844ed019d"><td class="memItemLeft" align="right" valign="top"><a id="a5839893e37d57ecdea4964f844ed019d" name="a5839893e37d57ecdea4964f844ed019d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_NON_AUTO</b>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:a5839893e37d57ecdea4964f844ed019d"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, make name non-autogenerated <br /></td></tr>
<tr class="separator:a5839893e37d57ecdea4964f844ed019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ba63b7a7a9a881df414b7bfdce7447"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a68ba63b7a7a9a881df414b7bfdce7447">SN_NOLIST</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:a68ba63b7a7a9a881df414b7bfdce7447"><td class="mdescLeft">&#160;</td><td class="mdescRight">if set, exclude name from the list.  <a href="name_8hpp.html#a68ba63b7a7a9a881df414b7bfdce7447">More...</a><br /></td></tr>
<tr class="separator:a68ba63b7a7a9a881df414b7bfdce7447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c416eb3ed6bc386932d8da15bb134b"><td class="memItemLeft" align="right" valign="top"><a id="a84c416eb3ed6bc386932d8da15bb134b" name="a84c416eb3ed6bc386932d8da15bb134b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_NOWARN</b>&#160;&#160;&#160;0x100</td></tr>
<tr class="memdesc:a84c416eb3ed6bc386932d8da15bb134b"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't display a warning if failed <br /></td></tr>
<tr class="separator:a84c416eb3ed6bc386932d8da15bb134b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6052ebef5e57c6e905fe9f902188401d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a6052ebef5e57c6e905fe9f902188401d">SN_LOCAL</a>&#160;&#160;&#160;0x200</td></tr>
<tr class="memdesc:a6052ebef5e57c6e905fe9f902188401d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create local name.  <a href="name_8hpp.html#a6052ebef5e57c6e905fe9f902188401d">More...</a><br /></td></tr>
<tr class="separator:a6052ebef5e57c6e905fe9f902188401d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4de680eb13eaaf581e4082ce7524f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#abb4de680eb13eaaf581e4082ce7524f3">SN_IDBENC</a>&#160;&#160;&#160;0x400</td></tr>
<tr class="memdesc:abb4de680eb13eaaf581e4082ce7524f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly.  <a href="name_8hpp.html#abb4de680eb13eaaf581e4082ce7524f3">More...</a><br /></td></tr>
<tr class="separator:abb4de680eb13eaaf581e4082ce7524f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc1743c42551da5864b7073b41438f8"><td class="memItemLeft" align="right" valign="top"><a id="abdc1743c42551da5864b7073b41438f8" name="abdc1743c42551da5864b7073b41438f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_FORCE</b>&#160;&#160;&#160;0x800</td></tr>
<tr class="memdesc:abdc1743c42551da5864b7073b41438f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the specified name is already present in the database, try variations with a numerical suffix like "_123" <br /></td></tr>
<tr class="separator:abdc1743c42551da5864b7073b41438f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382967c6aac3f869feb3d63c8bbe3a7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a382967c6aac3f869feb3d63c8bbe3a7f">SN_NODUMMY</a>&#160;&#160;&#160;0x1000</td></tr>
<tr class="memdesc:a382967c6aac3f869feb3d63c8bbe3a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">automatically prepend the name with '_' if it begins with a dummy suffix such as 'sub_'.  <a href="name_8hpp.html#a382967c6aac3f869feb3d63c8bbe3a7f">More...</a><br /></td></tr>
<tr class="separator:a382967c6aac3f869feb3d63c8bbe3a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4672dba1ee0e8c1b127cbcbf01a22e"><td class="memItemLeft" align="right" valign="top"><a id="aff4672dba1ee0e8c1b127cbcbf01a22e" name="aff4672dba1ee0e8c1b127cbcbf01a22e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SN_DELTAIL</b>&#160;&#160;&#160;0x2000</td></tr>
<tr class="memdesc:aff4672dba1ee0e8c1b127cbcbf01a22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">if name cannot be set because of a tail byte, delete the hindering item <br /></td></tr>
<tr class="separator:aff4672dba1ee0e8c1b127cbcbf01a22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a051016ac92685c95d47a7c1850c19632"><td class="memItemLeft" align="right" valign="top"><a id="a051016ac92685c95d47a7c1850c19632" name="a051016ac92685c95d47a7c1850c19632"></a>
typedef <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><b>color_t</b></td></tr>
<tr class="separator:a051016ac92685c95d47a7c1850c19632"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa75fb1ba89bb22f323472e329eb4a486"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#aa75fb1ba89bb22f323472e329eb4a486">set_name</a> (ea_t ea, const char *name, int flags=0)</td></tr>
<tr class="memdesc:aa75fb1ba89bb22f323472e329eb4a486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or delete name of an item at the specified address.  <a href="name_8hpp.html#aa75fb1ba89bb22f323472e329eb4a486">More...</a><br /></td></tr>
<tr class="separator:aa75fb1ba89bb22f323472e329eb4a486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa126bf5a647bde94b176277a0936c3b8"><td class="memItemLeft" align="right" valign="top"><a id="aa126bf5a647bde94b176277a0936c3b8" name="aa126bf5a647bde94b176277a0936c3b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>force_name</b> (ea_t ea, const char *name, int flags=0)</td></tr>
<tr class="separator:aa126bf5a647bde94b176277a0936c3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Delete a name of a program item</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok, name is deleted </td></tr>
    <tr><td class="paramname">0</td><td>failure, invalid address </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a40259b9687b2e45798e5dc439d24b6d7"><td class="memItemLeft" align="right" valign="top"><a id="a40259b9687b2e45798e5dc439d24b6d7" name="a40259b9687b2e45798e5dc439d24b6d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>del_global_name</b> (ea_t ea)</td></tr>
<tr class="separator:a40259b9687b2e45798e5dc439d24b6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc47ae3db754c532ad98c1aa49ca5d9e"><td class="memItemLeft" align="right" valign="top"><a id="abc47ae3db754c532ad98c1aa49ca5d9e" name="abc47ae3db754c532ad98c1aa49ca5d9e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>del_local_name</b> (ea_t ea)</td></tr>
<tr class="separator:abc47ae3db754c532ad98c1aa49ca5d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa940671bab6958b3772cbf834d9e8d4"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#afa940671bab6958b3772cbf834d9e8d4">set_dummy_name</a> (ea_t from, ea_t ea)</td></tr>
<tr class="memdesc:afa940671bab6958b3772cbf834d9e8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give an autogenerated (dummy) name.  <a href="name_8hpp.html#afa940671bab6958b3772cbf834d9e8d4">More...</a><br /></td></tr>
<tr class="separator:afa940671bab6958b3772cbf834d9e8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Work with publicness of a name</div></td></tr>
<tr class="memitem:a3025d6af37336d312cde70d55e31c35c"><td class="memItemLeft" align="right" valign="top"><a id="a3025d6af37336d312cde70d55e31c35c" name="a3025d6af37336d312cde70d55e31c35c"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_public_name</b> (ea_t ea)</td></tr>
<tr class="separator:a3025d6af37336d312cde70d55e31c35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ff78eb1604b37f3dcad2fd68a50f89"><td class="memItemLeft" align="right" valign="top"><a id="aa0ff78eb1604b37f3dcad2fd68a50f89" name="aa0ff78eb1604b37f3dcad2fd68a50f89"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>make_name_public</b> (ea_t ea)</td></tr>
<tr class="separator:aa0ff78eb1604b37f3dcad2fd68a50f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2b3fb8776e0b9e665d8080be27c767"><td class="memItemLeft" align="right" valign="top"><a id="afa2b3fb8776e0b9e665d8080be27c767" name="afa2b3fb8776e0b9e665d8080be27c767"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>make_name_non_public</b> (ea_t ea)</td></tr>
<tr class="separator:afa2b3fb8776e0b9e665d8080be27c767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Work with weak names.</div></td></tr>
<tr class="memitem:a2e3710e212d4ae4211994a48146011f6"><td class="memItemLeft" align="right" valign="top"><a id="a2e3710e212d4ae4211994a48146011f6" name="a2e3710e212d4ae4211994a48146011f6"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_weak_name</b> (ea_t ea)</td></tr>
<tr class="separator:a2e3710e212d4ae4211994a48146011f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae376f4da9664b9f9b93c969f35ebbbc7"><td class="memItemLeft" align="right" valign="top"><a id="ae376f4da9664b9f9b93c969f35ebbbc7" name="ae376f4da9664b9f9b93c969f35ebbbc7"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>make_name_weak</b> (ea_t ea)</td></tr>
<tr class="separator:ae376f4da9664b9f9b93c969f35ebbbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fae415f3714ca7bb96a894483953b48"><td class="memItemLeft" align="right" valign="top"><a id="a4fae415f3714ca7bb96a894483953b48" name="a4fae415f3714ca7bb96a894483953b48"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>make_name_non_weak</b> (ea_t ea)</td></tr>
<tr class="separator:a4fae415f3714ca7bb96a894483953b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Set/Clear bit in flags for 'autogenerated but meaningful name'</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpbaa28c5794865b4184e11309c408201a"></a>This bit affects value of <a class="el" href="bytes_8hpp.html#aabdf4af28c50c8aa1a370809d30d1753" title="Does the current byte have user-specified name?">has_user_name()</a>, <a class="el" href="bytes_8hpp.html#ad69dcba9650af2bace104f83083e23e1" title="Does the current byte have auto-generated (no special prefix) name?">has_auto_name()</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>no meaningful name is present at the specified address </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr class="memitem:a4de219a37da79e15eef267e9c2779c99"><td class="memItemLeft" align="right" valign="top"><a id="a4de219a37da79e15eef267e9c2779c99" name="a4de219a37da79e15eef267e9c2779c99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_NONE</b>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a4de219a37da79e15eef267e9c2779c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">name doesn't exist or has no value <br /></td></tr>
<tr class="separator:a4de219a37da79e15eef267e9c2779c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb20321455bb23e97b9a01a7b894cfa"><td class="memItemLeft" align="right" valign="top"><a id="a7cb20321455bb23e97b9a01a7b894cfa" name="a7cb20321455bb23e97b9a01a7b894cfa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_BYTE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a7cb20321455bb23e97b9a01a7b894cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is byte name (regular name) <br /></td></tr>
<tr class="separator:a7cb20321455bb23e97b9a01a7b894cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0fef47f0ff2129d0c97b6deac0ec84"><td class="memItemLeft" align="right" valign="top"><a id="a3f0fef47f0ff2129d0c97b6deac0ec84" name="a3f0fef47f0ff2129d0c97b6deac0ec84"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_LOCAL</b>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a3f0fef47f0ff2129d0c97b6deac0ec84"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is local label <br /></td></tr>
<tr class="separator:a3f0fef47f0ff2129d0c97b6deac0ec84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df1731f818635633fb4f778be4e0e0a"><td class="memItemLeft" align="right" valign="top"><a id="a8df1731f818635633fb4f778be4e0e0a" name="a8df1731f818635633fb4f778be4e0e0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_STKVAR</b>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a8df1731f818635633fb4f778be4e0e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is stack variable name <br /></td></tr>
<tr class="separator:a8df1731f818635633fb4f778be4e0e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96c9ab46de6d8a989c982e94cd0c5b9"><td class="memItemLeft" align="right" valign="top"><a id="ab96c9ab46de6d8a989c982e94cd0c5b9" name="ab96c9ab46de6d8a989c982e94cd0c5b9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_ENUM</b>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ab96c9ab46de6d8a989c982e94cd0c5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is symbolic constant <br /></td></tr>
<tr class="separator:ab96c9ab46de6d8a989c982e94cd0c5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6468e1435a25f7b2156f1be7eacc1e5e"><td class="memItemLeft" align="right" valign="top"><a id="a6468e1435a25f7b2156f1be7eacc1e5e" name="a6468e1435a25f7b2156f1be7eacc1e5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_ABS</b>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a6468e1435a25f7b2156f1be7eacc1e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is absolute symbol (<a class="el" href="segment_8hpp.html#a5c130d299e48ff537068e03e8ae23d71" title="* segment with definitions of absolute symbols">SEG_ABSSYM</a>) <br /></td></tr>
<tr class="separator:a6468e1435a25f7b2156f1be7eacc1e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72908de84dbd9fe5cefe18ace88f484e"><td class="memItemLeft" align="right" valign="top"><a id="a72908de84dbd9fe5cefe18ace88f484e" name="a72908de84dbd9fe5cefe18ace88f484e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_SEG</b>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a72908de84dbd9fe5cefe18ace88f484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is segment or segment register name <br /></td></tr>
<tr class="separator:a72908de84dbd9fe5cefe18ace88f484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c2fde5a1cbc8a7cf3da8b10bae1467"><td class="memItemLeft" align="right" valign="top"><a id="a64c2fde5a1cbc8a7cf3da8b10bae1467" name="a64c2fde5a1cbc8a7cf3da8b10bae1467"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_STROFF</b>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a64c2fde5a1cbc8a7cf3da8b10bae1467"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is structure member <br /></td></tr>
<tr class="separator:a64c2fde5a1cbc8a7cf3da8b10bae1467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fb600ff0ae72ab4ae0662e4a37f785"><td class="memItemLeft" align="right" valign="top"><a id="a36fb600ff0ae72ab4ae0662e4a37f785" name="a36fb600ff0ae72ab4ae0662e4a37f785"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_BMASK</b>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a36fb600ff0ae72ab4ae0662e4a37f785"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is a bit group mask name <br /></td></tr>
<tr class="separator:a36fb600ff0ae72ab4ae0662e4a37f785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29201df21dd3954b735cbf0219b10781"><td class="memItemLeft" align="right" valign="top"><a id="a29201df21dd3954b735cbf0219b10781" name="a29201df21dd3954b735cbf0219b10781"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NT_REGVAR</b>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:a29201df21dd3954b735cbf0219b10781"><td class="mdescLeft">&#160;</td><td class="mdescRight">name is a renamed register (*value is idx into pfn-&gt;regvars) <br /></td></tr>
<tr class="separator:a29201df21dd3954b735cbf0219b10781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ddb516744c3c8a33bac41c5f4ac819"><td class="memItemLeft" align="right" valign="top"><a id="a80ddb516744c3c8a33bac41c5f4ac819" name="a80ddb516744c3c8a33bac41c5f4ac819"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_VISIBLE</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a80ddb516744c3c8a33bac41c5f4ac819"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace forbidden characters by SUBSTCHAR <br /></td></tr>
<tr class="separator:a80ddb516744c3c8a33bac41c5f4ac819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1c5de165b2519941f5d2cd40f74d4c"><td class="memItemLeft" align="right" valign="top"><a id="aae1c5de165b2519941f5d2cd40f74d4c" name="aae1c5de165b2519941f5d2cd40f74d4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_COLORED</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:aae1c5de165b2519941f5d2cd40f74d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return colored name <br /></td></tr>
<tr class="separator:aae1c5de165b2519941f5d2cd40f74d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9c3a59e99c5c7460007521b2a29638"><td class="memItemLeft" align="right" valign="top"><a id="afa9c3a59e99c5c7460007521b2a29638" name="afa9c3a59e99c5c7460007521b2a29638"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_DEMANGLED</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:afa9c3a59e99c5c7460007521b2a29638"><td class="mdescLeft">&#160;</td><td class="mdescRight">return demangled name <br /></td></tr>
<tr class="separator:afa9c3a59e99c5c7460007521b2a29638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a436f17eead3c46517b66fd839618b"><td class="memItemLeft" align="right" valign="top"><a id="aa7a436f17eead3c46517b66fd839618b" name="aa7a436f17eead3c46517b66fd839618b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_STRICT</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:aa7a436f17eead3c46517b66fd839618b"><td class="mdescLeft">&#160;</td><td class="mdescRight">fail if cannot demangle <br /></td></tr>
<tr class="separator:aa7a436f17eead3c46517b66fd839618b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495df041aa5fb753d624be86eb505c15"><td class="memItemLeft" align="right" valign="top"><a id="a495df041aa5fb753d624be86eb505c15" name="a495df041aa5fb753d624be86eb505c15"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_SHORT</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a495df041aa5fb753d624be86eb505c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">use short form of demangled name <br /></td></tr>
<tr class="separator:a495df041aa5fb753d624be86eb505c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5863fe8b0fb7e2611a256b1522c0c2"><td class="memItemLeft" align="right" valign="top"><a id="a0d5863fe8b0fb7e2611a256b1522c0c2" name="a0d5863fe8b0fb7e2611a256b1522c0c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_LONG</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a0d5863fe8b0fb7e2611a256b1522c0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">use long form of demangled name <br /></td></tr>
<tr class="separator:a0d5863fe8b0fb7e2611a256b1522c0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0715adddc8d76104b20380d0f1622d3"><td class="memItemLeft" align="right" valign="top"><a id="ac0715adddc8d76104b20380d0f1622d3" name="ac0715adddc8d76104b20380d0f1622d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_LOCAL</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:ac0715adddc8d76104b20380d0f1622d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to get local name first; if failed, get global <br /></td></tr>
<tr class="separator:ac0715adddc8d76104b20380d0f1622d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e0fd595f03d14856a3cb0d3ad3c97"><td class="memItemLeft" align="right" valign="top"><a id="ac32e0fd595f03d14856a3cb0d3ad3c97" name="ac32e0fd595f03d14856a3cb0d3ad3c97"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_ISRET</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:ac32e0fd595f03d14856a3cb0d3ad3c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">for dummy names: use retloc <br /></td></tr>
<tr class="separator:ac32e0fd595f03d14856a3cb0d3ad3c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bc14f872a9e5f14dfe51d82f191367"><td class="memItemLeft" align="right" valign="top"><a id="aa1bc14f872a9e5f14dfe51d82f191367" name="aa1bc14f872a9e5f14dfe51d82f191367"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_NOT_ISRET</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:aa1bc14f872a9e5f14dfe51d82f191367"><td class="mdescLeft">&#160;</td><td class="mdescRight">for dummy names: do not use retloc <br /></td></tr>
<tr class="separator:aa1bc14f872a9e5f14dfe51d82f191367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceacd365212162c953a17a1ed27be84"><td class="memItemLeft" align="right" valign="top"><a id="aaceacd365212162c953a17a1ed27be84" name="aaceacd365212162c953a17a1ed27be84"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GN_NOT_DUMMY</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:aaceacd365212162c953a17a1ed27be84"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not return a dummy name <br /></td></tr>
<tr class="separator:aaceacd365212162c953a17a1ed27be84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d81af73461e98bd691ef1337d72a018"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a1d81af73461e98bd691ef1337d72a018">GETN_APPZERO</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a1d81af73461e98bd691ef1337d72a018"><td class="mdescLeft">&#160;</td><td class="mdescRight">meaningful only if the name refers to a structure.  <a href="name_8hpp.html#a1d81af73461e98bd691ef1337d72a018">More...</a><br /></td></tr>
<tr class="separator:a1d81af73461e98bd691ef1337d72a018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02954d083735a275dab62ea9952e0a1"><td class="memItemLeft" align="right" valign="top"><a id="ab02954d083735a275dab62ea9952e0a1" name="ab02954d083735a275dab62ea9952e0a1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GETN_NOFIXUP</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:ab02954d083735a275dab62ea9952e0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore the fixup information when producing the name <br /></td></tr>
<tr class="separator:ab02954d083735a275dab62ea9952e0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087e60e7f734e12197cbd6f3fd0238eb"><td class="memItemLeft" align="right" valign="top"><a id="a087e60e7f734e12197cbd6f3fd0238eb" name="a087e60e7f734e12197cbd6f3fd0238eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GETN_NODUMMY</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a087e60e7f734e12197cbd6f3fd0238eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">do not create a new dummy name but pretend it exists <br /></td></tr>
<tr class="separator:a087e60e7f734e12197cbd6f3fd0238eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b6c1a0d3546db59f574c7e68b934da"><td class="memItemLeft" align="right" valign="top"><a id="a44b6c1a0d3546db59f574c7e68b934da" name="a44b6c1a0d3546db59f574c7e68b934da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_NOSEG</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a44b6c1a0d3546db59f574c7e68b934da"><td class="mdescLeft">&#160;</td><td class="mdescRight">ignore the segment prefix when producing the name <br /></td></tr>
<tr class="separator:a44b6c1a0d3546db59f574c7e68b934da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af16b8c4d15883f80523c618a15b2b"><td class="memItemLeft" align="right" valign="top"><a id="a76af16b8c4d15883f80523c618a15b2b" name="a76af16b8c4d15883f80523c618a15b2b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_NOCOLOR</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a76af16b8c4d15883f80523c618a15b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate an uncolored name <br /></td></tr>
<tr class="separator:a76af16b8c4d15883f80523c618a15b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552dbc7d9e0d506c4c0360c0f19d7d1a"><td class="memItemLeft" align="right" valign="top"><a id="a552dbc7d9e0d506c4c0360c0f19d7d1a" name="a552dbc7d9e0d506c4c0360c0f19d7d1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_NOLABEL</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:a552dbc7d9e0d506c4c0360c0f19d7d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't generate labels <br /></td></tr>
<tr class="separator:a552dbc7d9e0d506c4c0360c0f19d7d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d69b354412585de23922860c32d0b96"><td class="memItemLeft" align="right" valign="top"><a id="a2d69b354412585de23922860c32d0b96" name="a2d69b354412585de23922860c32d0b96"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_NOFUNC</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:a2d69b354412585de23922860c32d0b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't generate funcname+... expressions <br /></td></tr>
<tr class="separator:a2d69b354412585de23922860c32d0b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a1f20aa3defaea4e8a9416b2a276a9"><td class="memItemLeft" align="right" valign="top"><a id="a62a1f20aa3defaea4e8a9416b2a276a9" name="a62a1f20aa3defaea4e8a9416b2a276a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_SEG_FUNC</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:a62a1f20aa3defaea4e8a9416b2a276a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate both segment and function names (default is to omit segment name if a function name is present) <br /></td></tr>
<tr class="separator:a62a1f20aa3defaea4e8a9416b2a276a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145d608439ef507a7c3d45d7aee1f292"><td class="memItemLeft" align="right" valign="top"><a id="a145d608439ef507a7c3d45d7aee1f292" name="a145d608439ef507a7c3d45d7aee1f292"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_SEGNUM</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:a145d608439ef507a7c3d45d7aee1f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">segment part is displayed as a hex number <br /></td></tr>
<tr class="separator:a145d608439ef507a7c3d45d7aee1f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628dd91bed5b223a3225d85a1e928f51"><td class="memItemLeft" align="right" valign="top"><a id="a628dd91bed5b223a3225d85a1e928f51" name="a628dd91bed5b223a3225d85a1e928f51"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_REQFUNC</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:a628dd91bed5b223a3225d85a1e928f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">return 0 if the address does not belong to a function <br /></td></tr>
<tr class="separator:a628dd91bed5b223a3225d85a1e928f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb1ec69833035cfef4b8efd7111ccdd"><td class="memItemLeft" align="right" valign="top"><a id="a1fb1ec69833035cfef4b8efd7111ccdd" name="a1fb1ec69833035cfef4b8efd7111ccdd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_REQNAME</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:a1fb1ec69833035cfef4b8efd7111ccdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return 0 if the address can only be represented as a hex number <br /></td></tr>
<tr class="separator:a1fb1ec69833035cfef4b8efd7111ccdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948d62d2ff4e200046a7aa62c49e4d4c"><td class="memItemLeft" align="right" valign="top"><a id="a948d62d2ff4e200046a7aa62c49e4d4c" name="a948d62d2ff4e200046a7aa62c49e4d4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_NODBGNM</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:a948d62d2ff4e200046a7aa62c49e4d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">don't use debug names <br /></td></tr>
<tr class="separator:a948d62d2ff4e200046a7aa62c49e4d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2605fc8cdf3194881c10f9925a10aa01"><td class="memItemLeft" align="right" valign="top"><a id="a2605fc8cdf3194881c10f9925a10aa01" name="a2605fc8cdf3194881c10f9925a10aa01"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>GNCN_PREFDBG</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:a2605fc8cdf3194881c10f9925a10aa01"><td class="mdescLeft">&#160;</td><td class="mdescRight">if using debug names, prefer debug names over function names <br /></td></tr>
<tr class="separator:a2605fc8cdf3194881c10f9925a10aa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf20e76cc52c1bd020f4534c17eb7fb6"><td class="memItemLeft" align="right" valign="top"><a id="aaf20e76cc52c1bd020f4534c17eb7fb6" name="aaf20e76cc52c1bd020f4534c17eb7fb6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ucdr_kind_t</b> { <b>UCDR_STRLIT</b> = 0x01
, <b>UCDR_NAME</b> = 0x02
, <b>UCDR_MANGLED</b> = 0x04
, <b>UCDR_TYPE</b> = 0x08
 }</td></tr>
<tr class="separator:aaf20e76cc52c1bd020f4534c17eb7fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8988c06f7c3477a71db92be5c947a782"><td class="memItemLeft" align="right" valign="top"><a id="a8988c06f7c3477a71db92be5c947a782" name="a8988c06f7c3477a71db92be5c947a782"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>nametype_t</b> { <br />
&#160;&#160;<b>VNT_IDENT</b> = UCDR_NAME|UCDR_MANGLED
, <b>VNT_TYPE</b> = UCDR_TYPE
, <b>VNT_UDTMEM</b> = UCDR_NAME
, <b>VNT_STRLIT</b> = UCDR_STRLIT
, <br />
&#160;&#160;<b>VNT_VISIBLE</b> = VNT_UDTMEM
<br />
 }</td></tr>
<tr class="separator:a8988c06f7c3477a71db92be5c947a782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8da22d2983d1afb5e40f0bfc99a2eb"><td class="memItemLeft" align="right" valign="top"><a id="a2d8da22d2983d1afb5e40f0bfc99a2eb" name="a2d8da22d2983d1afb5e40f0bfc99a2eb"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>make_name_auto</b> (ea_t ea)</td></tr>
<tr class="separator:a2d8da22d2983d1afb5e40f0bfc99a2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288047cb739f54c49cb0f5b09a334b38"><td class="memItemLeft" align="right" valign="top"><a id="a288047cb739f54c49cb0f5b09a334b38" name="a288047cb739f54c49cb0f5b09a334b38"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>make_name_user</b> (ea_t ea)</td></tr>
<tr class="separator:a288047cb739f54c49cb0f5b09a334b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023a7105c003b3ed6d812e0ef713539b"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a023a7105c003b3ed6d812e0ef713539b">validate_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *name, nametype_t type, int flags=0)</td></tr>
<tr class="memdesc:a023a7105c003b3ed6d812e0ef713539b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a name.  <a href="name_8hpp.html#a023a7105c003b3ed6d812e0ef713539b">More...</a><br /></td></tr>
<tr class="separator:a023a7105c003b3ed6d812e0ef713539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fc0390fdc76135feab239ec18ad3d8"><td class="memItemLeft" align="right" valign="top"><a id="a39fc0390fdc76135feab239ec18ad3d8" name="a39fc0390fdc76135feab239ec18ad3d8"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_cp</b> (wchar32_t cp, nametype_t kind, void *data=nullptr)</td></tr>
<tr class="memdesc:a39fc0390fdc76135feab239ec18ad3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given codepoint acceptable in the given context? <br /></td></tr>
<tr class="separator:a39fc0390fdc76135feab239ec18ad3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7015469eb9998dd7b2f49f5c7817820e"><td class="memItemLeft" align="right" valign="top"><a id="a7015469eb9998dd7b2f49f5c7817820e" name="a7015469eb9998dd7b2f49f5c7817820e"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_cp_validity</b> (ucdr_kind_t kind, wchar32_t cp, wchar32_t endcp=BADCP, bool valid=true)</td></tr>
<tr class="memdesc:a7015469eb9998dd7b2f49f5c7817820e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the given codepoint (or range) as acceptable or unacceptable in the given context If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range. <br /></td></tr>
<tr class="separator:a7015469eb9998dd7b2f49f5c7817820e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc51dac0048905e9870364dbf66cf463"><td class="memItemLeft" align="right" valign="top"><a id="abc51dac0048905e9870364dbf66cf463" name="abc51dac0048905e9870364dbf66cf463"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_cp_validity</b> (ucdr_kind_t kind, wchar32_t cp, wchar32_t endcp=BADCP)</td></tr>
<tr class="memdesc:abc51dac0048905e9870364dbf66cf463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given codepoint (or range) acceptable in the given context? If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range. <br /></td></tr>
<tr class="separator:abc51dac0048905e9870364dbf66cf463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e64321c277a5c8f90cad23f418a16c"><td class="memItemLeft" align="right" valign="top"><a id="a76e64321c277a5c8f90cad23f418a16c" name="a76e64321c277a5c8f90cad23f418a16c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_ident_cp</b> (wchar32_t cp)</td></tr>
<tr class="memdesc:a76e64321c277a5c8f90cad23f418a16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a character appear in a name? (present in ::NameChars or ::MangleChars) <br /></td></tr>
<tr class="separator:a76e64321c277a5c8f90cad23f418a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cf659d7d58ba20ad558ea99623d5f8"><td class="memItemLeft" align="right" valign="top"><a id="a41cf659d7d58ba20ad558ea99623d5f8" name="a41cf659d7d58ba20ad558ea99623d5f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_strlit_cp</b> (wchar32_t cp, const <a class="el" href="classqvector.html">rangeset_crefvec_t</a> *specific_ranges=nullptr)</td></tr>
<tr class="memdesc:a41cf659d7d58ba20ad558ea99623d5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a character appear in a string literal (present in ::StrlitChars) If 'specific_ranges' are specified, those will be used instead of the ones corresponding to the current culture (only if ::StrlitChars is configured to use the current culture) <br /></td></tr>
<tr class="separator:a41cf659d7d58ba20ad558ea99623d5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c03716b0d191d94fd8ca99f1a14eb14"><td class="memItemLeft" align="right" valign="top"><a id="a4c03716b0d191d94fd8ca99f1a14eb14" name="a4c03716b0d191d94fd8ca99f1a14eb14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_visible_cp</b> (wchar32_t cp)</td></tr>
<tr class="memdesc:a4c03716b0d191d94fd8ca99f1a14eb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a character be displayed in a name? (present in ::NameChars) <br /></td></tr>
<tr class="separator:a4c03716b0d191d94fd8ca99f1a14eb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474a81ed7d871c6045ef009955db712b"><td class="memItemLeft" align="right" valign="top"><a id="a474a81ed7d871c6045ef009955db712b" name="a474a81ed7d871c6045ef009955db712b"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_ident</b> (const char *name)</td></tr>
<tr class="memdesc:a474a81ed7d871c6045ef009955db712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a valid name? (including ::MangleChars) <br /></td></tr>
<tr class="separator:a474a81ed7d871c6045ef009955db712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cac1f791aadbaf4699c672e2a371483"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a1cac1f791aadbaf4699c672e2a371483">is_uname</a> (const char *name)</td></tr>
<tr class="memdesc:a1cac1f791aadbaf4699c672e2a371483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is valid user-specified name? (valid name &amp; !dummy prefix).  <a href="name_8hpp.html#a1cac1f791aadbaf4699c672e2a371483">More...</a><br /></td></tr>
<tr class="separator:a1cac1f791aadbaf4699c672e2a371483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3271b2d04d48bf0d8b2126cda8152b23"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a3271b2d04d48bf0d8b2126cda8152b23">is_valid_typename</a> (const char *name)</td></tr>
<tr class="memdesc:a3271b2d04d48bf0d8b2126cda8152b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is valid type name?  <a href="name_8hpp.html#a3271b2d04d48bf0d8b2126cda8152b23">More...</a><br /></td></tr>
<tr class="separator:a3271b2d04d48bf0d8b2126cda8152b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7861ff00288a2f91688761305c901d34"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a7861ff00288a2f91688761305c901d34">dummy_name_ea</a> (const char *name)</td></tr>
<tr class="memdesc:a7861ff00288a2f91688761305c901d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is dummy name?  <a href="name_8hpp.html#a7861ff00288a2f91688761305c901d34">More...</a><br /></td></tr>
<tr class="separator:a7861ff00288a2f91688761305c901d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b4ea81944925c0689be2557e2f501"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a5c3b4ea81944925c0689be2557e2f501">extract_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const char *line, int x)</td></tr>
<tr class="memdesc:a5c3b4ea81944925c0689be2557e2f501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a name or address from the specified string.  <a href="name_8hpp.html#a5c3b4ea81944925c0689be2557e2f501">More...</a><br /></td></tr>
<tr class="separator:a5c3b4ea81944925c0689be2557e2f501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57ff60cd0ee8a0aa6283d88a88743cf"><td class="memItemLeft" align="right" valign="top">idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#ad57ff60cd0ee8a0aa6283d88a88743cf">hide_name</a> (ea_t ea)</td></tr>
<tr class="memdesc:ad57ff60cd0ee8a0aa6283d88a88743cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove name from the list of names.  <a href="name_8hpp.html#ad57ff60cd0ee8a0aa6283d88a88743cf">More...</a><br /></td></tr>
<tr class="separator:ad57ff60cd0ee8a0aa6283d88a88743cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbdb624ecada9f02b129f85031ab4d3"><td class="memItemLeft" align="right" valign="top"><a id="aafbdb624ecada9f02b129f85031ab4d3" name="aafbdb624ecada9f02b129f85031ab4d3"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>show_name</b> (ea_t ea)</td></tr>
<tr class="memdesc:aafbdb624ecada9f02b129f85031ab4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert name to the list of names. <br /></td></tr>
<tr class="separator:aafbdb624ecada9f02b129f85031ab4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14a47ac26d57e3926296e9c0c729075"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#ad14a47ac26d57e3926296e9c0c729075">get_name_ea</a> (ea_t from, const char *name)</td></tr>
<tr class="memdesc:ad14a47ac26d57e3926296e9c0c729075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of a name.  <a href="name_8hpp.html#ad14a47ac26d57e3926296e9c0c729075">More...</a><br /></td></tr>
<tr class="separator:ad14a47ac26d57e3926296e9c0c729075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdcd86fbe8f292b62b0cb97a749d205"><td class="memItemLeft" align="right" valign="top">idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#aacdcd86fbe8f292b62b0cb97a749d205">get_name_base_ea</a> (ea_t from, ea_t to)</td></tr>
<tr class="memdesc:aacdcd86fbe8f292b62b0cb97a749d205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address of the name used in the expression for the address.  <a href="name_8hpp.html#aacdcd86fbe8f292b62b0cb97a749d205">More...</a><br /></td></tr>
<tr class="separator:aacdcd86fbe8f292b62b0cb97a749d205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610d30c00b8ec32d1d9147589d75c0a6"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a610d30c00b8ec32d1d9147589d75c0a6">get_name_value</a> (<a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *value, ea_t from, const char *name)</td></tr>
<tr class="memdesc:a610d30c00b8ec32d1d9147589d75c0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of the name.  <a href="name_8hpp.html#a610d30c00b8ec32d1d9147589d75c0a6">More...</a><br /></td></tr>
<tr class="separator:a610d30c00b8ec32d1d9147589d75c0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12648107028fb2927759f78edc8b3e7a"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a12648107028fb2927759f78edc8b3e7a">get_ea_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int gtn_flags=0, <a class="el" href="structgetname__info__t.html">getname_info_t</a> *gtni=nullptr)</td></tr>
<tr class="memdesc:a12648107028fb2927759f78edc8b3e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name at the specified address.  <a href="name_8hpp.html#a12648107028fb2927759f78edc8b3e7a">More...</a><br /></td></tr>
<tr class="separator:a12648107028fb2927759f78edc8b3e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa575b3bcc4c1203ffbf0c0ebb7eaa16c"><td class="memItemLeft" align="right" valign="top"><a id="aa575b3bcc4c1203ffbf0c0ebb7eaa16c" name="aa575b3bcc4c1203ffbf0c0ebb7eaa16c"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:aa575b3bcc4c1203ffbf0c0ebb7eaa16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874f4e97d730d5375365e1bf8221444f"><td class="memItemLeft" align="right" valign="top"><a id="a874f4e97d730d5375365e1bf8221444f" name="a874f4e97d730d5375365e1bf8221444f"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_visible_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a874f4e97d730d5375365e1bf8221444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816e88b679a0f0c8cb37bce3aa712420"><td class="memItemLeft" align="right" valign="top"><a id="a816e88b679a0f0c8cb37bce3aa712420" name="a816e88b679a0f0c8cb37bce3aa712420"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_colored_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a816e88b679a0f0c8cb37bce3aa712420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4e26cf3997699391cce8d6ff888885"><td class="memItemLeft" align="right" valign="top"><a id="acc4e26cf3997699391cce8d6ff888885" name="acc4e26cf3997699391cce8d6ff888885"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_short_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:acc4e26cf3997699391cce8d6ff888885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27d842500bf774fbdd073aea2b3f403"><td class="memItemLeft" align="right" valign="top"><a id="ad27d842500bf774fbdd073aea2b3f403" name="ad27d842500bf774fbdd073aea2b3f403"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_long_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:ad27d842500bf774fbdd073aea2b3f403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033a9d0509114e4f97fdaeab1a9cdde8"><td class="memItemLeft" align="right" valign="top"><a id="a033a9d0509114e4f97fdaeab1a9cdde8" name="a033a9d0509114e4f97fdaeab1a9cdde8"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_colored_short_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a033a9d0509114e4f97fdaeab1a9cdde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab717ea9badda3fda7d6818d28d2467c9"><td class="memItemLeft" align="right" valign="top"><a id="ab717ea9badda3fda7d6818d28d2467c9" name="ab717ea9badda3fda7d6818d28d2467c9"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_colored_long_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:ab717ea9badda3fda7d6818d28d2467c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab686aff2c7d57504cd626422a4c45217"><td class="memItemLeft" align="right" valign="top"><a id="ab686aff2c7d57504cd626422a4c45217" name="ab686aff2c7d57504cd626422a4c45217"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_demangled_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> inhibitor, int demform, int gtn_flags=0)</td></tr>
<tr class="separator:ab686aff2c7d57504cd626422a4c45217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f640271f3d6e66b652c54775aa17709"><td class="memItemLeft" align="right" valign="top"><a id="a9f640271f3d6e66b652c54775aa17709" name="a9f640271f3d6e66b652c54775aa17709"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_colored_demangled_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> inhibitor, int demform, int gtn_flags=0)</td></tr>
<tr class="separator:a9f640271f3d6e66b652c54775aa17709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fe80f985595cc95960891b5edcd296"><td class="memItemLeft" align="right" valign="top"><a id="a24fe80f985595cc95960891b5edcd296" name="a24fe80f985595cc95960891b5edcd296"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_name</b> (ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a24fe80f985595cc95960891b5edcd296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9f91331dadbd70ff2da64b1e19cded"><td class="memItemLeft" align="right" valign="top"><a id="a5e9f91331dadbd70ff2da64b1e19cded" name="a5e9f91331dadbd70ff2da64b1e19cded"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_visible_name</b> (ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a5e9f91331dadbd70ff2da64b1e19cded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85346c5d02c6ceaee845ef5c64f7f2f7"><td class="memItemLeft" align="right" valign="top"><a id="a85346c5d02c6ceaee845ef5c64f7f2f7" name="a85346c5d02c6ceaee845ef5c64f7f2f7"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_colored_name</b> (ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a85346c5d02c6ceaee845ef5c64f7f2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbd26275d56c5ec7ff3090f8b3443e4"><td class="memItemLeft" align="right" valign="top"><a id="adcbd26275d56c5ec7ff3090f8b3443e4" name="adcbd26275d56c5ec7ff3090f8b3443e4"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_short_name</b> (ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:adcbd26275d56c5ec7ff3090f8b3443e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fb60538b597a3d6ac7933311895425"><td class="memItemLeft" align="right" valign="top"><a id="a51fb60538b597a3d6ac7933311895425" name="a51fb60538b597a3d6ac7933311895425"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_long_name</b> (ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a51fb60538b597a3d6ac7933311895425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163738740c8b61cc152557cbe762ec68"><td class="memItemLeft" align="right" valign="top"><a id="a163738740c8b61cc152557cbe762ec68" name="a163738740c8b61cc152557cbe762ec68"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_colored_short_name</b> (ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a163738740c8b61cc152557cbe762ec68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9523be0fb8ae3ac26c44c88945873dbd"><td class="memItemLeft" align="right" valign="top"><a id="a9523be0fb8ae3ac26c44c88945873dbd" name="a9523be0fb8ae3ac26c44c88945873dbd"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_colored_long_name</b> (ea_t ea, int gtn_flags=0)</td></tr>
<tr class="separator:a9523be0fb8ae3ac26c44c88945873dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb614d8e189b6889309f3e0763e2cd8c"><td class="memItemLeft" align="right" valign="top"><a id="abb614d8e189b6889309f3e0763e2cd8c" name="abb614d8e189b6889309f3e0763e2cd8c"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_demangled_name</b> (ea_t ea, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> inhibitor, int demform, int gtn_flags=0)</td></tr>
<tr class="separator:abb614d8e189b6889309f3e0763e2cd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a848cfedeb8b31040407d0e5c35a096"><td class="memItemLeft" align="right" valign="top"><a id="a9a848cfedeb8b31040407d0e5c35a096" name="a9a848cfedeb8b31040407d0e5c35a096"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>get_colored_demangled_name</b> (ea_t ea, <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> inhibitor, int demform, int gtn_flags=0)</td></tr>
<tr class="separator:a9a848cfedeb8b31040407d0e5c35a096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdd8c2bcc41b1246c83c020eee512c0"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="kernwin_8hpp.html#a051016ac92685c95d47a7c1850c19632">color_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#aabdd8c2bcc41b1246c83c020eee512c0">get_name_color</a> (ea_t from, ea_t ea)</td></tr>
<tr class="memdesc:aabdd8c2bcc41b1246c83c020eee512c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate flags for <a class="el" href="name_8hpp.html#a12648107028fb2927759f78edc8b3e7a" title="Get name at the specified address.">get_ea_name()</a> function.  <a href="name_8hpp.html#aabdd8c2bcc41b1246c83c020eee512c0">More...</a><br /></td></tr>
<tr class="separator:aabdd8c2bcc41b1246c83c020eee512c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbd29ee7ba50fa1d5ccf46922757b70"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a5dbd29ee7ba50fa1d5ccf46922757b70">get_name_expr</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t from, int n, ea_t ea, <a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> off, int flags=<a class="el" href="name_8hpp.html#a1d81af73461e98bd691ef1337d72a018">GETN_APPZERO</a>)</td></tr>
<tr class="memdesc:a5dbd29ee7ba50fa1d5ccf46922757b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert address to name expression (name with a displacement).  <a href="name_8hpp.html#a5dbd29ee7ba50fa1d5ccf46922757b70">More...</a><br /></td></tr>
<tr class="separator:a5dbd29ee7ba50fa1d5ccf46922757b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76ccaa62d5c6280ad61dcd372eaa44f"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#ad76ccaa62d5c6280ad61dcd372eaa44f">get_nice_colored_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *buf, ea_t ea, int flags=0)</td></tr>
<tr class="memdesc:ad76ccaa62d5c6280ad61dcd372eaa44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a nice colored name at the specified address.  <a href="name_8hpp.html#ad76ccaa62d5c6280ad61dcd372eaa44f">More...</a><br /></td></tr>
<tr class="separator:ad76ccaa62d5c6280ad61dcd372eaa44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af487ec35c909e6fcd3ce06ccaaea6e58"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#af487ec35c909e6fcd3ce06ccaaea6e58">append_struct_fields</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, adiff_t *disp, int n, const <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *path, int plen, <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> flags, adiff_t delta, bool appzero)</td></tr>
<tr class="memdesc:af487ec35c909e6fcd3ce06ccaaea6e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append names of struct fields to a name if the name is a struct name.  <a href="name_8hpp.html#af487ec35c909e6fcd3ce06ccaaea6e58">More...</a><br /></td></tr>
<tr class="separator:af487ec35c909e6fcd3ce06ccaaea6e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab6142412589f0a1ce6fad1b372e479"><td class="memItemLeft" align="right" valign="top">idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#acab6142412589f0a1ce6fad1b372e479">get_struct_operand</a> (adiff_t *disp, adiff_t *delta, <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *path, ea_t ea, int n)</td></tr>
<tr class="memdesc:acab6142412589f0a1ce6fad1b372e479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get offset within a structure if the operand refers to structure.  <a href="name_8hpp.html#acab6142412589f0a1ce6fad1b372e479">More...</a><br /></td></tr>
<tr class="separator:acab6142412589f0a1ce6fad1b372e479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Debug names</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp75717f59f045e6dfbedb225accdb8a38"></a>Debug names exist during the debugging session.</p>
<p >The kernel does not verify them for anything and happily accepts any string as a name. </p>
</td></tr>
<tr class="memitem:ac223d46b7ab8f7f3cff17602e0d920a7"><td class="memItemLeft" align="right" valign="top"><a id="ac223d46b7ab8f7f3cff17602e0d920a7" name="ac223d46b7ab8f7f3cff17602e0d920a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CN_KEEP_TRAILING__DIGITS</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ac223d46b7ab8f7f3cff17602e0d920a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb78c30f35664f57311d5baa00360434"><td class="memItemLeft" align="right" valign="top"><a id="afb78c30f35664f57311d5baa00360434" name="afb78c30f35664f57311d5baa00360434"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>demreq_type_t</b> { <br />
&#160;&#160;<b>DQT_NPURGED_8</b> = -8
, <b>DQT_NPURGED_4</b> = -4
, <b>DQT_NPURGED_2</b> = -2
, <b>DQT_COMPILER</b> = 0
, <br />
&#160;&#160;<b>DQT_NAME_TYPE</b> = 1
, <b>DQT_FULL</b> = 2
<br />
 }</td></tr>
<tr class="separator:afb78c30f35664f57311d5baa00360434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c11cf6f91e87c2f20aa0ead93361a56"><td class="memItemLeft" align="right" valign="top"><a id="a1c11cf6f91e87c2f20aa0ead93361a56" name="a1c11cf6f91e87c2f20aa0ead93361a56"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>ignore_name_def_t</b></td></tr>
<tr class="memdesc:a1c11cf6f91e87c2f20aa0ead93361a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">What name types to ignore. <br /></td></tr>
<tr class="separator:a1c11cf6f91e87c2f20aa0ead93361a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c3b1c6a967597499df1154ba284af4"><td class="memItemLeft" align="right" valign="top"><a id="ac6c3b1c6a967597499df1154ba284af4" name="ac6c3b1c6a967597499df1154ba284af4"></a>
const <a class="el" href="name_8hpp.html#a1c11cf6f91e87c2f20aa0ead93361a56">ignore_name_def_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ignore_none</b> = 0</td></tr>
<tr class="separator:ac6c3b1c6a967597499df1154ba284af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1655dddc2cdca53d5d4b900b1fc3830d"><td class="memItemLeft" align="right" valign="top"><a id="a1655dddc2cdca53d5d4b900b1fc3830d" name="a1655dddc2cdca53d5d4b900b1fc3830d"></a>
const <a class="el" href="name_8hpp.html#a1c11cf6f91e87c2f20aa0ead93361a56">ignore_name_def_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ignore_regvar</b> = 1</td></tr>
<tr class="separator:a1655dddc2cdca53d5d4b900b1fc3830d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf065d7fde6393e875ddc471caed5a3"><td class="memItemLeft" align="right" valign="top"><a id="a7bf065d7fde6393e875ddc471caed5a3" name="a7bf065d7fde6393e875ddc471caed5a3"></a>
const <a class="el" href="name_8hpp.html#a1c11cf6f91e87c2f20aa0ead93361a56">ignore_name_def_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ignore_llabel</b> = 2</td></tr>
<tr class="separator:a7bf065d7fde6393e875ddc471caed5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547abffc73cd33cf03d6897c223ba7cb"><td class="memItemLeft" align="right" valign="top"><a id="a547abffc73cd33cf03d6897c223ba7cb" name="a547abffc73cd33cf03d6897c223ba7cb"></a>
const <a class="el" href="name_8hpp.html#a1c11cf6f91e87c2f20aa0ead93361a56">ignore_name_def_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ignore_stkvar</b> = 3</td></tr>
<tr class="separator:a547abffc73cd33cf03d6897c223ba7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc0b8c549c5622a39ae1787cc5c3515"><td class="memItemLeft" align="right" valign="top"><a id="acfc0b8c549c5622a39ae1787cc5c3515" name="acfc0b8c549c5622a39ae1787cc5c3515"></a>
const <a class="el" href="name_8hpp.html#a1c11cf6f91e87c2f20aa0ead93361a56">ignore_name_def_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ignore_glabel</b> = 4</td></tr>
<tr class="separator:acfc0b8c549c5622a39ae1787cc5c3515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa244e9ea1eb8f4b93fac3974dea6a9f4"><td class="memItemLeft" align="right" valign="top"><a id="aa244e9ea1eb8f4b93fac3974dea6a9f4" name="aa244e9ea1eb8f4b93fac3974dea6a9f4"></a>
idaman int ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_debug_names</b> (const ea_t *addrs, const char *const *names, int qty)</td></tr>
<tr class="separator:aa244e9ea1eb8f4b93fac3974dea6a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ca5f6570272ce65f7e4d2ebef00edc"><td class="memItemLeft" align="right" valign="top"><a id="a45ca5f6570272ce65f7e4d2ebef00edc" name="a45ca5f6570272ce65f7e4d2ebef00edc"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>set_debug_name</b> (ea_t ea, const char *name)</td></tr>
<tr class="separator:a45ca5f6570272ce65f7e4d2ebef00edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee67bb690cf96a69917ad7278e91735e"><td class="memItemLeft" align="right" valign="top"><a id="aee67bb690cf96a69917ad7278e91735e" name="aee67bb690cf96a69917ad7278e91735e"></a>
idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_debug_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t *ea_ptr, <a class="el" href="name_8hpp.html#ab2ce188a7de5d24751a51619142bc3cd">debug_name_how_t</a> how)</td></tr>
<tr class="separator:aee67bb690cf96a69917ad7278e91735e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3f5605e8e4fb8be15a77cbcb80593"><td class="memItemLeft" align="right" valign="top"><a id="a88a3f5605e8e4fb8be15a77cbcb80593" name="a88a3f5605e8e4fb8be15a77cbcb80593"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>del_debug_names</b> (ea_t ea1, ea_t ea2)</td></tr>
<tr class="separator:a88a3f5605e8e4fb8be15a77cbcb80593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f185e2b6edba7d5a8737952f20a7df"><td class="memItemLeft" align="right" valign="top"><a id="a26f185e2b6edba7d5a8737952f20a7df" name="a26f185e2b6edba7d5a8737952f20a7df"></a>
idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_debug_name_ea</b> (const char *name)</td></tr>
<tr class="separator:a26f185e2b6edba7d5a8737952f20a7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65ed57830ceaa0edcec48749302ebb5"><td class="memItemLeft" align="right" valign="top"><a id="aa65ed57830ceaa0edcec48749302ebb5" name="aa65ed57830ceaa0edcec48749302ebb5"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_debug_names</b> (<a class="el" href="name_8hpp.html#a0a08d5152cc3fcc5cba155b300892674">ea_name_vec_t</a> *names, ea_t ea1, ea_t ea2)</td></tr>
<tr class="separator:aa65ed57830ceaa0edcec48749302ebb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c7d3ed8cf3b79dca8ee2262c9f3b56"><td class="memItemLeft" align="right" valign="top">idaman <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#aa9c7d3ed8cf3b79dca8ee2262c9f3b56">demangle_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const char *name, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> disable_mask, demreq_type_t demreq=DQT_FULL)</td></tr>
<tr class="memdesc:aa9c7d3ed8cf3b79dca8ee2262c9f3b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demangle a name.  <a href="name_8hpp.html#aa9c7d3ed8cf3b79dca8ee2262c9f3b56">More...</a><br /></td></tr>
<tr class="separator:aa9c7d3ed8cf3b79dca8ee2262c9f3b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10755fe3bcc14191826d3381f10a7c3b"><td class="memItemLeft" align="right" valign="top"><a id="a10755fe3bcc14191826d3381f10a7c3b" name="a10755fe3bcc14191826d3381f10a7c3b"></a>
<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> idaapi&#160;</td><td class="memItemRight" valign="bottom"><b>demangle_name</b> (const char *name, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> disable_mask, demreq_type_t demreq=DQT_FULL)</td></tr>
<tr class="memdesc:a10755fe3bcc14191826d3381f10a7c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demangle a name. <br /></td></tr>
<tr class="separator:a10755fe3bcc14191826d3381f10a7c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b42c669a152d98dbddb63b9f0ab6969"><td class="memItemLeft" align="right" valign="top"><a id="a2b42c669a152d98dbddb63b9f0ab6969" name="a2b42c669a152d98dbddb63b9f0ab6969"></a>
<a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>detect_compiler_using_demangler</b> (const char *name)</td></tr>
<tr class="separator:a2b42c669a152d98dbddb63b9f0ab6969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093967cd658d6aa85af7f75a3d56c9da"><td class="memItemLeft" align="right" valign="top">idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a093967cd658d6aa85af7f75a3d56c9da">is_name_defined_locally</a> (<a class="el" href="classfunc__t.html">func_t</a> *pfn, const char *name, <a class="el" href="name_8hpp.html#a1c11cf6f91e87c2f20aa0ead93361a56">ignore_name_def_t</a> ignore_name_def, ea_t ea1=<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a>, ea_t ea2=<a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a>)</td></tr>
<tr class="memdesc:a093967cd658d6aa85af7f75a3d56c9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the name defined locally in the specified function?  <a href="name_8hpp.html#a093967cd658d6aa85af7f75a3d56c9da">More...</a><br /></td></tr>
<tr class="separator:a093967cd658d6aa85af7f75a3d56c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1643196cfb62d1841e2c046d2e6931b9"><td class="memItemLeft" align="right" valign="top"><a id="a1643196cfb62d1841e2c046d2e6931b9" name="a1643196cfb62d1841e2c046d2e6931b9"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>cleanup_name</b> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, ea_t ea, const char *name, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> flags=0)</td></tr>
<tr class="separator:a1643196cfb62d1841e2c046d2e6931b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Work with the list of names</h2></td></tr>
<tr class="memitem:ab2ce188a7de5d24751a51619142bc3cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#ab2ce188a7de5d24751a51619142bc3cd">debug_name_how_t</a> { <a class="el" href="name_8hpp.html#ab2ce188a7de5d24751a51619142bc3cda07919bfad7fbbe1cbaa5bd395263743b">DEBNAME_EXACT</a>
, <a class="el" href="name_8hpp.html#ab2ce188a7de5d24751a51619142bc3cda450e6b033e4dfc8132f1afde00d27ff6">DEBNAME_LOWER</a>
, <a class="el" href="name_8hpp.html#ab2ce188a7de5d24751a51619142bc3cda234a853dad3bf08d8de43c1039a57901">DEBNAME_UPPER</a>
, <a class="el" href="name_8hpp.html#ab2ce188a7de5d24751a51619142bc3cda6fe3df259439fb5db48bc7183d736c3f">DEBNAME_NICE</a>
 }</td></tr>
<tr class="memdesc:ab2ce188a7de5d24751a51619142bc3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify strategy for retrieving debug names.  <a href="name_8hpp.html#ab2ce188a7de5d24751a51619142bc3cd">More...</a><br /></td></tr>
<tr class="separator:ab2ce188a7de5d24751a51619142bc3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a08d5152cc3fcc5cba155b300892674"><td class="memItemLeft" align="right" valign="top"><a id="a0a08d5152cc3fcc5cba155b300892674" name="a0a08d5152cc3fcc5cba155b300892674"></a>
typedef <a class="el" href="classqvector.html">qvector</a>&lt; <a class="el" href="structea__name__t.html">ea_name_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ea_name_vec_t</b></td></tr>
<tr class="memdesc:a0a08d5152cc3fcc5cba155b300892674"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of ea,name pairs <br /></td></tr>
<tr class="separator:a0a08d5152cc3fcc5cba155b300892674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59799ac73e4ae519643bfde48dd02fb2"><td class="memItemLeft" align="right" valign="top"><a id="a59799ac73e4ae519643bfde48dd02fb2" name="a59799ac73e4ae519643bfde48dd02fb2"></a>
idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_nlist_size</b> (void)</td></tr>
<tr class="memdesc:a59799ac73e4ae519643bfde48dd02fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of names in the list. <br /></td></tr>
<tr class="separator:a59799ac73e4ae519643bfde48dd02fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571b1f7ad5b466b232fd22d8f63a1d0c"><td class="memItemLeft" align="right" valign="top">idaman size_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="name_8hpp.html#a571b1f7ad5b466b232fd22d8f63a1d0c">get_nlist_idx</a> (ea_t ea)</td></tr>
<tr class="memdesc:a571b1f7ad5b466b232fd22d8f63a1d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of the name in the list.  <a href="name_8hpp.html#a571b1f7ad5b466b232fd22d8f63a1d0c">More...</a><br /></td></tr>
<tr class="separator:a571b1f7ad5b466b232fd22d8f63a1d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398e166b60176265fa4066f17359a0d9"><td class="memItemLeft" align="right" valign="top"><a id="a398e166b60176265fa4066f17359a0d9" name="a398e166b60176265fa4066f17359a0d9"></a>
idaman bool ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>is_in_nlist</b> (ea_t ea)</td></tr>
<tr class="memdesc:a398e166b60176265fa4066f17359a0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the name included into the name list? <br /></td></tr>
<tr class="separator:a398e166b60176265fa4066f17359a0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7750bac059fcd9c476c1dfde964357"><td class="memItemLeft" align="right" valign="top"><a id="a8d7750bac059fcd9c476c1dfde964357" name="a8d7750bac059fcd9c476c1dfde964357"></a>
idaman ea_t ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_nlist_ea</b> (size_t idx)</td></tr>
<tr class="memdesc:a8d7750bac059fcd9c476c1dfde964357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address from the list at 'idx'. <br /></td></tr>
<tr class="separator:a8d7750bac059fcd9c476c1dfde964357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69ca9a7dfaea22f289209bb0423ae8a"><td class="memItemLeft" align="right" valign="top"><a id="ab69ca9a7dfaea22f289209bb0423ae8a" name="ab69ca9a7dfaea22f289209bb0423ae8a"></a>
idaman const char *ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>get_nlist_name</b> (size_t idx)</td></tr>
<tr class="memdesc:ab69ca9a7dfaea22f289209bb0423ae8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name using idx. <br /></td></tr>
<tr class="separator:ab69ca9a7dfaea22f289209bb0423ae8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c4fd5dd29e834a7c35d5ccfefb84ad"><td class="memItemLeft" align="right" valign="top"><a id="ae0c4fd5dd29e834a7c35d5ccfefb84ad" name="ae0c4fd5dd29e834a7c35d5ccfefb84ad"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>rebuild_nlist</b> (void)</td></tr>
<tr class="memdesc:ae0c4fd5dd29e834a7c35d5ccfefb84ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuild the name list. <br /></td></tr>
<tr class="separator:ae0c4fd5dd29e834a7c35d5ccfefb84ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab9b3ede9deeafd060d038cedc993b9"><td class="memItemLeft" align="right" valign="top"><a id="a5ab9b3ede9deeafd060d038cedc993b9" name="a5ab9b3ede9deeafd060d038cedc993b9"></a>
idaman void ida_export&#160;</td><td class="memItemRight" valign="bottom"><b>reorder_dummy_names</b> (void)</td></tr>
<tr class="memdesc:a5ab9b3ede9deeafd060d038cedc993b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renumber dummy names. <br /></td></tr>
<tr class="separator:a5ab9b3ede9deeafd060d038cedc993b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Functions that deal with names. </p>
<p >A non-tail address of the program may have a name. Tail addresses (i.e. the addresses in the middle of an instruction or data item) cannot have names. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad7882b24fb8463d16e80274851e0e203" name="ad7882b24fb8463d16e80274851e0e203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7882b24fb8463d16e80274851e0e203">&#9670;&nbsp;</a></span>SN_NOCHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SN_NOCHECK&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace invalid characters silently. </p>
<p >If this bit is set, all invalid chars (not in NameChars or MangleChars) will be replaced by '_' List of valid characters is defined in ida.cfg </p>

</div>
</div>
<a id="a68ba63b7a7a9a881df414b7bfdce7447" name="a68ba63b7a7a9a881df414b7bfdce7447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ba63b7a7a9a881df414b7bfdce7447">&#9670;&nbsp;</a></span>SN_NOLIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SN_NOLIST&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if set, exclude name from the list. </p>
<p >if not set, then include the name into the list (however, if other bits are set, the name might be immediately excluded from the list). </p>

</div>
</div>
<a id="a6052ebef5e57c6e905fe9f902188401d" name="a6052ebef5e57c6e905fe9f902188401d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6052ebef5e57c6e905fe9f902188401d">&#9670;&nbsp;</a></span>SN_LOCAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SN_LOCAL&#160;&#160;&#160;0x200</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create local name. </p>
<p >a function should exist. local names can't be public or weak. also they are not included into the list of names they can't have dummy prefixes. </p>

</div>
</div>
<a id="abb4de680eb13eaaf581e4082ce7524f3" name="abb4de680eb13eaaf581e4082ce7524f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4de680eb13eaaf581e4082ce7524f3">&#9670;&nbsp;</a></span>SN_IDBENC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SN_IDBENC&#160;&#160;&#160;0x400</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly. </p>
<p >Specifying SN_IDBENC also implies SN_NODUMMY </p>

</div>
</div>
<a id="a382967c6aac3f869feb3d63c8bbe3a7f" name="a382967c6aac3f869feb3d63c8bbe3a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382967c6aac3f869feb3d63c8bbe3a7f">&#9670;&nbsp;</a></span>SN_NODUMMY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SN_NODUMMY&#160;&#160;&#160;0x1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>automatically prepend the name with '_' if it begins with a dummy suffix such as 'sub_'. </p>
<p >See also SN_IDBENC </p>

</div>
</div>
<a id="a1d81af73461e98bd691ef1337d72a018" name="a1d81af73461e98bd691ef1337d72a018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d81af73461e98bd691ef1337d72a018">&#9670;&nbsp;</a></span>GETN_APPZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GETN_APPZERO&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>meaningful only if the name refers to a structure. </p>
<p >append a struct field name if the field offset is zero? </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab2ce188a7de5d24751a51619142bc3cd" name="ab2ce188a7de5d24751a51619142bc3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ce188a7de5d24751a51619142bc3cd">&#9670;&nbsp;</a></span>debug_name_how_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="name_8hpp.html#ab2ce188a7de5d24751a51619142bc3cd">debug_name_how_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify strategy for retrieving debug names. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab2ce188a7de5d24751a51619142bc3cda07919bfad7fbbe1cbaa5bd395263743b" name="ab2ce188a7de5d24751a51619142bc3cda07919bfad7fbbe1cbaa5bd395263743b"></a>DEBNAME_EXACT&#160;</td><td class="fielddoc"><p >find a name at exactly the specified address </p>
</td></tr>
<tr><td class="fieldname"><a id="ab2ce188a7de5d24751a51619142bc3cda450e6b033e4dfc8132f1afde00d27ff6" name="ab2ce188a7de5d24751a51619142bc3cda450e6b033e4dfc8132f1afde00d27ff6"></a>DEBNAME_LOWER&#160;</td><td class="fielddoc"><p >find a name with the address &gt;= the specified address </p>
</td></tr>
<tr><td class="fieldname"><a id="ab2ce188a7de5d24751a51619142bc3cda234a853dad3bf08d8de43c1039a57901" name="ab2ce188a7de5d24751a51619142bc3cda234a853dad3bf08d8de43c1039a57901"></a>DEBNAME_UPPER&#160;</td><td class="fielddoc"><p >find a name with the address &gt; the specified address </p>
</td></tr>
<tr><td class="fieldname"><a id="ab2ce188a7de5d24751a51619142bc3cda6fe3df259439fb5db48bc7183d736c3f" name="ab2ce188a7de5d24751a51619142bc3cda6fe3df259439fb5db48bc7183d736c3f"></a>DEBNAME_NICE&#160;</td><td class="fielddoc"><p >find a name with the address &lt;= the specified address </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa75fb1ba89bb22f323472e329eb4a486" name="aa75fb1ba89bb22f323472e329eb4a486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75fb1ba89bb22f323472e329eb4a486">&#9670;&nbsp;</a></span>set_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_name </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or delete name of an item at the specified address. </p>
<p >An item can be anything: instruction, function, data byte, word, string, structure, etc... Include name into the list of names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>linear address. do nothing if ea is not valid (return 0). tail bytes can't have names. </td></tr>
    <tr><td class="paramname">name</td><td>new name.<ul>
<li>nullptr: do nothing (return 0).</li>
<li>"" : delete name.</li>
<li>otherwise this is a new name. </li>
</ul>
</td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="group___s_n__.html">Set name flags</a>. If a bit is not specified, then the corresponding action is not performed and the name will retain the same bits as before calling this function. For new names, default is: non-public, non-weak, non-auto. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok, name is changed </td></tr>
    <tr><td class="paramname">0</td><td>failure, a warning is displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa940671bab6958b3772cbf834d9e8d4" name="afa940671bab6958b3772cbf834d9e8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa940671bab6958b3772cbf834d9e8d4">&#9670;&nbsp;</a></span>set_dummy_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export set_dummy_name </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give an autogenerated (dummy) name. </p>
<p >Autogenerated names have special prefixes (loc_...). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>linear address of the operand which references to the address </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok, dummy name is generated or the byte already had a name </td></tr>
    <tr><td class="paramname">0</td><td>failure, invalid address or tail byte </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a023a7105c003b3ed6d812e0ef713539b" name="a023a7105c003b3ed6d812e0ef713539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023a7105c003b3ed6d812e0ef713539b">&#9670;&nbsp;</a></span>validate_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export validate_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nametype_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate a name. </p>
<p >This function replaces all invalid characters in the name with SUBSTCHAR. However, it will return false if name is valid but not allowed to be an identifier (is a register name).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">name</td><td>ptr to name. the name will be modified </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>the type of name we want to validate </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>see SN_* . Only SN_IDBENC is currently considered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="a1cac1f791aadbaf4699c672e2a371483" name="a1cac1f791aadbaf4699c672e2a371483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cac1f791aadbaf4699c672e2a371483">&#9670;&nbsp;</a></span>is_uname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_uname </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is valid user-specified name? (valid name &amp; !dummy prefix). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to test. may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">0</td><td>no </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3271b2d04d48bf0d8b2126cda8152b23" name="a3271b2d04d48bf0d8b2126cda8152b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3271b2d04d48bf0d8b2126cda8152b23">&#9670;&nbsp;</a></span>is_valid_typename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_valid_typename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is valid type name? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to test. may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">0</td><td>no </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7861ff00288a2f91688761305c901d34" name="a7861ff00288a2f91688761305c901d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7861ff00288a2f91688761305c901d34">&#9670;&nbsp;</a></span>dummy_name_ea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export dummy_name_ea </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is dummy name? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to test. may be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> if not, otherwise the address denoted by the name </dd></dl>

</div>
</div>
<a id="a5c3b4ea81944925c0689be2557e2f501" name="a5c3b4ea81944925c0689be2557e2f501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3b4ea81944925c0689be2557e2f501">&#9670;&nbsp;</a></span>extract_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export extract_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a name or address from the specified string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output buffer for the identifier </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">line</td><td>input string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>x coordinate of cursor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if cannot extract. otherwise length of the name </dd></dl>

</div>
</div>
<a id="ad57ff60cd0ee8a0aa6283d88a88743cf" name="ad57ff60cd0ee8a0aa6283d88a88743cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57ff60cd0ee8a0aa6283d88a88743cf">&#9670;&nbsp;</a></span>hide_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman void ida_export hide_name </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove name from the list of names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>address of the name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad14a47ac26d57e3926296e9c0c729075" name="ad14a47ac26d57e3926296e9c0c729075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14a47ac26d57e3926296e9c0c729075">&#9670;&nbsp;</a></span>get_name_ea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_name_ea </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address of a name. </p>
<p >This function resolves a name into an address. It can handle regular global and local names, as well as debugger names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>linear address where the name is used. If specified, the local labels of the function at the specified address will will be checked. <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> means that local names won't be consulted. </td></tr>
    <tr><td class="paramname">name</td><td>any name in the program or nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the name or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a> </dd></dl>

</div>
</div>
<a id="aacdcd86fbe8f292b62b0cb97a749d205" name="aacdcd86fbe8f292b62b0cb97a749d205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdcd86fbe8f292b62b0cb97a749d205">&#9670;&nbsp;</a></span>get_name_base_ea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman ea_t ida_export get_name_base_ea </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address of the name used in the expression for the address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>address of the operand which references to the address </td></tr>
    <tr><td class="paramname">to</td><td>the referenced address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the name used to represent the operand </dd></dl>

</div>
</div>
<a id="a610d30c00b8ec32d1d9147589d75c0a6" name="a610d30c00b8ec32d1d9147589d75c0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610d30c00b8ec32d1d9147589d75c0a6">&#9670;&nbsp;</a></span>get_name_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_name_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value of the name. </p>
<p >This function knows about: regular names, enums, special segments, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>pointer to variable with answer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>linear address where the name is used if not applicable, then should be BADADDR </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>any name in the program or nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___n_t__.html">Name value result codes</a> </dd></dl>

</div>
</div>
<a id="a12648107028fb2927759f78edc8b3e7a" name="a12648107028fb2927759f78edc8b3e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12648107028fb2927759f78edc8b3e7a">&#9670;&nbsp;</a></span>get_ea_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_ea_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gtn_flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgetname__info__t.html">getname_info_t</a> *&#160;</td>
          <td class="paramname"><em>gtni</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name at the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>buffer to hold the name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gtn_flags</td><td>how exactly the name should be retrieved. combination of <a class="el" href="group___g_n__.html">bits for get_ea_name() function. There is a convenience</a> bits </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gtni</td><td>additional information for name demangling Please use the convenience functions declared below instead of calling get_ea_name directly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a id="aabdd8c2bcc41b1246c83c020eee512c0" name="aabdd8c2bcc41b1246c83c020eee512c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdd8c2bcc41b1246c83c020eee512c0">&#9670;&nbsp;</a></span>get_name_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="kernwin_8hpp.html#a051016ac92685c95d47a7c1850c19632">color_t</a> ida_export get_name_color </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate flags for <a class="el" href="name_8hpp.html#a12648107028fb2927759f78edc8b3e7a" title="Get name at the specified address.">get_ea_name()</a> function. </p>
<p >Get name color. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>linear address where the name is used. if not applicable, then should be <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39;">BADADDR</a>. The kernel returns a local name color if the reference is within a function, i.e. 'from' and 'ea' belong to the same function. </td></tr>
    <tr><td class="paramname">ea</td><td>linear address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dbd29ee7ba50fa1d5ccf46922757b70" name="a5dbd29ee7ba50fa1d5ccf46922757b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbd29ee7ba50fa1d5ccf46922757b70">&#9670;&nbsp;</a></span>get_name_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_name_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aef265b11f25357d520dcfd40aa8c18f3">uval_t</a>&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="name_8hpp.html#a1d81af73461e98bd691ef1337d72a018">GETN_APPZERO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert address to name expression (name with a displacement). </p>
<p >This function takes into account fixup information and returns a colored name expression (in the form &lt;name&gt; +/- &lt;offset&gt;). It also knows about structure members and arrays. If the specified address doesn't have a name, a dummy name is generated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output buffer for the name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">from</td><td>linear address of instruction operand or data referring to the name. This address will be used to get fixup information, so it should point to exact position of the operand in the instruction. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>number of referencing operand. for data items specify 0 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ea</td><td>address to convert to name expression </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">off</td><td>the value of name expression. this parameter is used only to check that the name expression will have the wanted value. 'off' may be equal to BADADDR but this is discouraged because it prohibits checks. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td><a class="el" href="group___g_e_t_n__.html">Name expression flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if address is not valid, no segment or other failure. otherwise the length of the name expression in characters. </dd></dl>

</div>
</div>
<a id="ad76ccaa62d5c6280ad61dcd372eaa44f" name="ad76ccaa62d5c6280ad61dcd372eaa44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76ccaa62d5c6280ad61dcd372eaa44f">&#9670;&nbsp;</a></span>get_nice_colored_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> ida_export get_nice_colored_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a nice colored name at the specified address. </p>
<p >Ex:</p><ul>
<li>segment:sub+offset</li>
<li>segment:sub:local_label</li>
<li>segment:label</li>
<li>segment:address</li>
<li>segment:address+offset <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer to hold the name </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ea</td><td>linear address </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td><a class="el" href="group___g_n_c_n__.html">Nice colored name flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the generated name in bytes. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="af487ec35c909e6fcd3ce06ccaaea6e58" name="af487ec35c909e6fcd3ce06ccaaea6e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af487ec35c909e6fcd3ce06ccaaea6e58">&#9670;&nbsp;</a></span>append_struct_fields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a> ida_export append_struct_fields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adiff_t *&#160;</td>
          <td class="paramname"><em>disp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#aa0929693b8649ee524795605e66a6533">flags64_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adiff_t&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appzero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append names of struct fields to a name if the name is a struct name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>pointer to the output buffer </td></tr>
    <tr><td class="paramname">disp</td><td>displacement from the name </td></tr>
    <tr><td class="paramname">n</td><td>operand number in which the name appears </td></tr>
    <tr><td class="paramname">path</td><td>path in the struct. path is an array of id's. maximal length of array is <a class="el" href="nalt_8hpp.html#a0be69d167c3b2004f3b786540982e174" title="maximal inclusion depth of unions">MAXSTRUCPATH</a>. the first element of the array is the structure id. consecutive elements are id's of used union members (if any). </td></tr>
    <tr><td class="paramname">plen</td><td>size of path array </td></tr>
    <tr><td class="paramname">flags</td><td>the input flags. they will be returned if the struct cannot be found. </td></tr>
    <tr><td class="paramname">delta</td><td>delta to add to displacement </td></tr>
    <tr><td class="paramname">appzero</td><td>should append a struct field name if the displacement is zero? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>flags of the innermost struct member or the input flags </dd></dl>

</div>
</div>
<a id="acab6142412589f0a1ce6fad1b372e479" name="acab6142412589f0a1ce6fad1b372e479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab6142412589f0a1ce6fad1b372e479">&#9670;&nbsp;</a></span>get_struct_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman int ida_export get_struct_operand </td>
          <td>(</td>
          <td class="paramtype">adiff_t *&#160;</td>
          <td class="paramname"><em>disp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">adiff_t *&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec">tid_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get offset within a structure if the operand refers to structure. </p>
<p >Ex: </p><pre class="fragment">mov ax, somedata.field5-2 (before it was max ax, 3) </pre><p> for this instruction, op #1 the function will return</p><ul>
<li>disp: the value of 'field5', i.e. 5</li>
<li>delta: -2</li>
<li>path: the existing path if any <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disp</td><td>pointer to displacement (answer will be here) </td></tr>
    <tr><td class="paramname">delta</td><td>pointer to displacement delta (answer will be here) </td></tr>
    <tr><td class="paramname">path</td><td>existing strpath (if any) </td></tr>
    <tr><td class="paramname">ea</td><td>linear address of instruction/data </td></tr>
    <tr><td class="paramname">n</td><td>0..<a class="el" href="ida_8hpp.html#ae2018a7cee04a8a790fc5fc445fb473a" title="max number of operands allowed for an instruction">UA_MAXOP</a>-1 operand number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if success, then length of path + 1. if failed, then 0. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a571b1f7ad5b466b232fd22d8f63a1d0c" name="a571b1f7ad5b466b232fd22d8f63a1d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571b1f7ad5b466b232fd22d8f63a1d0c">&#9670;&nbsp;</a></span>get_nlist_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman size_t ida_export get_nlist_idx </td>
          <td>(</td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get index of the name in the list. </p>
<dl class="section warning"><dt>Warning</dt><dd>returns the closest match. may return idx &gt;= size. </dd></dl>

</div>
</div>
<a id="aa9c7d3ed8cf3b79dca8ee2262c9f3b56" name="aa9c7d3ed8cf3b79dca8ee2262c9f3b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c7d3ed8cf3b79dca8ee2262c9f3b56">&#9670;&nbsp;</a></span>demangle_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman <a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a> ida_export demangle_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>disable_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">demreq_type_t&#160;</td>
          <td class="paramname"><em>demreq</em> = <code>DQT_FULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Demangle a name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output buffer </td></tr>
    <tr><td class="paramname">name</td><td>name to demangle </td></tr>
    <tr><td class="paramname">disable_mask</td><td>bits to inhibit parts of demangled name (see MNG_). by the M_COMPILER bits a specific compiler can be selected (see MT_). </td></tr>
    <tr><td class="paramname">demreq</td><td>the request type demreq_type_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ME_... or MT__ bitmasks from demangle.hpp </dd></dl>

</div>
</div>
<a id="a093967cd658d6aa85af7f75a3d56c9da" name="a093967cd658d6aa85af7f75a3d56c9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093967cd658d6aa85af7f75a3d56c9da">&#9670;&nbsp;</a></span>is_name_defined_locally()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">idaman bool ida_export is_name_defined_locally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfunc__t.html">func_t</a> *&#160;</td>
          <td class="paramname"><em>pfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="name_8hpp.html#a1c11cf6f91e87c2f20aa0ead93361a56">ignore_name_def_t</a>&#160;</td>
          <td class="paramname"><em>ignore_name_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea1</em> = <code><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ea_t&#160;</td>
          <td class="paramname"><em>ea2</em> = <code><a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f">BADADDR</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the name defined locally in the specified function? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function </td></tr>
    <tr><td class="paramname">name</td><td>name to check </td></tr>
    <tr><td class="paramname">ignore_name_def</td><td>which names to ignore when checking </td></tr>
    <tr><td class="paramname">ea1</td><td>the starting address of the range inside the function (optional) </td></tr>
    <tr><td class="paramname">ea2</td><td>the ending address of the range inside the function (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the name has been defined </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
